# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _rust_call_async(scaffolding_fn, callback_fn, *args):
    # Call the scaffolding function, passing it a callback handler for `AsyncTypes.py` and a pointer
    # to a python Future object.  The async function then awaits the Future.
    uniffi_eventloop = asyncio.get_running_loop()
    uniffi_py_future = uniffi_eventloop.create_future()
    uniffi_call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))
    scaffolding_fn(*args,
       _UniffiConverterForeignExecutor._pointer_manager.new_pointer(uniffi_eventloop),
       callback_fn,
       # Note: It's tempting to skip the pointer manager and just use a `py_object` pointing to a
       # local variable like we do in Swift.  However, Python doesn't use cooperative cancellation
       # -- asyncio can cancel a task at anytime.  This means if we use a local variable, the Rust
       # callback could fire with a dangling pointer.
       _UniffiPyFuturePointerManager.new_pointer(uniffi_py_future),
       ctypes.byref(uniffi_call_status),
    )
    _uniffi_check_call_status(None, uniffi_call_status)
    return uniffi_py_future

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))
class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.write_unchecked(cls.check(value), buf)

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
_UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("uniffi_radix_engine_toolkit_uniffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 22
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information() != 17662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key() != 19647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address() != 45205:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address() != 11639:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address() != 24509:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key() != 36758:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key() != 11003:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key() != 61146:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_hash() != 16303:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses() != 16813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation() != 19578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode() != 54114:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode() != 11090:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str() != 10663:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str() != 27404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode() != 5482:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode() != 44017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation() != 11831:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event() != 43789:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation() != 50232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic() != 25407:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and() != 5785:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or() != 27266:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string() != 5709:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str() != 38197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes() != 16699:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type() != 40172:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global() != 25808:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component() != 58252:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager() != 48841:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager() != 55847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager() != 16959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package() != 10761:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager() != 34705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual() != 44552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal() != 34745:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault() != 26605:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store() != 4366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault() != 30524:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault() != 10507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id() != 20026:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs() != 47552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add() != 29792:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str() != 18253:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt() != 31267:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling() != 53104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div() != 7427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal() != 45597:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor() != 17697:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than() != 16609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal() != 3170:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative() != 27762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive() != 15349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero() != 27694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than() != 30546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal() != 2387:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul() != 52430:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal() != 61801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root() != 6178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi() != 11213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round() != 685:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt() != 43295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub() != 15109:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str() != 46597:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes() != 57303:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str() != 2403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list() != 45845:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id() != 55489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile() != 31325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash() != 993:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header() != 49719:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash() != 63530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest() != 60823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message() != 49610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate() != 18502:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit() != 58477:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch() != 3828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort() != 14294:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund() != 51871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort() != 44832:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund() != 50194:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address() != 18604:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains() != 37738:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any() != 20665:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles() != 58282:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build() != 36705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource() != 52445:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method() != 19399:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method() != 53674:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function() != 38619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method() != 42239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method() != 39370:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method() != 25488:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof() != 52407:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_access_controller_with_securify_structure() != 12292:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_account_advanced() != 27856:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager() != 45955:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all() != 51538:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount() != 51265:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles() != 49166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all() != 46129:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount() != 20827:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles() != 25333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_signature_based_access_controller() != 47497:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs() != 12341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs() != 63484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs() != 2952:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof() != 29894:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd() != 59721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee() != 5856:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible() != 41635:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone() != 54385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_publish_package() != 13228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone() != 59668:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop() != 48542:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_metadata() != 4065:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_role() != 58550:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop() != 61948:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop() != 7334:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop() != 49676:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_from_account() != 4369:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_non_fungibles_from_account() != 36610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors() != 45350:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length() != 10753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length() != 15824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length() != 53437:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str() != 12617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id() != 42729:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address() != 26038:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile() != 65183:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash() != 64270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash() != 51688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash() != 17757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature() != 46873:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent() != 11409:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash() != 60604:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate() != 11188:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str() != 211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key() != 33649:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs() != 2924:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add() != 36087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str() != 50135:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt() != 60153:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling() != 35397:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div() != 55154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal() != 35658:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor() != 37447:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than() != 21292:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal() != 34931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative() != 11588:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive() != 30868:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero() != 41566:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than() != 50862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal() != 33893:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul() != 61496:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal() != 17368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root() != 60037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi() != 1798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round() != 38035:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt() != 18565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub() != 15847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key() != 49403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign() != 21427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature() != 4246:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key() != 41168:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile() != 26394:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash() != 60260:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent() != 19540:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash() != 9462:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures() != 46037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash() != 20757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate() != 27682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header() != 40383:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest() != 8446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key() != 57025:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer() != 32547:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key() != 29671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer() != 17372:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message() != 55782:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key() != 60073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer() != 21713:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash() != 1343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str() != 9829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes() != 40875:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id() != 4187:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into() != 33560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth() != 31236:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from() != 1186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_analyze_execution() != 28095:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs() != 55127:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses() != 5474:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth() != 1239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions() != 3783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify() != 4850:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate() != 42656:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_cost_unit_limit() != 3389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range() != 31430:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size() != 39564:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage() != 28981:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation() != 52946:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_cost_unit_limit() != 51406:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage() != 2069:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id() != 63098:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all() != 26074:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all() != 40312:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require() != 10110:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of() != 11748:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount() != 34714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of() != 30352:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of() != 59472:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature() != 41270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw() != 43797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new() != 37549:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address() != 64771:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address() != 31070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key() != 738:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key() != 32432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max() != 38313:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min() != 18079:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new() != 15617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one() != 42470:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero() != 39451:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string() != 64410:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes() != 17030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new() != 17594:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions() != 51039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string() != 47420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile() != 565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new() != 4284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new() != 30710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default() != 54905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new() != 60275:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts() != 36478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new() != 58056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge() != 22546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile() != 58667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new() != 56154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new() != 12724:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max() != 49495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min() != 4453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new() != 34846:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one() != 9121:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero() != 5648:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new() != 47612:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519() != 4005:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1() != 20991:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile() != 12765:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new() != 36392:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new() != 46196:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str() != 37610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new() != 62865:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default() != 1435:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new() != 20792:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign() != 46892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature() != 15804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key() != 9393:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key() != 61195:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of.argtypes = (
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_address.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id.restype = ctypes.c_uint8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_hash.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id.restype = ctypes.c_uint8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_intent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_intent.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_access_controller_with_securify_structure.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_access_controller_with_securify_structure.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_account_advanced.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_account_advanced.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_signature_based_access_controller.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_signature_based_access_controller.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_publish_package.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_publish_package.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_role.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_role.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_from_account.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_from_account.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_non_fungibles_from_account.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_non_fungibles_from_account.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors.restype = ctypes.c_uint64
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length.restype = ctypes.c_uint64
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length.restype = ctypes.c_uint64
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length.restype = ctypes.c_uint64
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id.restype = ctypes.c_uint8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_analyze_execution.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_analyze_execution.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new.argtypes = (
    ctypes.c_uint8,
    ctypes.c_uint64,
    ctypes.c_uint32,
    ctypes.c_uint32,
    ctypes.c_uint16,
    ctypes.c_uint16,
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_cost_unit_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_cost_unit_limit.restype = ctypes.c_uint32
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range.restype = ctypes.c_uint64
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_cost_unit_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_cost_unit_limit.restype = ctypes.c_uint32
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id.restype = ctypes.c_uint8
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer.argtypes = (
    _UNIFFI_FOREIGN_CALLBACK_T,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer.restype = None
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_build_information.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_build_information.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_hash.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_free.restype = None
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_build_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_olympia_account_address_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_public_key_from_olympia_account_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_resource_address_from_olympia_resource_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_olympia_account_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_account_address_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_identity_address_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_derive_virtual_signature_non_fungible_global_id_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_known_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_manifest_sbor_decode_to_string_representation.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_decode.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_metadata_sbor_encode.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_decode.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_non_fungible_local_id_sbor_encode.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_string_representation.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_sbor_decode_to_typed_native_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_scrypto_sbor_decode_to_string_representation.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_func_test_panic.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_and.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_accessrule_or.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_address_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_entity_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_component.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_consensus_manager.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_fungible_resource_manager.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_non_fungible_resource_manager.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_resource_manager.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_global_virtual.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_fungible_vault.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_kv_store.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_non_fungible_vault.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_is_internal_vault.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_address_network_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_abs.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_add.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_cbrt.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_ceiling.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_div.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_floor.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_greater_than_or_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_negative.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_positive.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_is_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_less_than_or_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_mul.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_not_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_nth_root.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_powi.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sqrt.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_decimal_sub.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_hash_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_instructions_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_instructions_network_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_compile.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_header.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_intent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_manifest.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_intent_statically_validate.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_deposit_batch.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_batch_or_refund.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_account_try_deposit_or_refund.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_allocate_global_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_any.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_assert_worktop_contains_non_fungibles.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_burn_resource.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_access_rules_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_direct_vault_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_function.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_metadata_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_call_royalty_method.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_clone_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_access_controller_with_securify_structure.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_access_controller_with_securify_structure.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_account_advanced.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_account_advanced.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_fungible_resource_manager.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_signature_based_access_controller.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_create_signature_based_access_controller.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_all_proofs.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_proofs.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_auth_zone_signature_proofs.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_drop_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_free_xrd.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_faucet_lock_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_mint_fungible.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_pop_from_auth_zone.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_publish_package.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_publish_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_push_to_auth_zone.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_return_to_worktop.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_metadata.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_role.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_set_role.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_all_from_worktop.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_from_worktop.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_take_non_fungibles_from_worktop.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_from_account.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_from_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_non_fungibles_from_account.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_manifestbuilder_withdraw_non_fungibles_from_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_decryptors.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_encrypted_message_length.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_mime_type_length.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_messagevalidationconfig_max_plaintext_message_length.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_local_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_nonfungibleglobalid_resource_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_compile.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_intent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notarized_transaction_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_notary_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_signed_intent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_notarizedtransaction_statically_validate.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_olympiaaddress_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_abs.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_add.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_cbrt.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_ceiling.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_div.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_floor.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_greater_than_or_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_negative.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_positive.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_is_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_less_than_or_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_mul.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_not_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_nth_root.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_powi.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sqrt.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_precisedecimal_sub.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_privatekey_sign_to_signature_with_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_compile.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_intent_signatures.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_signed_intent_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signedintent_statically_validate.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilder_header.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderheaderstep_manifest.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_private_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_notarize_with_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_private_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuilderintentsignaturesstep_sign_with_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_private_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionbuildermessagestep_sign_with_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionhash_network_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_deposited_into.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_requiring_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_accounts_withdrawn_from.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_analyze_execution.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_analyze_execution.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_blobs.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_extract_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_identities_requiring_auth.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_instructions.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_modify.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_transactionmanifest_statically_validate.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_cost_unit_limit.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_cost_unit_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_epoch_range.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_notarized_payload_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_max_tip_percentage.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_message_validation.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_cost_unit_limit.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_cost_unit_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_min_tip_percentage.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_validationconfig_network_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_allow_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_deny_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_all_of.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_any_of.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_count_of.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_accessrule_require_virtual_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_from_raw.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_resource_address_from_olympia_resource_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_olympia_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_account_address_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_address_virtual_identity_address_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_max.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_min.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_one.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_decimal_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_hex_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_from_unhashed_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_hash_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_instructions.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_instructions_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_decompile.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_intent_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_manifestbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_default.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_messagevalidationconfig_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_from_parts.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_nonfungibleglobalid_virtual_signature_badge.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_decompile.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_notarizedtransaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_olympiaaddress_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_max.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_min.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_one.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_precisedecimal_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_privatekey_new_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_decompile.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_signedintent_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionhash_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_transactionmanifest_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_default.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_constructor_validationconfig_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_sign_to_signature_with_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key.argtypes = (
)
_UniffiLib.uniffi_radix_engine_toolkit_uniffi_checksum_method_signer_public_key.restype = ctypes.c_uint16
_UniffiLib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_radix_engine_toolkit_uniffi_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u8(value)

class _UniffiConverterInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i8"
    VALUE_MIN = -2**7
    VALUE_MAX = 2**7

    @staticmethod
    def read(buf):
        return buf.read_i8()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u16(value)

class _UniffiConverterInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i16"
    VALUE_MIN = -2**15
    VALUE_MAX = 2**15

    @staticmethod
    def read(buf):
        return buf.read_i16()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write_unchecked(value, buf):
        buf.write_i64(value)

class _UniffiConverterBool(_UniffiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write_unchecked(cls, value, buf):
        buf.write_u8(value)

    @staticmethod
    def lift(value):
        return value != 0

class _UniffiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = _UniffiConverterString.check(value)
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = _UniffiConverterString.check(value)
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class AccessRule:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_accessrule, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def allow_all(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_allow_all,)
        return cls._make_instance_(pointer)


    @classmethod
    def deny_all(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_deny_all,)
        return cls._make_instance_(pointer)


    @classmethod
    def require(cls, resource_or_non_fungible: "ResourceOrNonFungible"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require,
        _UniffiConverterTypeResourceOrNonFungible.lower(resource_or_non_fungible))
        return cls._make_instance_(pointer)


    @classmethod
    def require_all_of(cls, resources: "typing.List[ResourceOrNonFungible]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_all_of,
        _UniffiConverterSequenceTypeResourceOrNonFungible.lower(resources))
        return cls._make_instance_(pointer)


    @classmethod
    def require_amount(cls, amount: "Decimal",resource: "Address"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_amount,
        _UniffiConverterTypeDecimal.lower(amount),
        _UniffiConverterTypeAddress.lower(resource))
        return cls._make_instance_(pointer)


    @classmethod
    def require_any_of(cls, resources: "typing.List[ResourceOrNonFungible]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_any_of,
        _UniffiConverterSequenceTypeResourceOrNonFungible.lower(resources))
        return cls._make_instance_(pointer)


    @classmethod
    def require_count_of(cls, count: "int",resources: "typing.List[ResourceOrNonFungible]"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_count_of,
        _UniffiConverterUInt8.lower(count),
        _UniffiConverterSequenceTypeResourceOrNonFungible.lower(resources))
        return cls._make_instance_(pointer)


    @classmethod
    def require_virtual_signature(cls, public_key: "PublicKey"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_accessrule_require_virtual_signature,
        _UniffiConverterTypePublicKey.lower(public_key))
        return cls._make_instance_(pointer)



    def _and(self, other: "AccessRule") -> "AccessRule":
        
        return _UniffiConverterTypeAccessRule.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_and,self._pointer,
        _UniffiConverterTypeAccessRule.lower(other))
        )






    def _or(self, other: "AccessRule") -> "AccessRule":
        
        return _UniffiConverterTypeAccessRule.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_accessrule_or,self._pointer,
        _UniffiConverterTypeAccessRule.lower(other))
        )






class _UniffiConverterTypeAccessRule:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, AccessRule):
            raise TypeError("Expected AccessRule instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return AccessRule._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Address:
    _pointer: ctypes.c_void_p
    def __init__(self, address: "str"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_new,
        _UniffiConverterString.lower(address))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_address, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_raw(cls, node_id_bytes: "typing.List[int]",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_from_raw,
        _UniffiConverterSequenceUInt8.lower(node_id_bytes),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)


    @classmethod
    def resource_address_from_olympia_resource_address(cls, olympia_resource_address: "OlympiaAddress",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_resource_address_from_olympia_resource_address,
        _UniffiConverterTypeOlympiaAddress.lower(olympia_resource_address),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)


    @classmethod
    def virtual_account_address_from_olympia_address(cls, olympia_account_address: "OlympiaAddress",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_olympia_address,
        _UniffiConverterTypeOlympiaAddress.lower(olympia_account_address),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)


    @classmethod
    def virtual_account_address_from_public_key(cls, public_key: "PublicKey",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_account_address_from_public_key,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)


    @classmethod
    def virtual_identity_address_from_public_key(cls, public_key: "PublicKey",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_address_virtual_identity_address_from_public_key,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)



    def address_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_address_string,self._pointer,)
        )






    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_as_str,self._pointer,)
        )






    def bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_bytes,self._pointer,)
        )






    def entity_type(self, ) -> "EntityType":
        return _UniffiConverterTypeEntityType.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_entity_type,self._pointer,)
        )






    def is_global(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global,self._pointer,)
        )






    def is_global_component(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_component,self._pointer,)
        )






    def is_global_consensus_manager(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_consensus_manager,self._pointer,)
        )






    def is_global_fungible_resource_manager(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_fungible_resource_manager,self._pointer,)
        )






    def is_global_non_fungible_resource_manager(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_non_fungible_resource_manager,self._pointer,)
        )






    def is_global_package(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_package,self._pointer,)
        )






    def is_global_resource_manager(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_resource_manager,self._pointer,)
        )






    def is_global_virtual(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_global_virtual,self._pointer,)
        )






    def is_internal(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal,self._pointer,)
        )






    def is_internal_fungible_vault(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_fungible_vault,self._pointer,)
        )






    def is_internal_kv_store(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_kv_store,self._pointer,)
        )






    def is_internal_non_fungible_vault(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_non_fungible_vault,self._pointer,)
        )






    def is_internal_vault(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_is_internal_vault,self._pointer,)
        )






    def network_id(self, ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_address_network_id,self._pointer,)
        )






class _UniffiConverterTypeAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Address._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Decimal:
    _pointer: ctypes.c_void_p
    def __init__(self, value: "str"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_new,
        _UniffiConverterString.lower(value))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_decimal, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def max(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_max,)
        return cls._make_instance_(pointer)


    @classmethod
    def min(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_min,)
        return cls._make_instance_(pointer)


    @classmethod
    def one(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_one,)
        return cls._make_instance_(pointer)


    @classmethod
    def zero(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_decimal_zero,)
        return cls._make_instance_(pointer)



    def abs(self, ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_abs,self._pointer,)
        )






    def add(self, other: "Decimal") -> "Decimal":
        
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_add,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_as_str,self._pointer,)
        )






    def cbrt(self, ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_cbrt,self._pointer,)
        )






    def ceiling(self, ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_ceiling,self._pointer,)
        )






    def div(self, other: "Decimal") -> "Decimal":
        
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_div,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def equal(self, other: "Decimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_equal,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def floor(self, ) -> "Decimal":
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_floor,self._pointer,)
        )






    def greater_than(self, other: "Decimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def greater_than_or_equal(self, other: "Decimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_greater_than_or_equal,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def is_negative(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_negative,self._pointer,)
        )






    def is_positive(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_positive,self._pointer,)
        )






    def is_zero(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_is_zero,self._pointer,)
        )






    def less_than(self, other: "Decimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def less_than_or_equal(self, other: "Decimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_less_than_or_equal,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def mul(self, other: "Decimal") -> "Decimal":
        
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_mul,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def not_equal(self, other: "Decimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_not_equal,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






    def nth_root(self, n: "int") -> "typing.Optional[Decimal]":
        
        return _UniffiConverterOptionalTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_nth_root,self._pointer,
        _UniffiConverterUInt32.lower(n))
        )






    def powi(self, exp: "int") -> "Decimal":
        
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_powi,self._pointer,
        _UniffiConverterInt64.lower(exp))
        )






    def round(self, decimal_places: "int",rounding_mode: "RoundingMode") -> "Decimal":
        
        
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_round,self._pointer,
        _UniffiConverterInt32.lower(decimal_places),
        _UniffiConverterTypeRoundingMode.lower(rounding_mode))
        )






    def sqrt(self, ) -> "typing.Optional[Decimal]":
        return _UniffiConverterOptionalTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sqrt,self._pointer,)
        )






    def sub(self, other: "Decimal") -> "Decimal":
        
        return _UniffiConverterTypeDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_decimal_sub,self._pointer,
        _UniffiConverterTypeDecimal.lower(other))
        )






class _UniffiConverterTypeDecimal:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Decimal):
            raise TypeError("Expected Decimal instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Decimal._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Hash:
    _pointer: ctypes.c_void_p
    def __init__(self, hash: "typing.List[int]"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_new,
        _UniffiConverterSequenceUInt8.lower(hash))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_hash, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_hex_string(cls, hash: "str"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_hex_string,
        _UniffiConverterString.lower(hash))
        return cls._make_instance_(pointer)


    @classmethod
    def from_unhashed_bytes(cls, bytes: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_hash_from_unhashed_bytes,
        _UniffiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)



    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_as_str,self._pointer,)
        )






    def bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_hash_bytes,self._pointer,)
        )






class _UniffiConverterTypeHash:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Hash):
            raise TypeError("Expected Hash instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Hash._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Instructions:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_instructions, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_instructions(cls, instructions: "typing.List[Instruction]",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_instructions,
        _UniffiConverterSequenceTypeInstruction.lower(instructions),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)


    @classmethod
    def from_string(cls, string: "str",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_instructions_from_string,
        _UniffiConverterString.lower(string),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)



    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_as_str,self._pointer,)
        )






    def instructions_list(self, ) -> "typing.List[Instruction]":
        return _UniffiConverterSequenceTypeInstruction.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_instructions_list,self._pointer,)
        )






    def network_id(self, ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_instructions_network_id,self._pointer,)
        )






class _UniffiConverterTypeInstructions:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Instructions):
            raise TypeError("Expected Instructions instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Instructions._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Intent:
    _pointer: ctypes.c_void_p
    def __init__(self, header: "TransactionHeader",manifest: "TransactionManifest",message: "Message"):
        
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_new,
        _UniffiConverterTypeTransactionHeader.lower(header),
        _UniffiConverterTypeTransactionManifest.lower(manifest),
        _UniffiConverterTypeMessage.lower(message))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_intent, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled_intent: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_intent_decompile,
        _UniffiConverterSequenceUInt8.lower(compiled_intent))
        return cls._make_instance_(pointer)



    def compile(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_compile,self._pointer,)
        )






    def hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_hash,self._pointer,)
        )






    def header(self, ) -> "TransactionHeader":
        return _UniffiConverterTypeTransactionHeader.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_header,self._pointer,)
        )






    def intent_hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_intent_hash,self._pointer,)
        )






    def manifest(self, ) -> "TransactionManifest":
        return _UniffiConverterTypeTransactionManifest.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_manifest,self._pointer,)
        )






    def message(self, ) -> "Message":
        return _UniffiConverterTypeMessage.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_message,self._pointer,)
        )






    def statically_validate(self, validation_config: "ValidationConfig"):
        
        _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_intent_statically_validate,self._pointer,
        _UniffiConverterTypeValidationConfig.lower(validation_config))







class _UniffiConverterTypeIntent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Intent):
            raise TypeError("Expected Intent instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Intent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ManifestBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_manifestbuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_manifestbuilder, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def account_deposit(self, account_address: "Address",bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket))
        )






    def account_deposit_batch(self, account_address: "Address") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_deposit_batch,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address))
        )






    def account_try_deposit_batch_or_abort(self, account_address: "Address",authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_abort,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterOptionalTypeResourceOrNonFungible.lower(authorized_depositor_badge))
        )






    def account_try_deposit_batch_or_refund(self, account_address: "Address",authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_batch_or_refund,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterOptionalTypeResourceOrNonFungible.lower(authorized_depositor_badge))
        )






    def account_try_deposit_or_abort(self, account_address: "Address",authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_abort,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterOptionalTypeResourceOrNonFungible.lower(authorized_depositor_badge),
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket))
        )






    def account_try_deposit_or_refund(self, account_address: "Address",authorized_depositor_badge: "typing.Optional[ResourceOrNonFungible]",bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_account_try_deposit_or_refund,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterOptionalTypeResourceOrNonFungible.lower(authorized_depositor_badge),
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket))
        )






    def allocate_global_address(self, package_address: "Address",blueprint_name: "str",into_address_reservation: "ManifestBuilderAddressReservation",into_named_address: "ManifestBuilderNamedAddress") -> "ManifestBuilder":
        
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_allocate_global_address,self._pointer,
        _UniffiConverterTypeAddress.lower(package_address),
        _UniffiConverterString.lower(blueprint_name),
        _UniffiConverterTypeManifestBuilderAddressReservation.lower(into_address_reservation),
        _UniffiConverterTypeManifestBuilderNamedAddress.lower(into_named_address))
        )






    def assert_worktop_contains(self, resource_address: "Address",amount: "Decimal") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeDecimal.lower(amount))
        )






    def assert_worktop_contains_any(self, resource_address: "Address") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_any,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address))
        )






    def assert_worktop_contains_non_fungibles(self, resource_address: "Address",ids: "typing.List[NonFungibleLocalId]") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_assert_worktop_contains_non_fungibles,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids))
        )






    def build(self, network_id: "int") -> "TransactionManifest":
        
        return _UniffiConverterTypeTransactionManifest.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_build,self._pointer,
        _UniffiConverterUInt8.lower(network_id))
        )






    def burn_resource(self, bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_burn_resource,self._pointer,
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket))
        )






    def call_access_rules_method(self, address: "ManifestBuilderAddress",method_name: "str",args: "typing.List[ManifestBuilderValue]") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_access_rules_method,self._pointer,
        _UniffiConverterTypeManifestBuilderAddress.lower(address),
        _UniffiConverterString.lower(method_name),
        _UniffiConverterSequenceTypeManifestBuilderValue.lower(args))
        )






    def call_direct_vault_method(self, address: "Address",method_name: "str",args: "typing.List[ManifestBuilderValue]") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_direct_vault_method,self._pointer,
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterString.lower(method_name),
        _UniffiConverterSequenceTypeManifestBuilderValue.lower(args))
        )






    def call_function(self, address: "ManifestBuilderAddress",blueprint_name: "str",function_name: "str",args: "typing.List[ManifestBuilderValue]") -> "ManifestBuilder":
        
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_function,self._pointer,
        _UniffiConverterTypeManifestBuilderAddress.lower(address),
        _UniffiConverterString.lower(blueprint_name),
        _UniffiConverterString.lower(function_name),
        _UniffiConverterSequenceTypeManifestBuilderValue.lower(args))
        )






    def call_metadata_method(self, address: "ManifestBuilderAddress",method_name: "str",args: "typing.List[ManifestBuilderValue]") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_metadata_method,self._pointer,
        _UniffiConverterTypeManifestBuilderAddress.lower(address),
        _UniffiConverterString.lower(method_name),
        _UniffiConverterSequenceTypeManifestBuilderValue.lower(args))
        )






    def call_method(self, address: "ManifestBuilderAddress",method_name: "str",args: "typing.List[ManifestBuilderValue]") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_method,self._pointer,
        _UniffiConverterTypeManifestBuilderAddress.lower(address),
        _UniffiConverterString.lower(method_name),
        _UniffiConverterSequenceTypeManifestBuilderValue.lower(args))
        )






    def call_royalty_method(self, address: "ManifestBuilderAddress",method_name: "str",args: "typing.List[ManifestBuilderValue]") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_call_royalty_method,self._pointer,
        _UniffiConverterTypeManifestBuilderAddress.lower(address),
        _UniffiConverterString.lower(method_name),
        _UniffiConverterSequenceTypeManifestBuilderValue.lower(args))
        )






    def clone_proof(self, proof: "ManifestBuilderProof",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_clone_proof,self._pointer,
        _UniffiConverterTypeManifestBuilderProof.lower(proof),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_access_controller_with_securify_structure(self, controlled_asset: "ManifestBuilderBucket",primary_role: "SecurityStructureRole",recovery_role: "SecurityStructureRole",confirmation_role: "SecurityStructureRole",timed_recovery_delay_in_minutes: "typing.Optional[int]") -> "ManifestBuilder":
        
        
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_access_controller_with_securify_structure,self._pointer,
        _UniffiConverterTypeManifestBuilderBucket.lower(controlled_asset),
        _UniffiConverterTypeSecurityStructureRole.lower(primary_role),
        _UniffiConverterTypeSecurityStructureRole.lower(recovery_role),
        _UniffiConverterTypeSecurityStructureRole.lower(confirmation_role),
        _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes))
        )






    def create_account_advanced(self, owner_role: "OwnerRole") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_account_advanced,self._pointer,
        _UniffiConverterTypeOwnerRole.lower(owner_role))
        )






    def create_fungible_resource_manager(self, owner_role: "OwnerRole",track_total_supply: "bool",divisibility: "int",initial_supply: "typing.Optional[Decimal]",resource_roles: "FungibleResourceRoles",metadata: "MetadataModuleConfig",address_reservation: "typing.Optional[ManifestBuilderAddressReservation]") -> "ManifestBuilder":
        
        
        
        
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_fungible_resource_manager,self._pointer,
        _UniffiConverterTypeOwnerRole.lower(owner_role),
        _UniffiConverterBool.lower(track_total_supply),
        _UniffiConverterUInt8.lower(divisibility),
        _UniffiConverterOptionalTypeDecimal.lower(initial_supply),
        _UniffiConverterTypeFungibleResourceRoles.lower(resource_roles),
        _UniffiConverterTypeMetadataModuleConfig.lower(metadata),
        _UniffiConverterOptionalTypeManifestBuilderAddressReservation.lower(address_reservation))
        )






    def create_proof_from_auth_zone_of_all(self, resource_address: "Address",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_all,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_proof_from_auth_zone_of_amount(self, resource_address: "Address",amount: "Decimal",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_amount,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeDecimal.lower(amount),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_proof_from_auth_zone_of_non_fungibles(self, resource_address: "Address",ids: "typing.List[NonFungibleLocalId]",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_auth_zone_of_non_fungibles,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_proof_from_bucket_of_all(self, bucket: "ManifestBuilderBucket",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_all,self._pointer,
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_proof_from_bucket_of_amount(self, amount: "Decimal",bucket: "ManifestBuilderBucket",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_amount,self._pointer,
        _UniffiConverterTypeDecimal.lower(amount),
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_proof_from_bucket_of_non_fungibles(self, ids: "typing.List[NonFungibleLocalId]",bucket: "ManifestBuilderBucket",into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_proof_from_bucket_of_non_fungibles,self._pointer,
        _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket),
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def create_signature_based_access_controller(self, controlled_asset: "ManifestBuilderBucket",primary_role: "PublicKey",recovery_role: "PublicKey",confirmation_role: "PublicKey",timed_recovery_delay_in_minutes: "typing.Optional[int]") -> "ManifestBuilder":
        
        
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_create_signature_based_access_controller,self._pointer,
        _UniffiConverterTypeManifestBuilderBucket.lower(controlled_asset),
        _UniffiConverterTypePublicKey.lower(primary_role),
        _UniffiConverterTypePublicKey.lower(recovery_role),
        _UniffiConverterTypePublicKey.lower(confirmation_role),
        _UniffiConverterOptionalUInt32.lower(timed_recovery_delay_in_minutes))
        )






    def drop_all_proofs(self, ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_all_proofs,self._pointer,)
        )






    def drop_auth_zone_proofs(self, ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_proofs,self._pointer,)
        )






    def drop_auth_zone_signature_proofs(self, ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_auth_zone_signature_proofs,self._pointer,)
        )






    def drop_proof(self, proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_drop_proof,self._pointer,
        _UniffiConverterTypeManifestBuilderProof.lower(proof))
        )






    def faucet_free_xrd(self, ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_free_xrd,self._pointer,)
        )






    def faucet_lock_fee(self, ) -> "ManifestBuilder":
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_faucet_lock_fee,self._pointer,)
        )






    def mint_fungible(self, resource_address: "Address",amount: "Decimal") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_mint_fungible,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeDecimal.lower(amount))
        )






    def pop_from_auth_zone(self, into_proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_pop_from_auth_zone,self._pointer,
        _UniffiConverterTypeManifestBuilderProof.lower(into_proof))
        )






    def publish_package(self, code: "typing.List[int]",definition: "typing.List[int]",metadata: "dict") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_publish_package,self._pointer,
        _UniffiConverterSequenceUInt8.lower(code),
        _UniffiConverterSequenceUInt8.lower(definition),
        _UniffiConverterMapStringTypeMetadataInitEntry.lower(metadata))
        )






    def push_to_auth_zone(self, proof: "ManifestBuilderProof") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_push_to_auth_zone,self._pointer,
        _UniffiConverterTypeManifestBuilderProof.lower(proof))
        )






    def return_to_worktop(self, bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_return_to_worktop,self._pointer,
        _UniffiConverterTypeManifestBuilderBucket.lower(bucket))
        )






    def set_metadata(self, address: "Address",key: "str",value: "MetadataValue") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_metadata,self._pointer,
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterString.lower(key),
        _UniffiConverterTypeMetadataValue.lower(value))
        )






    def set_role(self, address: "Address",module: "ObjectModuleId",role_key: "str",rule: "AccessRule") -> "ManifestBuilder":
        
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_set_role,self._pointer,
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterTypeObjectModuleId.lower(module),
        _UniffiConverterString.lower(role_key),
        _UniffiConverterTypeAccessRule.lower(rule))
        )






    def take_all_from_worktop(self, resource_address: "Address",into_bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_all_from_worktop,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeManifestBuilderBucket.lower(into_bucket))
        )






    def take_from_worktop(self, resource_address: "Address",amount: "Decimal",into_bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_from_worktop,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeDecimal.lower(amount),
        _UniffiConverterTypeManifestBuilderBucket.lower(into_bucket))
        )






    def take_non_fungibles_from_worktop(self, resource_address: "Address",ids: "typing.List[NonFungibleLocalId]",into_bucket: "ManifestBuilderBucket") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_take_non_fungibles_from_worktop,self._pointer,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids),
        _UniffiConverterTypeManifestBuilderBucket.lower(into_bucket))
        )






    def withdraw_from_account(self, account_address: "Address",resource_address: "Address",amount: "Decimal") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_from_account,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeDecimal.lower(amount))
        )






    def withdraw_non_fungibles_from_account(self, account_address: "Address",resource_address: "Address",ids: "typing.List[NonFungibleLocalId]") -> "ManifestBuilder":
        
        
        
        return _UniffiConverterTypeManifestBuilder.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_manifestbuilder_withdraw_non_fungibles_from_account,self._pointer,
        _UniffiConverterTypeAddress.lower(account_address),
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterSequenceTypeNonFungibleLocalId.lower(ids))
        )






class _UniffiConverterTypeManifestBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ManifestBuilder):
            raise TypeError("Expected ManifestBuilder instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ManifestBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class MessageValidationConfig:
    _pointer: ctypes.c_void_p
    def __init__(self, max_plaintext_message_length: "int",max_encrypted_message_length: "int",max_mime_type_length: "int",max_decryptors: "int"):
        
        
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_new,
        _UniffiConverterUInt64.lower(max_plaintext_message_length),
        _UniffiConverterUInt64.lower(max_encrypted_message_length),
        _UniffiConverterUInt64.lower(max_mime_type_length),
        _UniffiConverterUInt64.lower(max_decryptors))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_messagevalidationconfig, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def default(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_messagevalidationconfig_default,)
        return cls._make_instance_(pointer)



    def max_decryptors(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_decryptors,self._pointer,)
        )






    def max_encrypted_message_length(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_encrypted_message_length,self._pointer,)
        )






    def max_mime_type_length(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_mime_type_length,self._pointer,)
        )






    def max_plaintext_message_length(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_messagevalidationconfig_max_plaintext_message_length,self._pointer,)
        )






class _UniffiConverterTypeMessageValidationConfig:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, MessageValidationConfig):
            raise TypeError("Expected MessageValidationConfig instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return MessageValidationConfig._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NonFungibleGlobalId:
    _pointer: ctypes.c_void_p
    def __init__(self, non_fungible_global_id: "str"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_new,
        _UniffiConverterString.lower(non_fungible_global_id))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_nonfungibleglobalid, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_parts(cls, resource_address: "Address",non_fungible_local_id: "NonFungibleLocalId"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_from_parts,
        _UniffiConverterTypeAddress.lower(resource_address),
        _UniffiConverterTypeNonFungibleLocalId.lower(non_fungible_local_id))
        return cls._make_instance_(pointer)


    @classmethod
    def virtual_signature_badge(cls, public_key: "PublicKey",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_nonfungibleglobalid_virtual_signature_badge,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)



    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_as_str,self._pointer,)
        )






    def local_id(self, ) -> "NonFungibleLocalId":
        return _UniffiConverterTypeNonFungibleLocalId.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_local_id,self._pointer,)
        )






    def resource_address(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_nonfungibleglobalid_resource_address,self._pointer,)
        )






class _UniffiConverterTypeNonFungibleGlobalId:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NonFungibleGlobalId):
            raise TypeError("Expected NonFungibleGlobalId instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NonFungibleGlobalId._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class NotarizedTransaction:
    _pointer: ctypes.c_void_p
    def __init__(self, signed_intent: "SignedIntent",notary_signature: "Signature"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_new,
        _UniffiConverterTypeSignedIntent.lower(signed_intent),
        _UniffiConverterTypeSignature.lower(notary_signature))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_notarizedtransaction, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled_notarized_transaction: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_notarizedtransaction_decompile,
        _UniffiConverterSequenceUInt8.lower(compiled_notarized_transaction))
        return cls._make_instance_(pointer)



    def compile(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_compile,self._pointer,)
        )






    def hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_hash,self._pointer,)
        )






    def intent_hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_intent_hash,self._pointer,)
        )






    def notarized_transaction_hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notarized_transaction_hash,self._pointer,)
        )






    def notary_signature(self, ) -> "Signature":
        return _UniffiConverterTypeSignature.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_notary_signature,self._pointer,)
        )






    def signed_intent(self, ) -> "SignedIntent":
        return _UniffiConverterTypeSignedIntent.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent,self._pointer,)
        )






    def signed_intent_hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_signed_intent_hash,self._pointer,)
        )






    def statically_validate(self, validation_config: "ValidationConfig"):
        
        _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_notarizedtransaction_statically_validate,self._pointer,
        _UniffiConverterTypeValidationConfig.lower(validation_config))







class _UniffiConverterTypeNotarizedTransaction:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, NotarizedTransaction):
            raise TypeError("Expected NotarizedTransaction instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return NotarizedTransaction._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class OlympiaAddress:
    _pointer: ctypes.c_void_p
    def __init__(self, address: "str"):
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_olympiaaddress_new,
        _UniffiConverterString.lower(address))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_olympiaaddress, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_as_str,self._pointer,)
        )






    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_olympiaaddress_public_key,self._pointer,)
        )






class _UniffiConverterTypeOlympiaAddress:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, OlympiaAddress):
            raise TypeError("Expected OlympiaAddress instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return OlympiaAddress._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PreciseDecimal:
    _pointer: ctypes.c_void_p
    def __init__(self, value: "str"):
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_new,
        _UniffiConverterString.lower(value))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_precisedecimal, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def max(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_max,)
        return cls._make_instance_(pointer)


    @classmethod
    def min(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_min,)
        return cls._make_instance_(pointer)


    @classmethod
    def one(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_one,)
        return cls._make_instance_(pointer)


    @classmethod
    def zero(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_precisedecimal_zero,)
        return cls._make_instance_(pointer)



    def abs(self, ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_abs,self._pointer,)
        )






    def add(self, other: "PreciseDecimal") -> "PreciseDecimal":
        
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_add,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_as_str,self._pointer,)
        )






    def cbrt(self, ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_cbrt,self._pointer,)
        )






    def ceiling(self, ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_ceiling,self._pointer,)
        )






    def div(self, other: "PreciseDecimal") -> "PreciseDecimal":
        
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_div,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def equal(self, other: "PreciseDecimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_equal,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def floor(self, ) -> "PreciseDecimal":
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_floor,self._pointer,)
        )






    def greater_than(self, other: "PreciseDecimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def greater_than_or_equal(self, other: "PreciseDecimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_greater_than_or_equal,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def is_negative(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_negative,self._pointer,)
        )






    def is_positive(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_positive,self._pointer,)
        )






    def is_zero(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_is_zero,self._pointer,)
        )






    def less_than(self, other: "PreciseDecimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def less_than_or_equal(self, other: "PreciseDecimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_less_than_or_equal,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def mul(self, other: "PreciseDecimal") -> "PreciseDecimal":
        
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_mul,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def not_equal(self, other: "PreciseDecimal") -> "bool":
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_not_equal,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






    def nth_root(self, n: "int") -> "typing.Optional[PreciseDecimal]":
        
        return _UniffiConverterOptionalTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_nth_root,self._pointer,
        _UniffiConverterUInt32.lower(n))
        )






    def powi(self, exp: "int") -> "PreciseDecimal":
        
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_powi,self._pointer,
        _UniffiConverterInt64.lower(exp))
        )






    def round(self, decimal_places: "int",rounding_mode: "RoundingMode") -> "PreciseDecimal":
        
        
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_round,self._pointer,
        _UniffiConverterInt32.lower(decimal_places),
        _UniffiConverterTypeRoundingMode.lower(rounding_mode))
        )






    def sqrt(self, ) -> "typing.Optional[PreciseDecimal]":
        return _UniffiConverterOptionalTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sqrt,self._pointer,)
        )






    def sub(self, other: "PreciseDecimal") -> "PreciseDecimal":
        
        return _UniffiConverterTypePreciseDecimal.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_precisedecimal_sub,self._pointer,
        _UniffiConverterTypePreciseDecimal.lower(other))
        )






class _UniffiConverterTypePreciseDecimal:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PreciseDecimal):
            raise TypeError("Expected PreciseDecimal instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PreciseDecimal._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class PrivateKey:
    _pointer: ctypes.c_void_p
    def __init__(self, bytes: "typing.List[int]",curve: "Curve"):
        
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new,
        _UniffiConverterSequenceUInt8.lower(bytes),
        _UniffiConverterTypeCurve.lower(curve))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_privatekey, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_ed25519(cls, bytes: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_ed25519,
        _UniffiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)


    @classmethod
    def new_secp256k1(cls, bytes: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_privatekey_new_secp256k1,
        _UniffiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_public_key,self._pointer,)
        )






    def sign(self, hash: "Hash") -> "typing.List[int]":
        
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign,self._pointer,
        _UniffiConverterTypeHash.lower(hash))
        )






    def sign_to_signature(self, hash: "Hash") -> "Signature":
        
        return _UniffiConverterTypeSignature.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature,self._pointer,
        _UniffiConverterTypeHash.lower(hash))
        )






    def sign_to_signature_with_public_key(self, hash: "Hash") -> "SignatureWithPublicKey":
        
        return _UniffiConverterTypeSignatureWithPublicKey.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_privatekey_sign_to_signature_with_public_key,self._pointer,
        _UniffiConverterTypeHash.lower(hash))
        )






class _UniffiConverterTypePrivateKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, PrivateKey):
            raise TypeError("Expected PrivateKey instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return PrivateKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SignedIntent:
    _pointer: ctypes.c_void_p
    def __init__(self, intent: "Intent",intent_signatures: "typing.List[SignatureWithPublicKey]"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_new,
        _UniffiConverterTypeIntent.lower(intent),
        _UniffiConverterSequenceTypeSignatureWithPublicKey.lower(intent_signatures))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_signedintent, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def decompile(cls, compiled_signed_intent: "typing.List[int]"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_signedintent_decompile,
        _UniffiConverterSequenceUInt8.lower(compiled_signed_intent))
        return cls._make_instance_(pointer)



    def compile(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_compile,self._pointer,)
        )






    def hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_hash,self._pointer,)
        )






    def intent(self, ) -> "Intent":
        return _UniffiConverterTypeIntent.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent,self._pointer,)
        )






    def intent_hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_hash,self._pointer,)
        )






    def intent_signatures(self, ) -> "typing.List[SignatureWithPublicKey]":
        return _UniffiConverterSequenceTypeSignatureWithPublicKey.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_intent_signatures,self._pointer,)
        )






    def signed_intent_hash(self, ) -> "TransactionHash":
        return _UniffiConverterTypeTransactionHash.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_signed_intent_hash,self._pointer,)
        )






    def statically_validate(self, validation_config: "ValidationConfig"):
        
        _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_signedintent_statically_validate,self._pointer,
        _UniffiConverterTypeValidationConfig.lower(validation_config))







class _UniffiConverterTypeSignedIntent:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SignedIntent):
            raise TypeError("Expected SignedIntent instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SignedIntent._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransactionBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionbuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilder, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def header(self, header: "TransactionHeader") -> "TransactionBuilderHeaderStep":
        
        return _UniffiConverterTypeTransactionBuilderHeaderStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilder_header,self._pointer,
        _UniffiConverterTypeTransactionHeader.lower(header))
        )






class _UniffiConverterTypeTransactionBuilder:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilder):
            raise TypeError("Expected TransactionBuilder instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilder._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransactionBuilderHeaderStep:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderheaderstep, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def manifest(self, manifest: "TransactionManifest") -> "TransactionBuilderMessageStep":
        
        return _UniffiConverterTypeTransactionBuilderMessageStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderheaderstep_manifest,self._pointer,
        _UniffiConverterTypeTransactionManifest.lower(manifest))
        )






class _UniffiConverterTypeTransactionBuilderHeaderStep:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilderHeaderStep):
            raise TypeError("Expected TransactionBuilderHeaderStep instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilderHeaderStep._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransactionBuilderIntentSignaturesStep:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuilderintentsignaturesstep, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def notarize_with_private_key(self, private_key: "PrivateKey") -> "NotarizedTransaction":
        
        return _UniffiConverterTypeNotarizedTransaction.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_private_key,self._pointer,
        _UniffiConverterTypePrivateKey.lower(private_key))
        )






    def notarize_with_signer(self, signer: "Signer") -> "NotarizedTransaction":
        
        return _UniffiConverterTypeNotarizedTransaction.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_notarize_with_signer,self._pointer,
        _UniffiConverterCallbackInterfaceSigner.lower(signer))
        )






    def sign_with_private_key(self, private_key: "PrivateKey") -> "TransactionBuilderIntentSignaturesStep":
        
        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_private_key,self._pointer,
        _UniffiConverterTypePrivateKey.lower(private_key))
        )






    def sign_with_signer(self, signer: "Signer") -> "TransactionBuilderIntentSignaturesStep":
        
        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuilderintentsignaturesstep_sign_with_signer,self._pointer,
        _UniffiConverterCallbackInterfaceSigner.lower(signer))
        )






class _UniffiConverterTypeTransactionBuilderIntentSignaturesStep:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilderIntentSignaturesStep):
            raise TypeError("Expected TransactionBuilderIntentSignaturesStep instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilderIntentSignaturesStep._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransactionBuilderMessageStep:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionbuildermessagestep, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def message(self, message: "Message") -> "TransactionBuilderIntentSignaturesStep":
        
        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_message,self._pointer,
        _UniffiConverterTypeMessage.lower(message))
        )






    def sign_with_private_key(self, private_key: "PrivateKey") -> "TransactionBuilderIntentSignaturesStep":
        
        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_private_key,self._pointer,
        _UniffiConverterTypePrivateKey.lower(private_key))
        )






    def sign_with_signer(self, signer: "Signer") -> "TransactionBuilderIntentSignaturesStep":
        
        return _UniffiConverterTypeTransactionBuilderIntentSignaturesStep.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionbuildermessagestep_sign_with_signer,self._pointer,
        _UniffiConverterCallbackInterfaceSigner.lower(signer))
        )






class _UniffiConverterTypeTransactionBuilderMessageStep:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionBuilderMessageStep):
            raise TypeError("Expected TransactionBuilderMessageStep instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionBuilderMessageStep._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransactionHash:
    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionhash, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_str(cls, string: "str",network_id: "int"):
        
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionhash_from_str,
        _UniffiConverterString.lower(string),
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)



    def as_hash(self, ) -> "Hash":
        return _UniffiConverterTypeHash.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_hash,self._pointer,)
        )






    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_as_str,self._pointer,)
        )






    def bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_bytes,self._pointer,)
        )






    def network_id(self, ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionhash_network_id,self._pointer,)
        )






class _UniffiConverterTypeTransactionHash:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionHash):
            raise TypeError("Expected TransactionHash instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionHash._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransactionManifest:
    _pointer: ctypes.c_void_p
    def __init__(self, instructions: "Instructions",blobs: "typing.List[typing.List[int]]"):
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_transactionmanifest_new,
        _UniffiConverterTypeInstructions.lower(instructions),
        _UniffiConverterSequenceSequenceUInt8.lower(blobs))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_transactionmanifest, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def accounts_deposited_into(self, ) -> "typing.List[Address]":
        return _UniffiConverterSequenceTypeAddress.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_deposited_into,self._pointer,)
        )






    def accounts_requiring_auth(self, ) -> "typing.List[Address]":
        return _UniffiConverterSequenceTypeAddress.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_requiring_auth,self._pointer,)
        )






    def accounts_withdrawn_from(self, ) -> "typing.List[Address]":
        return _UniffiConverterSequenceTypeAddress.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_accounts_withdrawn_from,self._pointer,)
        )






    def analyze_execution(self, transaction_receipt: "typing.List[int]") -> "ExecutionAnalysis":
        
        return _UniffiConverterTypeExecutionAnalysis.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_analyze_execution,self._pointer,
        _UniffiConverterSequenceUInt8.lower(transaction_receipt))
        )






    def blobs(self, ) -> "typing.List[typing.List[int]]":
        return _UniffiConverterSequenceSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_blobs,self._pointer,)
        )






    def extract_addresses(self, ) -> "dict":
        return _UniffiConverterMapTypeEntityTypeSequenceTypeAddress.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_extract_addresses,self._pointer,)
        )






    def identities_requiring_auth(self, ) -> "typing.List[Address]":
        return _UniffiConverterSequenceTypeAddress.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_identities_requiring_auth,self._pointer,)
        )






    def instructions(self, ) -> "Instructions":
        return _UniffiConverterTypeInstructions.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_instructions,self._pointer,)
        )






    def modify(self, modifications: "TransactionManifestModifications") -> "TransactionManifest":
        
        return _UniffiConverterTypeTransactionManifest.lift(
            _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_modify,self._pointer,
        _UniffiConverterTypeTransactionManifestModifications.lower(modifications))
        )






    def statically_validate(self, ):
        _rust_call_with_error(
    _UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_transactionmanifest_statically_validate,self._pointer,)







class _UniffiConverterTypeTransactionManifest:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransactionManifest):
            raise TypeError("Expected TransactionManifest instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransactionManifest._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class ValidationConfig:
    _pointer: ctypes.c_void_p
    def __init__(self, network_id: "int",max_notarized_payload_size: "int",min_cost_unit_limit: "int",max_cost_unit_limit: "int",min_tip_percentage: "int",max_tip_percentage: "int",max_epoch_range: "int",message_validation: "MessageValidationConfig"):
        
        
        
        
        
        
        
        
        self._pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_new,
        _UniffiConverterUInt8.lower(network_id),
        _UniffiConverterUInt64.lower(max_notarized_payload_size),
        _UniffiConverterUInt32.lower(min_cost_unit_limit),
        _UniffiConverterUInt32.lower(max_cost_unit_limit),
        _UniffiConverterUInt16.lower(min_tip_percentage),
        _UniffiConverterUInt16.lower(max_tip_percentage),
        _UniffiConverterUInt64.lower(max_epoch_range),
        _UniffiConverterTypeMessageValidationConfig.lower(message_validation))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_free_validationconfig, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def default(cls, network_id: "int"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_constructor_validationconfig_default,
        _UniffiConverterUInt8.lower(network_id))
        return cls._make_instance_(pointer)



    def max_cost_unit_limit(self, ) -> "int":
        return _UniffiConverterUInt32.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_cost_unit_limit,self._pointer,)
        )






    def max_epoch_range(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_epoch_range,self._pointer,)
        )






    def max_notarized_payload_size(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_notarized_payload_size,self._pointer,)
        )






    def max_tip_percentage(self, ) -> "int":
        return _UniffiConverterUInt16.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_max_tip_percentage,self._pointer,)
        )






    def message_validation(self, ) -> "MessageValidationConfig":
        return _UniffiConverterTypeMessageValidationConfig.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_message_validation,self._pointer,)
        )






    def min_cost_unit_limit(self, ) -> "int":
        return _UniffiConverterUInt32.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_cost_unit_limit,self._pointer,)
        )






    def min_tip_percentage(self, ) -> "int":
        return _UniffiConverterUInt16.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_min_tip_percentage,self._pointer,)
        )






    def network_id(self, ) -> "int":
        return _UniffiConverterUInt8.lift(
            _rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_method_validationconfig_network_id,self._pointer,)
        )






class _UniffiConverterTypeValidationConfig:
    @classmethod
    def read(cls, buf):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, ValidationConfig):
            raise TypeError("Expected ValidationConfig instance, {} found".format(type(value).__name__))
        buf.write_u64(cls.lower(value))

    @staticmethod
    def lift(value):
        return ValidationConfig._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AuthorizedDepositorsChanges:
    added: "typing.List[ResourceOrNonFungible]";removed: "typing.List[ResourceOrNonFungible]";

    @typing.no_type_check
    def __init__(self, added: "typing.List[ResourceOrNonFungible]", removed: "typing.List[ResourceOrNonFungible]"):
        self.added = added
        self.removed = removed

    def __str__(self):
        return "AuthorizedDepositorsChanges(added={}, removed={})".format(self.added, self.removed)

    def __eq__(self, other):
        if self.added != other.added:
            return False
        if self.removed != other.removed:
            return False
        return True

class _UniffiConverterTypeAuthorizedDepositorsChanges(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AuthorizedDepositorsChanges(
            added=_UniffiConverterSequenceTypeResourceOrNonFungible.read(buf),
            removed=_UniffiConverterSequenceTypeResourceOrNonFungible.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeResourceOrNonFungible.write(value.added, buf)
        _UniffiConverterSequenceTypeResourceOrNonFungible.write(value.removed, buf)


class BadgeWithdrawEvent:
    proposer: "Proposer";

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "BadgeWithdrawEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True

class _UniffiConverterTypeBadgeWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BadgeWithdrawEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class BuildInformation:
    version: "str";scrypto_dependency: "DependencyInformation";

    @typing.no_type_check
    def __init__(self, version: "str", scrypto_dependency: "DependencyInformation"):
        self.version = version
        self.scrypto_dependency = scrypto_dependency

    def __str__(self):
        return "BuildInformation(version={}, scrypto_dependency={})".format(self.version, self.scrypto_dependency)

    def __eq__(self, other):
        if self.version != other.version:
            return False
        if self.scrypto_dependency != other.scrypto_dependency:
            return False
        return True

class _UniffiConverterTypeBuildInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuildInformation(
            version=_UniffiConverterString.read(buf),
            scrypto_dependency=_UniffiConverterTypeDependencyInformation.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.version, buf)
        _UniffiConverterTypeDependencyInformation.write(value.scrypto_dependency, buf)


class BurnFungibleResourceEvent:
    amount: "Decimal";

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "BurnFungibleResourceEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeBurnFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BurnFungibleResourceEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class BurnNonFungibleResourceEvent:
    ids: "typing.List[NonFungibleLocalId]";

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "BurnNonFungibleResourceEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True

class _UniffiConverterTypeBurnNonFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BurnNonFungibleResourceEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class CancelBadgeWithdrawAttemptEvent:
    proposer: "Proposer";

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "CancelBadgeWithdrawAttemptEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True

class _UniffiConverterTypeCancelBadgeWithdrawAttemptEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CancelBadgeWithdrawAttemptEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class CancelRecoveryProposalEvent:
    proposer: "Proposer";

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "CancelRecoveryProposalEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True

class _UniffiConverterTypeCancelRecoveryProposalEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CancelRecoveryProposalEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class ClaimXrdEvent:
    claimed_xrd: "Decimal";

    @typing.no_type_check
    def __init__(self, claimed_xrd: "Decimal"):
        self.claimed_xrd = claimed_xrd

    def __str__(self):
        return "ClaimXrdEvent(claimed_xrd={})".format(self.claimed_xrd)

    def __eq__(self, other):
        if self.claimed_xrd != other.claimed_xrd:
            return False
        return True

class _UniffiConverterTypeClaimXrdEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClaimXrdEvent(
            claimed_xrd=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.claimed_xrd, buf)


class ComponentAddresses:
    consensus_manager: "Address";genesis_helper: "Address";faucet: "Address";

    @typing.no_type_check
    def __init__(self, consensus_manager: "Address", genesis_helper: "Address", faucet: "Address"):
        self.consensus_manager = consensus_manager
        self.genesis_helper = genesis_helper
        self.faucet = faucet

    def __str__(self):
        return "ComponentAddresses(consensus_manager={}, genesis_helper={}, faucet={})".format(self.consensus_manager, self.genesis_helper, self.faucet)

    def __eq__(self, other):
        if self.consensus_manager != other.consensus_manager:
            return False
        if self.genesis_helper != other.genesis_helper:
            return False
        if self.faucet != other.faucet:
            return False
        return True

class _UniffiConverterTypeComponentAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ComponentAddresses(
            consensus_manager=_UniffiConverterTypeAddress.read(buf),
            genesis_helper=_UniffiConverterTypeAddress.read(buf),
            faucet=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.consensus_manager, buf)
        _UniffiConverterTypeAddress.write(value.genesis_helper, buf)
        _UniffiConverterTypeAddress.write(value.faucet, buf)


class Ed25519PublicKey:
    value: "typing.List[int]";

    @typing.no_type_check
    def __init__(self, value: "typing.List[int]"):
        self.value = value

    def __str__(self):
        return "Ed25519PublicKey(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeEd25519PublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Ed25519PublicKey(
            value=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.value, buf)


class EncryptedMessage:
    encrypted: "typing.List[int]";decryptors_by_curve: "dict";

    @typing.no_type_check
    def __init__(self, encrypted: "typing.List[int]", decryptors_by_curve: "dict"):
        self.encrypted = encrypted
        self.decryptors_by_curve = decryptors_by_curve

    def __str__(self):
        return "EncryptedMessage(encrypted={}, decryptors_by_curve={})".format(self.encrypted, self.decryptors_by_curve)

    def __eq__(self, other):
        if self.encrypted != other.encrypted:
            return False
        if self.decryptors_by_curve != other.decryptors_by_curve:
            return False
        return True

class _UniffiConverterTypeEncryptedMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EncryptedMessage(
            encrypted=_UniffiConverterSequenceUInt8.read(buf),
            decryptors_by_curve=_UniffiConverterMapTypeCurveTypeTypeDecryptorsByCurve.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.encrypted, buf)
        _UniffiConverterMapTypeCurveTypeTypeDecryptorsByCurve.write(value.decryptors_by_curve, buf)


class EpochChangeEvent:
    epoch: "int";validator_set: "dict";

    @typing.no_type_check
    def __init__(self, epoch: "int", validator_set: "dict"):
        self.epoch = epoch
        self.validator_set = validator_set

    def __str__(self):
        return "EpochChangeEvent(epoch={}, validator_set={})".format(self.epoch, self.validator_set)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.validator_set != other.validator_set:
            return False
        return True

class _UniffiConverterTypeEpochChangeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EpochChangeEvent(
            epoch=_UniffiConverterUInt64.read(buf),
            validator_set=_UniffiConverterMapStringTypeValidatorInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterMapStringTypeValidatorInfo.write(value.validator_set, buf)


class EventTypeIdentifier:
    emitter: "Emitter";schema_hash: "Hash";local_type_index: "LocalTypeIndex";

    @typing.no_type_check
    def __init__(self, emitter: "Emitter", schema_hash: "Hash", local_type_index: "LocalTypeIndex"):
        self.emitter = emitter
        self.schema_hash = schema_hash
        self.local_type_index = local_type_index

    def __str__(self):
        return "EventTypeIdentifier(emitter={}, schema_hash={}, local_type_index={})".format(self.emitter, self.schema_hash, self.local_type_index)

    def __eq__(self, other):
        if self.emitter != other.emitter:
            return False
        if self.schema_hash != other.schema_hash:
            return False
        if self.local_type_index != other.local_type_index:
            return False
        return True

class _UniffiConverterTypeEventTypeIdentifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EventTypeIdentifier(
            emitter=_UniffiConverterTypeEmitter.read(buf),
            schema_hash=_UniffiConverterTypeHash.read(buf),
            local_type_index=_UniffiConverterTypeLocalTypeIndex.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeEmitter.write(value.emitter, buf)
        _UniffiConverterTypeHash.write(value.schema_hash, buf)
        _UniffiConverterTypeLocalTypeIndex.write(value.local_type_index, buf)


class ExecutionAnalysis:
    fee_locks: "FeeLocks";fee_summary: "FeeSummary";transaction_types: "typing.List[TransactionType]";reserved_instructions: "typing.List[ReservedInstruction]";

    @typing.no_type_check
    def __init__(self, fee_locks: "FeeLocks", fee_summary: "FeeSummary", transaction_types: "typing.List[TransactionType]", reserved_instructions: "typing.List[ReservedInstruction]"):
        self.fee_locks = fee_locks
        self.fee_summary = fee_summary
        self.transaction_types = transaction_types
        self.reserved_instructions = reserved_instructions

    def __str__(self):
        return "ExecutionAnalysis(fee_locks={}, fee_summary={}, transaction_types={}, reserved_instructions={})".format(self.fee_locks, self.fee_summary, self.transaction_types, self.reserved_instructions)

    def __eq__(self, other):
        if self.fee_locks != other.fee_locks:
            return False
        if self.fee_summary != other.fee_summary:
            return False
        if self.transaction_types != other.transaction_types:
            return False
        if self.reserved_instructions != other.reserved_instructions:
            return False
        return True

class _UniffiConverterTypeExecutionAnalysis(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ExecutionAnalysis(
            fee_locks=_UniffiConverterTypeFeeLocks.read(buf),
            fee_summary=_UniffiConverterTypeFeeSummary.read(buf),
            transaction_types=_UniffiConverterSequenceTypeTransactionType.read(buf),
            reserved_instructions=_UniffiConverterSequenceTypeReservedInstruction.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFeeLocks.write(value.fee_locks, buf)
        _UniffiConverterTypeFeeSummary.write(value.fee_summary, buf)
        _UniffiConverterSequenceTypeTransactionType.write(value.transaction_types, buf)
        _UniffiConverterSequenceTypeReservedInstruction.write(value.reserved_instructions, buf)


class FeeLocks:
    lock: "Decimal";contingent_lock: "Decimal";

    @typing.no_type_check
    def __init__(self, lock: "Decimal", contingent_lock: "Decimal"):
        self.lock = lock
        self.contingent_lock = contingent_lock

    def __str__(self):
        return "FeeLocks(lock={}, contingent_lock={})".format(self.lock, self.contingent_lock)

    def __eq__(self, other):
        if self.lock != other.lock:
            return False
        if self.contingent_lock != other.contingent_lock:
            return False
        return True

class _UniffiConverterTypeFeeLocks(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeLocks(
            lock=_UniffiConverterTypeDecimal.read(buf),
            contingent_lock=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.lock, buf)
        _UniffiConverterTypeDecimal.write(value.contingent_lock, buf)


class FeeSummary:
    execution_cost: "Decimal";finalization_cost: "Decimal";storage_expansion_cost: "Decimal";royalty_cost: "Decimal";

    @typing.no_type_check
    def __init__(self, execution_cost: "Decimal", finalization_cost: "Decimal", storage_expansion_cost: "Decimal", royalty_cost: "Decimal"):
        self.execution_cost = execution_cost
        self.finalization_cost = finalization_cost
        self.storage_expansion_cost = storage_expansion_cost
        self.royalty_cost = royalty_cost

    def __str__(self):
        return "FeeSummary(execution_cost={}, finalization_cost={}, storage_expansion_cost={}, royalty_cost={})".format(self.execution_cost, self.finalization_cost, self.storage_expansion_cost, self.royalty_cost)

    def __eq__(self, other):
        if self.execution_cost != other.execution_cost:
            return False
        if self.finalization_cost != other.finalization_cost:
            return False
        if self.storage_expansion_cost != other.storage_expansion_cost:
            return False
        if self.royalty_cost != other.royalty_cost:
            return False
        return True

class _UniffiConverterTypeFeeSummary(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeSummary(
            execution_cost=_UniffiConverterTypeDecimal.read(buf),
            finalization_cost=_UniffiConverterTypeDecimal.read(buf),
            storage_expansion_cost=_UniffiConverterTypeDecimal.read(buf),
            royalty_cost=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.execution_cost, buf)
        _UniffiConverterTypeDecimal.write(value.finalization_cost, buf)
        _UniffiConverterTypeDecimal.write(value.storage_expansion_cost, buf)
        _UniffiConverterTypeDecimal.write(value.royalty_cost, buf)


class FungibleResourceRoles:
    mint_roles: "typing.Optional[ResourceManagerRole]";burn_roles: "typing.Optional[ResourceManagerRole]";freeze_roles: "typing.Optional[ResourceManagerRole]";recall_roles: "typing.Optional[ResourceManagerRole]";withdraw_roles: "typing.Optional[ResourceManagerRole]";deposit_roles: "typing.Optional[ResourceManagerRole]";

    @typing.no_type_check
    def __init__(self, mint_roles: "typing.Optional[ResourceManagerRole]", burn_roles: "typing.Optional[ResourceManagerRole]", freeze_roles: "typing.Optional[ResourceManagerRole]", recall_roles: "typing.Optional[ResourceManagerRole]", withdraw_roles: "typing.Optional[ResourceManagerRole]", deposit_roles: "typing.Optional[ResourceManagerRole]"):
        self.mint_roles = mint_roles
        self.burn_roles = burn_roles
        self.freeze_roles = freeze_roles
        self.recall_roles = recall_roles
        self.withdraw_roles = withdraw_roles
        self.deposit_roles = deposit_roles

    def __str__(self):
        return "FungibleResourceRoles(mint_roles={}, burn_roles={}, freeze_roles={}, recall_roles={}, withdraw_roles={}, deposit_roles={})".format(self.mint_roles, self.burn_roles, self.freeze_roles, self.recall_roles, self.withdraw_roles, self.deposit_roles)

    def __eq__(self, other):
        if self.mint_roles != other.mint_roles:
            return False
        if self.burn_roles != other.burn_roles:
            return False
        if self.freeze_roles != other.freeze_roles:
            return False
        if self.recall_roles != other.recall_roles:
            return False
        if self.withdraw_roles != other.withdraw_roles:
            return False
        if self.deposit_roles != other.deposit_roles:
            return False
        return True

class _UniffiConverterTypeFungibleResourceRoles(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FungibleResourceRoles(
            mint_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            burn_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            freeze_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            recall_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            withdraw_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
            deposit_roles=_UniffiConverterOptionalTypeResourceManagerRole.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.mint_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.burn_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.freeze_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.recall_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.withdraw_roles, buf)
        _UniffiConverterOptionalTypeResourceManagerRole.write(value.deposit_roles, buf)


class IndexedAssertion:
    index: "int";assertion: "Assertion";

    @typing.no_type_check
    def __init__(self, index: "int", assertion: "Assertion"):
        self.index = index
        self.assertion = assertion

    def __str__(self):
        return "IndexedAssertion(index={}, assertion={})".format(self.index, self.assertion)

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.assertion != other.assertion:
            return False
        return True

class _UniffiConverterTypeIndexedAssertion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IndexedAssertion(
            index=_UniffiConverterUInt64.read(buf),
            assertion=_UniffiConverterTypeAssertion.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.index, buf)
        _UniffiConverterTypeAssertion.write(value.assertion, buf)


class InitiateBadgeWithdrawAttemptEvent:
    proposer: "Proposer";

    @typing.no_type_check
    def __init__(self, proposer: "Proposer"):
        self.proposer = proposer

    def __str__(self):
        return "InitiateBadgeWithdrawAttemptEvent(proposer={})".format(self.proposer)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        return True

class _UniffiConverterTypeInitiateBadgeWithdrawAttemptEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InitiateBadgeWithdrawAttemptEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)


class InitiateRecoveryEvent:
    proposer: "Proposer";proposal: "RecoveryProposal";

    @typing.no_type_check
    def __init__(self, proposer: "Proposer", proposal: "RecoveryProposal"):
        self.proposer = proposer
        self.proposal = proposal

    def __str__(self):
        return "InitiateRecoveryEvent(proposer={}, proposal={})".format(self.proposer, self.proposal)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        if self.proposal != other.proposal:
            return False
        return True

class _UniffiConverterTypeInitiateRecoveryEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InitiateRecoveryEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
            proposal=_UniffiConverterTypeRecoveryProposal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)
        _UniffiConverterTypeRecoveryProposal.write(value.proposal, buf)


class KnownAddresses:
    resource_addresses: "ResourceAddresses";package_addresses: "PackageAddresses";component_addresses: "ComponentAddresses";

    @typing.no_type_check
    def __init__(self, resource_addresses: "ResourceAddresses", package_addresses: "PackageAddresses", component_addresses: "ComponentAddresses"):
        self.resource_addresses = resource_addresses
        self.package_addresses = package_addresses
        self.component_addresses = component_addresses

    def __str__(self):
        return "KnownAddresses(resource_addresses={}, package_addresses={}, component_addresses={})".format(self.resource_addresses, self.package_addresses, self.component_addresses)

    def __eq__(self, other):
        if self.resource_addresses != other.resource_addresses:
            return False
        if self.package_addresses != other.package_addresses:
            return False
        if self.component_addresses != other.component_addresses:
            return False
        return True

class _UniffiConverterTypeKnownAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KnownAddresses(
            resource_addresses=_UniffiConverterTypeResourceAddresses.read(buf),
            package_addresses=_UniffiConverterTypePackageAddresses.read(buf),
            component_addresses=_UniffiConverterTypeComponentAddresses.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeResourceAddresses.write(value.resource_addresses, buf)
        _UniffiConverterTypePackageAddresses.write(value.package_addresses, buf)
        _UniffiConverterTypeComponentAddresses.write(value.component_addresses, buf)


class LockFeeEvent:
    amount: "Decimal";

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "LockFeeEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeLockFeeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockFeeEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class LockFeeModification:
    account_address: "Address";amount: "Decimal";

    @typing.no_type_check
    def __init__(self, account_address: "Address", amount: "Decimal"):
        self.account_address = account_address
        self.amount = amount

    def __str__(self):
        return "LockFeeModification(account_address={}, amount={})".format(self.account_address, self.amount)

    def __eq__(self, other):
        if self.account_address != other.account_address:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeLockFeeModification(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockFeeModification(
            account_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.account_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class LockOwnerRoleEvent:
    placeholder_field: "bool";

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "LockOwnerRoleEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True

class _UniffiConverterTypeLockOwnerRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockOwnerRoleEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class LockPrimaryRoleEvent:
    placeholder_field: "bool";

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "LockPrimaryRoleEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True

class _UniffiConverterTypeLockPrimaryRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockPrimaryRoleEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class LockRoleEvent:
    role_key: "str";

    @typing.no_type_check
    def __init__(self, role_key: "str"):
        self.role_key = role_key

    def __str__(self):
        return "LockRoleEvent(role_key={})".format(self.role_key)

    def __eq__(self, other):
        if self.role_key != other.role_key:
            return False
        return True

class _UniffiConverterTypeLockRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LockRoleEvent(
            role_key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.role_key, buf)


class ManifestAddressReservation:
    value: "int";

    @typing.no_type_check
    def __init__(self, value: "int"):
        self.value = value

    def __str__(self):
        return "ManifestAddressReservation(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeManifestAddressReservation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestAddressReservation(
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)


class ManifestBlobRef:
    value: "Hash";

    @typing.no_type_check
    def __init__(self, value: "Hash"):
        self.value = value

    def __str__(self):
        return "ManifestBlobRef(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeManifestBlobRef(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBlobRef(
            value=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.value, buf)


class ManifestBucket:
    value: "int";

    @typing.no_type_check
    def __init__(self, value: "int"):
        self.value = value

    def __str__(self):
        return "ManifestBucket(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeManifestBucket(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBucket(
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)


class ManifestBuilderAddressReservation:
    name: "str";

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderAddressReservation(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeManifestBuilderAddressReservation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderAddressReservation(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestBuilderBucket:
    name: "str";

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderBucket(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeManifestBuilderBucket(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderBucket(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestBuilderMapEntry:
    key: "ManifestBuilderValue";value: "ManifestBuilderValue";

    @typing.no_type_check
    def __init__(self, key: "ManifestBuilderValue", value: "ManifestBuilderValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "ManifestBuilderMapEntry(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeManifestBuilderMapEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderMapEntry(
            key=_UniffiConverterTypeManifestBuilderValue.read(buf),
            value=_UniffiConverterTypeManifestBuilderValue.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeManifestBuilderValue.write(value.key, buf)
        _UniffiConverterTypeManifestBuilderValue.write(value.value, buf)


class ManifestBuilderNamedAddress:
    name: "str";

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderNamedAddress(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeManifestBuilderNamedAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderNamedAddress(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestBuilderProof:
    name: "str";

    @typing.no_type_check
    def __init__(self, name: "str"):
        self.name = name

    def __str__(self):
        return "ManifestBuilderProof(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeManifestBuilderProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestBuilderProof(
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)


class ManifestProof:
    value: "int";

    @typing.no_type_check
    def __init__(self, value: "int"):
        self.value = value

    def __str__(self):
        return "ManifestProof(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeManifestProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ManifestProof(
            value=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)


class MapEntry:
    key: "ManifestValue";value: "ManifestValue";

    @typing.no_type_check
    def __init__(self, key: "ManifestValue", value: "ManifestValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "MapEntry(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeMapEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MapEntry(
            key=_UniffiConverterTypeManifestValue.read(buf),
            value=_UniffiConverterTypeManifestValue.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeManifestValue.write(value.key, buf)
        _UniffiConverterTypeManifestValue.write(value.value, buf)


class MetadataInitEntry:
    value: "typing.Optional[MetadataValue]";lock: "bool";

    @typing.no_type_check
    def __init__(self, value: "typing.Optional[MetadataValue]", lock: "bool"):
        self.value = value
        self.lock = lock

    def __str__(self):
        return "MetadataInitEntry(value={}, lock={})".format(self.value, self.lock)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.lock != other.lock:
            return False
        return True

class _UniffiConverterTypeMetadataInitEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataInitEntry(
            value=_UniffiConverterOptionalTypeMetadataValue.read(buf),
            lock=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeMetadataValue.write(value.value, buf)
        _UniffiConverterBool.write(value.lock, buf)


class MetadataModuleConfig:
    init: "dict";roles: "dict";

    @typing.no_type_check
    def __init__(self, init: "dict", roles: "dict"):
        self.init = init
        self.roles = roles

    def __str__(self):
        return "MetadataModuleConfig(init={}, roles={})".format(self.init, self.roles)

    def __eq__(self, other):
        if self.init != other.init:
            return False
        if self.roles != other.roles:
            return False
        return True

class _UniffiConverterTypeMetadataModuleConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MetadataModuleConfig(
            init=_UniffiConverterMapStringTypeMetadataInitEntry.read(buf),
            roles=_UniffiConverterMapStringOptionalTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringTypeMetadataInitEntry.write(value.init, buf)
        _UniffiConverterMapStringOptionalTypeAccessRule.write(value.roles, buf)


class MintFungibleResourceEvent:
    amount: "Decimal";

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "MintFungibleResourceEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeMintFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MintFungibleResourceEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class MintNonFungibleResourceEvent:
    ids: "typing.List[NonFungibleLocalId]";

    @typing.no_type_check
    def __init__(self, ids: "typing.List[NonFungibleLocalId]"):
        self.ids = ids

    def __str__(self):
        return "MintNonFungibleResourceEvent(ids={})".format(self.ids)

    def __eq__(self, other):
        if self.ids != other.ids:
            return False
        return True

class _UniffiConverterTypeMintNonFungibleResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MintNonFungibleResourceEvent(
            ids=_UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)


class MultiResourcePoolContributionEvent:
    contributed_resources: "dict";pool_units_minted: "Decimal";

    @typing.no_type_check
    def __init__(self, contributed_resources: "dict", pool_units_minted: "Decimal"):
        self.contributed_resources = contributed_resources
        self.pool_units_minted = pool_units_minted

    def __str__(self):
        return "MultiResourcePoolContributionEvent(contributed_resources={}, pool_units_minted={})".format(self.contributed_resources, self.pool_units_minted)

    def __eq__(self, other):
        if self.contributed_resources != other.contributed_resources:
            return False
        if self.pool_units_minted != other.pool_units_minted:
            return False
        return True

class _UniffiConverterTypeMultiResourcePoolContributionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolContributionEvent(
            contributed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
            pool_units_minted=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringTypeDecimal.write(value.contributed_resources, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_minted, buf)


class MultiResourcePoolDepositEvent:
    resource_address: "Address";amount: "Decimal";

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "MultiResourcePoolDepositEvent(resource_address={}, amount={})".format(self.resource_address, self.amount)

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeMultiResourcePoolDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolDepositEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class MultiResourcePoolRedemptionEvent:
    pool_unit_tokens_redeemed: "Decimal";redeemed_resources: "dict";

    @typing.no_type_check
    def __init__(self, pool_unit_tokens_redeemed: "Decimal", redeemed_resources: "dict"):
        self.pool_unit_tokens_redeemed = pool_unit_tokens_redeemed
        self.redeemed_resources = redeemed_resources

    def __str__(self):
        return "MultiResourcePoolRedemptionEvent(pool_unit_tokens_redeemed={}, redeemed_resources={})".format(self.pool_unit_tokens_redeemed, self.redeemed_resources)

    def __eq__(self, other):
        if self.pool_unit_tokens_redeemed != other.pool_unit_tokens_redeemed:
            return False
        if self.redeemed_resources != other.redeemed_resources:
            return False
        return True

class _UniffiConverterTypeMultiResourcePoolRedemptionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolRedemptionEvent(
            pool_unit_tokens_redeemed=_UniffiConverterTypeDecimal.read(buf),
            redeemed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.pool_unit_tokens_redeemed, buf)
        _UniffiConverterMapStringTypeDecimal.write(value.redeemed_resources, buf)


class MultiResourcePoolWithdrawEvent:
    resource_address: "Address";amount: "Decimal";

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "MultiResourcePoolWithdrawEvent(resource_address={}, amount={})".format(self.resource_address, self.amount)

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeMultiResourcePoolWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultiResourcePoolWithdrawEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class OneResourcePoolContributionEvent:
    amount_of_resources_contributed: "Decimal";pool_units_minted: "Decimal";

    @typing.no_type_check
    def __init__(self, amount_of_resources_contributed: "Decimal", pool_units_minted: "Decimal"):
        self.amount_of_resources_contributed = amount_of_resources_contributed
        self.pool_units_minted = pool_units_minted

    def __str__(self):
        return "OneResourcePoolContributionEvent(amount_of_resources_contributed={}, pool_units_minted={})".format(self.amount_of_resources_contributed, self.pool_units_minted)

    def __eq__(self, other):
        if self.amount_of_resources_contributed != other.amount_of_resources_contributed:
            return False
        if self.pool_units_minted != other.pool_units_minted:
            return False
        return True

class _UniffiConverterTypeOneResourcePoolContributionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolContributionEvent(
            amount_of_resources_contributed=_UniffiConverterTypeDecimal.read(buf),
            pool_units_minted=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount_of_resources_contributed, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_minted, buf)


class OneResourcePoolDepositEvent:
    amount: "Decimal";

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "OneResourcePoolDepositEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeOneResourcePoolDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolDepositEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class OneResourcePoolRedemptionEvent:
    pool_unit_tokens_redeemed: "Decimal";redeemed_amount: "Decimal";

    @typing.no_type_check
    def __init__(self, pool_unit_tokens_redeemed: "Decimal", redeemed_amount: "Decimal"):
        self.pool_unit_tokens_redeemed = pool_unit_tokens_redeemed
        self.redeemed_amount = redeemed_amount

    def __str__(self):
        return "OneResourcePoolRedemptionEvent(pool_unit_tokens_redeemed={}, redeemed_amount={})".format(self.pool_unit_tokens_redeemed, self.redeemed_amount)

    def __eq__(self, other):
        if self.pool_unit_tokens_redeemed != other.pool_unit_tokens_redeemed:
            return False
        if self.redeemed_amount != other.redeemed_amount:
            return False
        return True

class _UniffiConverterTypeOneResourcePoolRedemptionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolRedemptionEvent(
            pool_unit_tokens_redeemed=_UniffiConverterTypeDecimal.read(buf),
            redeemed_amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.pool_unit_tokens_redeemed, buf)
        _UniffiConverterTypeDecimal.write(value.redeemed_amount, buf)


class OneResourcePoolWithdrawEvent:
    amount: "Decimal";

    @typing.no_type_check
    def __init__(self, amount: "Decimal"):
        self.amount = amount

    def __str__(self):
        return "OneResourcePoolWithdrawEvent(amount={})".format(self.amount)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeOneResourcePoolWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OneResourcePoolWithdrawEvent(
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class PackageAddresses:
    package_package: "Address";resource_package: "Address";account_package: "Address";identity_package: "Address";consensus_manager_package: "Address";access_controller_package: "Address";pool_package: "Address";transaction_processor_package: "Address";metadata_module_package: "Address";royalty_module_package: "Address";role_assignment_module_package: "Address";genesis_helper_package: "Address";faucet_package: "Address";

    @typing.no_type_check
    def __init__(self, package_package: "Address", resource_package: "Address", account_package: "Address", identity_package: "Address", consensus_manager_package: "Address", access_controller_package: "Address", pool_package: "Address", transaction_processor_package: "Address", metadata_module_package: "Address", royalty_module_package: "Address", role_assignment_module_package: "Address", genesis_helper_package: "Address", faucet_package: "Address"):
        self.package_package = package_package
        self.resource_package = resource_package
        self.account_package = account_package
        self.identity_package = identity_package
        self.consensus_manager_package = consensus_manager_package
        self.access_controller_package = access_controller_package
        self.pool_package = pool_package
        self.transaction_processor_package = transaction_processor_package
        self.metadata_module_package = metadata_module_package
        self.royalty_module_package = royalty_module_package
        self.role_assignment_module_package = role_assignment_module_package
        self.genesis_helper_package = genesis_helper_package
        self.faucet_package = faucet_package

    def __str__(self):
        return "PackageAddresses(package_package={}, resource_package={}, account_package={}, identity_package={}, consensus_manager_package={}, access_controller_package={}, pool_package={}, transaction_processor_package={}, metadata_module_package={}, royalty_module_package={}, role_assignment_module_package={}, genesis_helper_package={}, faucet_package={})".format(self.package_package, self.resource_package, self.account_package, self.identity_package, self.consensus_manager_package, self.access_controller_package, self.pool_package, self.transaction_processor_package, self.metadata_module_package, self.royalty_module_package, self.role_assignment_module_package, self.genesis_helper_package, self.faucet_package)

    def __eq__(self, other):
        if self.package_package != other.package_package:
            return False
        if self.resource_package != other.resource_package:
            return False
        if self.account_package != other.account_package:
            return False
        if self.identity_package != other.identity_package:
            return False
        if self.consensus_manager_package != other.consensus_manager_package:
            return False
        if self.access_controller_package != other.access_controller_package:
            return False
        if self.pool_package != other.pool_package:
            return False
        if self.transaction_processor_package != other.transaction_processor_package:
            return False
        if self.metadata_module_package != other.metadata_module_package:
            return False
        if self.royalty_module_package != other.royalty_module_package:
            return False
        if self.role_assignment_module_package != other.role_assignment_module_package:
            return False
        if self.genesis_helper_package != other.genesis_helper_package:
            return False
        if self.faucet_package != other.faucet_package:
            return False
        return True

class _UniffiConverterTypePackageAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PackageAddresses(
            package_package=_UniffiConverterTypeAddress.read(buf),
            resource_package=_UniffiConverterTypeAddress.read(buf),
            account_package=_UniffiConverterTypeAddress.read(buf),
            identity_package=_UniffiConverterTypeAddress.read(buf),
            consensus_manager_package=_UniffiConverterTypeAddress.read(buf),
            access_controller_package=_UniffiConverterTypeAddress.read(buf),
            pool_package=_UniffiConverterTypeAddress.read(buf),
            transaction_processor_package=_UniffiConverterTypeAddress.read(buf),
            metadata_module_package=_UniffiConverterTypeAddress.read(buf),
            royalty_module_package=_UniffiConverterTypeAddress.read(buf),
            role_assignment_module_package=_UniffiConverterTypeAddress.read(buf),
            genesis_helper_package=_UniffiConverterTypeAddress.read(buf),
            faucet_package=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.package_package, buf)
        _UniffiConverterTypeAddress.write(value.resource_package, buf)
        _UniffiConverterTypeAddress.write(value.account_package, buf)
        _UniffiConverterTypeAddress.write(value.identity_package, buf)
        _UniffiConverterTypeAddress.write(value.consensus_manager_package, buf)
        _UniffiConverterTypeAddress.write(value.access_controller_package, buf)
        _UniffiConverterTypeAddress.write(value.pool_package, buf)
        _UniffiConverterTypeAddress.write(value.transaction_processor_package, buf)
        _UniffiConverterTypeAddress.write(value.metadata_module_package, buf)
        _UniffiConverterTypeAddress.write(value.royalty_module_package, buf)
        _UniffiConverterTypeAddress.write(value.role_assignment_module_package, buf)
        _UniffiConverterTypeAddress.write(value.genesis_helper_package, buf)
        _UniffiConverterTypeAddress.write(value.faucet_package, buf)


class PlainTextMessage:
    mime_type: "str";message: "MessageContent";

    @typing.no_type_check
    def __init__(self, mime_type: "str", message: "MessageContent"):
        self.mime_type = mime_type
        self.message = message

    def __str__(self):
        return "PlainTextMessage(mime_type={}, message={})".format(self.mime_type, self.message)

    def __eq__(self, other):
        if self.mime_type != other.mime_type:
            return False
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypePlainTextMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlainTextMessage(
            mime_type=_UniffiConverterString.read(buf),
            message=_UniffiConverterTypeMessageContent.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.mime_type, buf)
        _UniffiConverterTypeMessageContent.write(value.message, buf)


class ProtocolUpdateReadinessSignalEvent:
    protocol_version_name: "str";

    @typing.no_type_check
    def __init__(self, protocol_version_name: "str"):
        self.protocol_version_name = protocol_version_name

    def __str__(self):
        return "ProtocolUpdateReadinessSignalEvent(protocol_version_name={})".format(self.protocol_version_name)

    def __eq__(self, other):
        if self.protocol_version_name != other.protocol_version_name:
            return False
        return True

class _UniffiConverterTypeProtocolUpdateReadinessSignalEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProtocolUpdateReadinessSignalEvent(
            protocol_version_name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.protocol_version_name, buf)


class RecoveryProposal:
    rule_set: "RuleSet";timed_recovery_delay_in_minutes: "typing.Optional[int]";

    @typing.no_type_check
    def __init__(self, rule_set: "RuleSet", timed_recovery_delay_in_minutes: "typing.Optional[int]"):
        self.rule_set = rule_set
        self.timed_recovery_delay_in_minutes = timed_recovery_delay_in_minutes

    def __str__(self):
        return "RecoveryProposal(rule_set={}, timed_recovery_delay_in_minutes={})".format(self.rule_set, self.timed_recovery_delay_in_minutes)

    def __eq__(self, other):
        if self.rule_set != other.rule_set:
            return False
        if self.timed_recovery_delay_in_minutes != other.timed_recovery_delay_in_minutes:
            return False
        return True

class _UniffiConverterTypeRecoveryProposal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecoveryProposal(
            rule_set=_UniffiConverterTypeRuleSet.read(buf),
            timed_recovery_delay_in_minutes=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeRuleSet.write(value.rule_set, buf)
        _UniffiConverterOptionalUInt32.write(value.timed_recovery_delay_in_minutes, buf)


class RegisterValidatorEvent:
    placeholder_field: "bool";

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "RegisterValidatorEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True

class _UniffiConverterTypeRegisterValidatorEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RegisterValidatorEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class RemoveMetadataEvent:
    key: "str";

    @typing.no_type_check
    def __init__(self, key: "str"):
        self.key = key

    def __str__(self):
        return "RemoveMetadataEvent(key={})".format(self.key)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeRemoveMetadataEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RemoveMetadataEvent(
            key=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)


class ResourceAddresses:
    xrd: "Address";secp256k1_signature_virtual_badge: "Address";ed25519_signature_virtual_badge: "Address";package_of_direct_caller_virtual_badge: "Address";global_caller_virtual_badge: "Address";system_transaction_badge: "Address";package_owner_badge: "Address";validator_owner_badge: "Address";account_owner_badge: "Address";identity_owner_badge: "Address";

    @typing.no_type_check
    def __init__(self, xrd: "Address", secp256k1_signature_virtual_badge: "Address", ed25519_signature_virtual_badge: "Address", package_of_direct_caller_virtual_badge: "Address", global_caller_virtual_badge: "Address", system_transaction_badge: "Address", package_owner_badge: "Address", validator_owner_badge: "Address", account_owner_badge: "Address", identity_owner_badge: "Address"):
        self.xrd = xrd
        self.secp256k1_signature_virtual_badge = secp256k1_signature_virtual_badge
        self.ed25519_signature_virtual_badge = ed25519_signature_virtual_badge
        self.package_of_direct_caller_virtual_badge = package_of_direct_caller_virtual_badge
        self.global_caller_virtual_badge = global_caller_virtual_badge
        self.system_transaction_badge = system_transaction_badge
        self.package_owner_badge = package_owner_badge
        self.validator_owner_badge = validator_owner_badge
        self.account_owner_badge = account_owner_badge
        self.identity_owner_badge = identity_owner_badge

    def __str__(self):
        return "ResourceAddresses(xrd={}, secp256k1_signature_virtual_badge={}, ed25519_signature_virtual_badge={}, package_of_direct_caller_virtual_badge={}, global_caller_virtual_badge={}, system_transaction_badge={}, package_owner_badge={}, validator_owner_badge={}, account_owner_badge={}, identity_owner_badge={})".format(self.xrd, self.secp256k1_signature_virtual_badge, self.ed25519_signature_virtual_badge, self.package_of_direct_caller_virtual_badge, self.global_caller_virtual_badge, self.system_transaction_badge, self.package_owner_badge, self.validator_owner_badge, self.account_owner_badge, self.identity_owner_badge)

    def __eq__(self, other):
        if self.xrd != other.xrd:
            return False
        if self.secp256k1_signature_virtual_badge != other.secp256k1_signature_virtual_badge:
            return False
        if self.ed25519_signature_virtual_badge != other.ed25519_signature_virtual_badge:
            return False
        if self.package_of_direct_caller_virtual_badge != other.package_of_direct_caller_virtual_badge:
            return False
        if self.global_caller_virtual_badge != other.global_caller_virtual_badge:
            return False
        if self.system_transaction_badge != other.system_transaction_badge:
            return False
        if self.package_owner_badge != other.package_owner_badge:
            return False
        if self.validator_owner_badge != other.validator_owner_badge:
            return False
        if self.account_owner_badge != other.account_owner_badge:
            return False
        if self.identity_owner_badge != other.identity_owner_badge:
            return False
        return True

class _UniffiConverterTypeResourceAddresses(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ResourceAddresses(
            xrd=_UniffiConverterTypeAddress.read(buf),
            secp256k1_signature_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            ed25519_signature_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            package_of_direct_caller_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            global_caller_virtual_badge=_UniffiConverterTypeAddress.read(buf),
            system_transaction_badge=_UniffiConverterTypeAddress.read(buf),
            package_owner_badge=_UniffiConverterTypeAddress.read(buf),
            validator_owner_badge=_UniffiConverterTypeAddress.read(buf),
            account_owner_badge=_UniffiConverterTypeAddress.read(buf),
            identity_owner_badge=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.xrd, buf)
        _UniffiConverterTypeAddress.write(value.secp256k1_signature_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(value.ed25519_signature_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(value.package_of_direct_caller_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(value.global_caller_virtual_badge, buf)
        _UniffiConverterTypeAddress.write(value.system_transaction_badge, buf)
        _UniffiConverterTypeAddress.write(value.package_owner_badge, buf)
        _UniffiConverterTypeAddress.write(value.validator_owner_badge, buf)
        _UniffiConverterTypeAddress.write(value.account_owner_badge, buf)
        _UniffiConverterTypeAddress.write(value.identity_owner_badge, buf)


class ResourceManagerRole:
    role: "typing.Optional[AccessRule]";role_updater: "typing.Optional[AccessRule]";

    @typing.no_type_check
    def __init__(self, role: "typing.Optional[AccessRule]", role_updater: "typing.Optional[AccessRule]"):
        self.role = role
        self.role_updater = role_updater

    def __str__(self):
        return "ResourceManagerRole(role={}, role_updater={})".format(self.role, self.role_updater)

    def __eq__(self, other):
        if self.role != other.role:
            return False
        if self.role_updater != other.role_updater:
            return False
        return True

class _UniffiConverterTypeResourceManagerRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ResourceManagerRole(
            role=_UniffiConverterOptionalTypeAccessRule.read(buf),
            role_updater=_UniffiConverterOptionalTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeAccessRule.write(value.role, buf)
        _UniffiConverterOptionalTypeAccessRule.write(value.role_updater, buf)


class RoundChangeEvent:
    round: "int";

    @typing.no_type_check
    def __init__(self, round: "int"):
        self.round = round

    def __str__(self):
        return "RoundChangeEvent(round={})".format(self.round)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        return True

class _UniffiConverterTypeRoundChangeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RoundChangeEvent(
            round=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)


class RuleSet:
    primary_role: "AccessRule";recovery_role: "AccessRule";confirmation_role: "AccessRule";

    @typing.no_type_check
    def __init__(self, primary_role: "AccessRule", recovery_role: "AccessRule", confirmation_role: "AccessRule"):
        self.primary_role = primary_role
        self.recovery_role = recovery_role
        self.confirmation_role = confirmation_role

    def __str__(self):
        return "RuleSet(primary_role={}, recovery_role={}, confirmation_role={})".format(self.primary_role, self.recovery_role, self.confirmation_role)

    def __eq__(self, other):
        if self.primary_role != other.primary_role:
            return False
        if self.recovery_role != other.recovery_role:
            return False
        if self.confirmation_role != other.confirmation_role:
            return False
        return True

class _UniffiConverterTypeRuleSet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RuleSet(
            primary_role=_UniffiConverterTypeAccessRule.read(buf),
            recovery_role=_UniffiConverterTypeAccessRule.read(buf),
            confirmation_role=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessRule.write(value.primary_role, buf)
        _UniffiConverterTypeAccessRule.write(value.recovery_role, buf)
        _UniffiConverterTypeAccessRule.write(value.confirmation_role, buf)


class RuleSetUpdateEvent:
    proposer: "Proposer";proposal: "RecoveryProposal";

    @typing.no_type_check
    def __init__(self, proposer: "Proposer", proposal: "RecoveryProposal"):
        self.proposer = proposer
        self.proposal = proposal

    def __str__(self):
        return "RuleSetUpdateEvent(proposer={}, proposal={})".format(self.proposer, self.proposal)

    def __eq__(self, other):
        if self.proposer != other.proposer:
            return False
        if self.proposal != other.proposal:
            return False
        return True

class _UniffiConverterTypeRuleSetUpdateEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RuleSetUpdateEvent(
            proposer=_UniffiConverterTypeProposer.read(buf),
            proposal=_UniffiConverterTypeRecoveryProposal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeProposer.write(value.proposer, buf)
        _UniffiConverterTypeRecoveryProposal.write(value.proposal, buf)


class Schema:
    local_type_index: "LocalTypeIndex";schema: "typing.List[int]";

    @typing.no_type_check
    def __init__(self, local_type_index: "LocalTypeIndex", schema: "typing.List[int]"):
        self.local_type_index = local_type_index
        self.schema = schema

    def __str__(self):
        return "Schema(local_type_index={}, schema={})".format(self.local_type_index, self.schema)

    def __eq__(self, other):
        if self.local_type_index != other.local_type_index:
            return False
        if self.schema != other.schema:
            return False
        return True

class _UniffiConverterTypeSchema(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Schema(
            local_type_index=_UniffiConverterTypeLocalTypeIndex.read(buf),
            schema=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLocalTypeIndex.write(value.local_type_index, buf)
        _UniffiConverterSequenceUInt8.write(value.schema, buf)


class Secp256k1PublicKey:
    value: "typing.List[int]";

    @typing.no_type_check
    def __init__(self, value: "typing.List[int]"):
        self.value = value

    def __str__(self):
        return "Secp256k1PublicKey(value={})".format(self.value)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeSecp256k1PublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Secp256k1PublicKey(
            value=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt8.write(value.value, buf)


class SecurityStructureRole:
    super_admin_factors: "typing.List[PublicKey]";threshold_factors: "typing.List[PublicKey]";threshold: "int";

    @typing.no_type_check
    def __init__(self, super_admin_factors: "typing.List[PublicKey]", threshold_factors: "typing.List[PublicKey]", threshold: "int"):
        self.super_admin_factors = super_admin_factors
        self.threshold_factors = threshold_factors
        self.threshold = threshold

    def __str__(self):
        return "SecurityStructureRole(super_admin_factors={}, threshold_factors={}, threshold={})".format(self.super_admin_factors, self.threshold_factors, self.threshold)

    def __eq__(self, other):
        if self.super_admin_factors != other.super_admin_factors:
            return False
        if self.threshold_factors != other.threshold_factors:
            return False
        if self.threshold != other.threshold:
            return False
        return True

class _UniffiConverterTypeSecurityStructureRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SecurityStructureRole(
            super_admin_factors=_UniffiConverterSequenceTypePublicKey.read(buf),
            threshold_factors=_UniffiConverterSequenceTypePublicKey.read(buf),
            threshold=_UniffiConverterUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePublicKey.write(value.super_admin_factors, buf)
        _UniffiConverterSequenceTypePublicKey.write(value.threshold_factors, buf)
        _UniffiConverterUInt8.write(value.threshold, buf)


class SetAndLockOwnerRoleEvent:
    rule: "AccessRule";

    @typing.no_type_check
    def __init__(self, rule: "AccessRule"):
        self.rule = rule

    def __str__(self):
        return "SetAndLockOwnerRoleEvent(rule={})".format(self.rule)

    def __eq__(self, other):
        if self.rule != other.rule:
            return False
        return True

class _UniffiConverterTypeSetAndLockOwnerRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetAndLockOwnerRoleEvent(
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class SetAndLockRoleEvent:
    role_key: "str";rule: "AccessRule";

    @typing.no_type_check
    def __init__(self, role_key: "str", rule: "AccessRule"):
        self.role_key = role_key
        self.rule = rule

    def __str__(self):
        return "SetAndLockRoleEvent(role_key={}, rule={})".format(self.role_key, self.rule)

    def __eq__(self, other):
        if self.role_key != other.role_key:
            return False
        if self.rule != other.rule:
            return False
        return True

class _UniffiConverterTypeSetAndLockRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetAndLockRoleEvent(
            role_key=_UniffiConverterString.read(buf),
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.role_key, buf)
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class SetMetadataEvent:
    key: "str";value: "MetadataValue";

    @typing.no_type_check
    def __init__(self, key: "str", value: "MetadataValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "SetMetadataEvent(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeSetMetadataEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetMetadataEvent(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterTypeMetadataValue.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterTypeMetadataValue.write(value.value, buf)


class SetOwnerRoleEvent:
    rule: "AccessRule";

    @typing.no_type_check
    def __init__(self, rule: "AccessRule"):
        self.rule = rule

    def __str__(self):
        return "SetOwnerRoleEvent(rule={})".format(self.rule)

    def __eq__(self, other):
        if self.rule != other.rule:
            return False
        return True

class _UniffiConverterTypeSetOwnerRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetOwnerRoleEvent(
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class SetRoleEvent:
    role_key: "str";rule: "AccessRule";

    @typing.no_type_check
    def __init__(self, role_key: "str", rule: "AccessRule"):
        self.role_key = role_key
        self.rule = rule

    def __str__(self):
        return "SetRoleEvent(role_key={}, rule={})".format(self.role_key, self.rule)

    def __eq__(self, other):
        if self.role_key != other.role_key:
            return False
        if self.rule != other.rule:
            return False
        return True

class _UniffiConverterTypeSetRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SetRoleEvent(
            role_key=_UniffiConverterString.read(buf),
            rule=_UniffiConverterTypeAccessRule.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.role_key, buf)
        _UniffiConverterTypeAccessRule.write(value.rule, buf)


class StakeEvent:
    xrd_staked: "Decimal";

    @typing.no_type_check
    def __init__(self, xrd_staked: "Decimal"):
        self.xrd_staked = xrd_staked

    def __str__(self):
        return "StakeEvent(xrd_staked={})".format(self.xrd_staked)

    def __eq__(self, other):
        if self.xrd_staked != other.xrd_staked:
            return False
        return True

class _UniffiConverterTypeStakeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StakeEvent(
            xrd_staked=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.xrd_staked, buf)


class StopTimedRecoveryEvent:
    placeholder_field: "bool";

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "StopTimedRecoveryEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True

class _UniffiConverterTypeStopTimedRecoveryEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StopTimedRecoveryEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class TransactionHeader:
    network_id: "int";start_epoch_inclusive: "int";end_epoch_exclusive: "int";nonce: "int";notary_public_key: "PublicKey";notary_is_signatory: "bool";tip_percentage: "int";

    @typing.no_type_check
    def __init__(self, network_id: "int", start_epoch_inclusive: "int", end_epoch_exclusive: "int", nonce: "int", notary_public_key: "PublicKey", notary_is_signatory: "bool", tip_percentage: "int"):
        self.network_id = network_id
        self.start_epoch_inclusive = start_epoch_inclusive
        self.end_epoch_exclusive = end_epoch_exclusive
        self.nonce = nonce
        self.notary_public_key = notary_public_key
        self.notary_is_signatory = notary_is_signatory
        self.tip_percentage = tip_percentage

    def __str__(self):
        return "TransactionHeader(network_id={}, start_epoch_inclusive={}, end_epoch_exclusive={}, nonce={}, notary_public_key={}, notary_is_signatory={}, tip_percentage={})".format(self.network_id, self.start_epoch_inclusive, self.end_epoch_exclusive, self.nonce, self.notary_public_key, self.notary_is_signatory, self.tip_percentage)

    def __eq__(self, other):
        if self.network_id != other.network_id:
            return False
        if self.start_epoch_inclusive != other.start_epoch_inclusive:
            return False
        if self.end_epoch_exclusive != other.end_epoch_exclusive:
            return False
        if self.nonce != other.nonce:
            return False
        if self.notary_public_key != other.notary_public_key:
            return False
        if self.notary_is_signatory != other.notary_is_signatory:
            return False
        if self.tip_percentage != other.tip_percentage:
            return False
        return True

class _UniffiConverterTypeTransactionHeader(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionHeader(
            network_id=_UniffiConverterUInt8.read(buf),
            start_epoch_inclusive=_UniffiConverterUInt64.read(buf),
            end_epoch_exclusive=_UniffiConverterUInt64.read(buf),
            nonce=_UniffiConverterUInt32.read(buf),
            notary_public_key=_UniffiConverterTypePublicKey.read(buf),
            notary_is_signatory=_UniffiConverterBool.read(buf),
            tip_percentage=_UniffiConverterUInt16.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.network_id, buf)
        _UniffiConverterUInt64.write(value.start_epoch_inclusive, buf)
        _UniffiConverterUInt64.write(value.end_epoch_exclusive, buf)
        _UniffiConverterUInt32.write(value.nonce, buf)
        _UniffiConverterTypePublicKey.write(value.notary_public_key, buf)
        _UniffiConverterBool.write(value.notary_is_signatory, buf)
        _UniffiConverterUInt16.write(value.tip_percentage, buf)


class TransactionManifestModifications:
    add_access_controller_proofs: "typing.List[Address]";add_lock_fee: "typing.Optional[LockFeeModification]";add_assertions: "typing.List[IndexedAssertion]";

    @typing.no_type_check
    def __init__(self, add_access_controller_proofs: "typing.List[Address]", add_lock_fee: "typing.Optional[LockFeeModification]", add_assertions: "typing.List[IndexedAssertion]"):
        self.add_access_controller_proofs = add_access_controller_proofs
        self.add_lock_fee = add_lock_fee
        self.add_assertions = add_assertions

    def __str__(self):
        return "TransactionManifestModifications(add_access_controller_proofs={}, add_lock_fee={}, add_assertions={})".format(self.add_access_controller_proofs, self.add_lock_fee, self.add_assertions)

    def __eq__(self, other):
        if self.add_access_controller_proofs != other.add_access_controller_proofs:
            return False
        if self.add_lock_fee != other.add_lock_fee:
            return False
        if self.add_assertions != other.add_assertions:
            return False
        return True

class _UniffiConverterTypeTransactionManifestModifications(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionManifestModifications(
            add_access_controller_proofs=_UniffiConverterSequenceTypeAddress.read(buf),
            add_lock_fee=_UniffiConverterOptionalTypeLockFeeModification.read(buf),
            add_assertions=_UniffiConverterSequenceTypeIndexedAssertion.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeAddress.write(value.add_access_controller_proofs, buf)
        _UniffiConverterOptionalTypeLockFeeModification.write(value.add_lock_fee, buf)
        _UniffiConverterSequenceTypeIndexedAssertion.write(value.add_assertions, buf)


class TwoResourcePoolContributionEvent:
    contributed_resources: "dict";pool_units_minted: "Decimal";

    @typing.no_type_check
    def __init__(self, contributed_resources: "dict", pool_units_minted: "Decimal"):
        self.contributed_resources = contributed_resources
        self.pool_units_minted = pool_units_minted

    def __str__(self):
        return "TwoResourcePoolContributionEvent(contributed_resources={}, pool_units_minted={})".format(self.contributed_resources, self.pool_units_minted)

    def __eq__(self, other):
        if self.contributed_resources != other.contributed_resources:
            return False
        if self.pool_units_minted != other.pool_units_minted:
            return False
        return True

class _UniffiConverterTypeTwoResourcePoolContributionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolContributionEvent(
            contributed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
            pool_units_minted=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringTypeDecimal.write(value.contributed_resources, buf)
        _UniffiConverterTypeDecimal.write(value.pool_units_minted, buf)


class TwoResourcePoolDepositEvent:
    resource_address: "Address";amount: "Decimal";

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "TwoResourcePoolDepositEvent(resource_address={}, amount={})".format(self.resource_address, self.amount)

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeTwoResourcePoolDepositEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolDepositEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class TwoResourcePoolRedemptionEvent:
    pool_unit_tokens_redeemed: "Decimal";redeemed_resources: "dict";

    @typing.no_type_check
    def __init__(self, pool_unit_tokens_redeemed: "Decimal", redeemed_resources: "dict"):
        self.pool_unit_tokens_redeemed = pool_unit_tokens_redeemed
        self.redeemed_resources = redeemed_resources

    def __str__(self):
        return "TwoResourcePoolRedemptionEvent(pool_unit_tokens_redeemed={}, redeemed_resources={})".format(self.pool_unit_tokens_redeemed, self.redeemed_resources)

    def __eq__(self, other):
        if self.pool_unit_tokens_redeemed != other.pool_unit_tokens_redeemed:
            return False
        if self.redeemed_resources != other.redeemed_resources:
            return False
        return True

class _UniffiConverterTypeTwoResourcePoolRedemptionEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolRedemptionEvent(
            pool_unit_tokens_redeemed=_UniffiConverterTypeDecimal.read(buf),
            redeemed_resources=_UniffiConverterMapStringTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.pool_unit_tokens_redeemed, buf)
        _UniffiConverterMapStringTypeDecimal.write(value.redeemed_resources, buf)


class TwoResourcePoolWithdrawEvent:
    resource_address: "Address";amount: "Decimal";

    @typing.no_type_check
    def __init__(self, resource_address: "Address", amount: "Decimal"):
        self.resource_address = resource_address
        self.amount = amount

    def __str__(self):
        return "TwoResourcePoolWithdrawEvent(resource_address={}, amount={})".format(self.resource_address, self.amount)

    def __eq__(self, other):
        if self.resource_address != other.resource_address:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeTwoResourcePoolWithdrawEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TwoResourcePoolWithdrawEvent(
            resource_address=_UniffiConverterTypeAddress.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.resource_address, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class UnlockPrimaryRoleEvent:
    placeholder_field: "bool";

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "UnlockPrimaryRoleEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True

class _UniffiConverterTypeUnlockPrimaryRoleEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnlockPrimaryRoleEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class UnregisterValidatorEvent:
    placeholder_field: "bool";

    @typing.no_type_check
    def __init__(self, placeholder_field: "bool"):
        self.placeholder_field = placeholder_field

    def __str__(self):
        return "UnregisterValidatorEvent(placeholder_field={})".format(self.placeholder_field)

    def __eq__(self, other):
        if self.placeholder_field != other.placeholder_field:
            return False
        return True

class _UniffiConverterTypeUnregisterValidatorEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnregisterValidatorEvent(
            placeholder_field=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.placeholder_field, buf)


class UnstakeEvent:
    stake_units: "Decimal";

    @typing.no_type_check
    def __init__(self, stake_units: "Decimal"):
        self.stake_units = stake_units

    def __str__(self):
        return "UnstakeEvent(stake_units={})".format(self.stake_units)

    def __eq__(self, other):
        if self.stake_units != other.stake_units:
            return False
        return True

class _UniffiConverterTypeUnstakeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnstakeEvent(
            stake_units=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDecimal.write(value.stake_units, buf)


class UpdateAcceptingStakeDelegationStateEvent:
    accepts_delegation: "bool";

    @typing.no_type_check
    def __init__(self, accepts_delegation: "bool"):
        self.accepts_delegation = accepts_delegation

    def __str__(self):
        return "UpdateAcceptingStakeDelegationStateEvent(accepts_delegation={})".format(self.accepts_delegation)

    def __eq__(self, other):
        if self.accepts_delegation != other.accepts_delegation:
            return False
        return True

class _UniffiConverterTypeUpdateAcceptingStakeDelegationStateEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UpdateAcceptingStakeDelegationStateEvent(
            accepts_delegation=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.accepts_delegation, buf)


class ValidatorEmissionAppliedEvent:
    epoch: "int";starting_stake_pool_xrd: "Decimal";stake_pool_added_xrd: "Decimal";total_stake_unit_supply: "Decimal";validator_fee_xrd: "Decimal";proposals_made: "int";proposals_missed: "int";

    @typing.no_type_check
    def __init__(self, epoch: "int", starting_stake_pool_xrd: "Decimal", stake_pool_added_xrd: "Decimal", total_stake_unit_supply: "Decimal", validator_fee_xrd: "Decimal", proposals_made: "int", proposals_missed: "int"):
        self.epoch = epoch
        self.starting_stake_pool_xrd = starting_stake_pool_xrd
        self.stake_pool_added_xrd = stake_pool_added_xrd
        self.total_stake_unit_supply = total_stake_unit_supply
        self.validator_fee_xrd = validator_fee_xrd
        self.proposals_made = proposals_made
        self.proposals_missed = proposals_missed

    def __str__(self):
        return "ValidatorEmissionAppliedEvent(epoch={}, starting_stake_pool_xrd={}, stake_pool_added_xrd={}, total_stake_unit_supply={}, validator_fee_xrd={}, proposals_made={}, proposals_missed={})".format(self.epoch, self.starting_stake_pool_xrd, self.stake_pool_added_xrd, self.total_stake_unit_supply, self.validator_fee_xrd, self.proposals_made, self.proposals_missed)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.starting_stake_pool_xrd != other.starting_stake_pool_xrd:
            return False
        if self.stake_pool_added_xrd != other.stake_pool_added_xrd:
            return False
        if self.total_stake_unit_supply != other.total_stake_unit_supply:
            return False
        if self.validator_fee_xrd != other.validator_fee_xrd:
            return False
        if self.proposals_made != other.proposals_made:
            return False
        if self.proposals_missed != other.proposals_missed:
            return False
        return True

class _UniffiConverterTypeValidatorEmissionAppliedEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorEmissionAppliedEvent(
            epoch=_UniffiConverterUInt64.read(buf),
            starting_stake_pool_xrd=_UniffiConverterTypeDecimal.read(buf),
            stake_pool_added_xrd=_UniffiConverterTypeDecimal.read(buf),
            total_stake_unit_supply=_UniffiConverterTypeDecimal.read(buf),
            validator_fee_xrd=_UniffiConverterTypeDecimal.read(buf),
            proposals_made=_UniffiConverterUInt64.read(buf),
            proposals_missed=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterTypeDecimal.write(value.starting_stake_pool_xrd, buf)
        _UniffiConverterTypeDecimal.write(value.stake_pool_added_xrd, buf)
        _UniffiConverterTypeDecimal.write(value.total_stake_unit_supply, buf)
        _UniffiConverterTypeDecimal.write(value.validator_fee_xrd, buf)
        _UniffiConverterUInt64.write(value.proposals_made, buf)
        _UniffiConverterUInt64.write(value.proposals_missed, buf)


class ValidatorInfo:
    key: "Secp256k1PublicKey";stake: "Decimal";

    @typing.no_type_check
    def __init__(self, key: "Secp256k1PublicKey", stake: "Decimal"):
        self.key = key
        self.stake = stake

    def __str__(self):
        return "ValidatorInfo(key={}, stake={})".format(self.key, self.stake)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.stake != other.stake:
            return False
        return True

class _UniffiConverterTypeValidatorInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorInfo(
            key=_UniffiConverterTypeSecp256k1PublicKey.read(buf),
            stake=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSecp256k1PublicKey.write(value.key, buf)
        _UniffiConverterTypeDecimal.write(value.stake, buf)


class ValidatorRewardAppliedEvent:
    epoch: "int";amount: "Decimal";

    @typing.no_type_check
    def __init__(self, epoch: "int", amount: "Decimal"):
        self.epoch = epoch
        self.amount = amount

    def __str__(self):
        return "ValidatorRewardAppliedEvent(epoch={}, amount={})".format(self.epoch, self.amount)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeValidatorRewardAppliedEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorRewardAppliedEvent(
            epoch=_UniffiConverterUInt64.read(buf),
            amount=_UniffiConverterTypeDecimal.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterTypeDecimal.write(value.amount, buf)


class VaultCreationEvent:
    vault_id: "Address";

    @typing.no_type_check
    def __init__(self, vault_id: "Address"):
        self.vault_id = vault_id

    def __str__(self):
        return "VaultCreationEvent(vault_id={})".format(self.vault_id)

    def __eq__(self, other):
        if self.vault_id != other.vault_id:
            return False
        return True

class _UniffiConverterTypeVaultCreationEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return VaultCreationEvent(
            vault_id=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.vault_id, buf)





class AccountDefaultDepositRule(enum.Enum):
    ACCEPT = 1
    REJECT = 2
    ALLOW_EXISTING = 3
    


class _UniffiConverterTypeAccountDefaultDepositRule(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountDefaultDepositRule.ACCEPT
        if variant == 2:
            return AccountDefaultDepositRule.REJECT
        if variant == 3:
            return AccountDefaultDepositRule.ALLOW_EXISTING
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AccountDefaultDepositRule.ACCEPT:
            buf.write_i32(1)
        if value == AccountDefaultDepositRule.REJECT:
            buf.write_i32(2)
        if value == AccountDefaultDepositRule.ALLOW_EXISTING:
            buf.write_i32(3)






class Assertion:
    def __init__(self):
        raise RuntimeError("Assertion cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        resource_address: "Address";amount: "Decimal";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "Decimal"):
            
            self.resource_address = resource_address
            self.amount = amount
            

        def __str__(self):
            return "Assertion.AMOUNT(resource_address={}, amount={})".format(self.resource_address, self.amount)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class IDS:
        resource_address: "Address";ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"):
            
            self.resource_address = resource_address
            self.ids = ids
            

        def __str__(self):
            return "Assertion.IDS(resource_address={}, ids={})".format(self.resource_address, self.ids)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, Assertion.AMOUNT)
    def is_ids(self) -> bool:
        return isinstance(self, Assertion.IDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Assertion.AMOUNT = type("Assertion.AMOUNT", (Assertion.AMOUNT, Assertion,), {})  # type: ignore
Assertion.IDS = type("Assertion.IDS", (Assertion.IDS, Assertion,), {})  # type: ignore




class _UniffiConverterTypeAssertion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Assertion.AMOUNT(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return Assertion.IDS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)






class Curve(enum.Enum):
    SECP256K1 = 1
    ED25519 = 2
    


class _UniffiConverterTypeCurve(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Curve.SECP256K1
        if variant == 2:
            return Curve.ED25519
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Curve.SECP256K1:
            buf.write_i32(1)
        if value == Curve.ED25519:
            buf.write_i32(2)






class CurveType(enum.Enum):
    ED25519 = 1
    SECP256K1 = 2
    


class _UniffiConverterTypeCurveType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CurveType.ED25519
        if variant == 2:
            return CurveType.SECP256K1
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == CurveType.ED25519:
            buf.write_i32(1)
        if value == CurveType.SECP256K1:
            buf.write_i32(2)






class DecimalSource:
    def __init__(self):
        raise RuntimeError("DecimalSource cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GUARANTEED:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "DecimalSource.GUARANTEED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_guaranteed():
                return False
            if self.value != other.value:
                return False
            return True
    class PREDICTED:
        instruction_index: "int";value: "Decimal";

        @typing.no_type_check
        def __init__(self,instruction_index: "int", value: "Decimal"):
            
            self.instruction_index = instruction_index
            self.value = value
            

        def __str__(self):
            return "DecimalSource.PREDICTED(instruction_index={}, value={})".format(self.instruction_index, self.value)

        def __eq__(self, other):
            if not other.is_predicted():
                return False
            if self.instruction_index != other.instruction_index:
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_guaranteed(self) -> bool:
        return isinstance(self, DecimalSource.GUARANTEED)
    def is_predicted(self) -> bool:
        return isinstance(self, DecimalSource.PREDICTED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DecimalSource.GUARANTEED = type("DecimalSource.GUARANTEED", (DecimalSource.GUARANTEED, DecimalSource,), {})  # type: ignore
DecimalSource.PREDICTED = type("DecimalSource.PREDICTED", (DecimalSource.PREDICTED, DecimalSource,), {})  # type: ignore




class _UniffiConverterTypeDecimalSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DecimalSource.GUARANTEED(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return DecimalSource.PREDICTED(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_guaranteed():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_predicted():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.instruction_index, buf)
            _UniffiConverterTypeDecimal.write(value.value, buf)






class DecryptorsByCurve:
    def __init__(self):
        raise RuntimeError("DecryptorsByCurve cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ED25519:
        dh_ephemeral_public_key: "Ed25519PublicKey";decryptors: "dict";

        @typing.no_type_check
        def __init__(self,dh_ephemeral_public_key: "Ed25519PublicKey", decryptors: "dict"):
            
            self.dh_ephemeral_public_key = dh_ephemeral_public_key
            self.decryptors = decryptors
            

        def __str__(self):
            return "DecryptorsByCurve.ED25519(dh_ephemeral_public_key={}, decryptors={})".format(self.dh_ephemeral_public_key, self.decryptors)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.dh_ephemeral_public_key != other.dh_ephemeral_public_key:
                return False
            if self.decryptors != other.decryptors:
                return False
            return True
    class SECP256K1:
        dh_ephemeral_public_key: "Secp256k1PublicKey";decryptors: "dict";

        @typing.no_type_check
        def __init__(self,dh_ephemeral_public_key: "Secp256k1PublicKey", decryptors: "dict"):
            
            self.dh_ephemeral_public_key = dh_ephemeral_public_key
            self.decryptors = decryptors
            

        def __str__(self):
            return "DecryptorsByCurve.SECP256K1(dh_ephemeral_public_key={}, decryptors={})".format(self.dh_ephemeral_public_key, self.decryptors)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.dh_ephemeral_public_key != other.dh_ephemeral_public_key:
                return False
            if self.decryptors != other.decryptors:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ed25519(self) -> bool:
        return isinstance(self, DecryptorsByCurve.ED25519)
    def is_secp256k1(self) -> bool:
        return isinstance(self, DecryptorsByCurve.SECP256K1)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DecryptorsByCurve.ED25519 = type("DecryptorsByCurve.ED25519", (DecryptorsByCurve.ED25519, DecryptorsByCurve,), {})  # type: ignore
DecryptorsByCurve.SECP256K1 = type("DecryptorsByCurve.SECP256K1", (DecryptorsByCurve.SECP256K1, DecryptorsByCurve,), {})  # type: ignore




class _UniffiConverterTypeDecryptorsByCurve(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DecryptorsByCurve.ED25519(
                _UniffiConverterTypeEd25519PublicKey.read(buf),
                _UniffiConverterMapSequenceUInt8SequenceUInt8.read(buf),
            )
        if variant == 2:
            return DecryptorsByCurve.SECP256K1(
                _UniffiConverterTypeSecp256k1PublicKey.read(buf),
                _UniffiConverterMapSequenceUInt8SequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ed25519():
            buf.write_i32(1)
            _UniffiConverterTypeEd25519PublicKey.write(value.dh_ephemeral_public_key, buf)
            _UniffiConverterMapSequenceUInt8SequenceUInt8.write(value.decryptors, buf)
        if value.is_secp256k1():
            buf.write_i32(2)
            _UniffiConverterTypeSecp256k1PublicKey.write(value.dh_ephemeral_public_key, buf)
            _UniffiConverterMapSequenceUInt8SequenceUInt8.write(value.decryptors, buf)






class DependencyInformation:
    def __init__(self):
        raise RuntimeError("DependencyInformation cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class VERSION:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "DependencyInformation.VERSION(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_version():
                return False
            if self.value != other.value:
                return False
            return True
    class TAG:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "DependencyInformation.TAG(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_tag():
                return False
            if self.value != other.value:
                return False
            return True
    class BRANCH:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "DependencyInformation.BRANCH(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_branch():
                return False
            if self.value != other.value:
                return False
            return True
    class REV:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "DependencyInformation.REV(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_rev():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_version(self) -> bool:
        return isinstance(self, DependencyInformation.VERSION)
    def is_tag(self) -> bool:
        return isinstance(self, DependencyInformation.TAG)
    def is_branch(self) -> bool:
        return isinstance(self, DependencyInformation.BRANCH)
    def is_rev(self) -> bool:
        return isinstance(self, DependencyInformation.REV)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DependencyInformation.VERSION = type("DependencyInformation.VERSION", (DependencyInformation.VERSION, DependencyInformation,), {})  # type: ignore
DependencyInformation.TAG = type("DependencyInformation.TAG", (DependencyInformation.TAG, DependencyInformation,), {})  # type: ignore
DependencyInformation.BRANCH = type("DependencyInformation.BRANCH", (DependencyInformation.BRANCH, DependencyInformation,), {})  # type: ignore
DependencyInformation.REV = type("DependencyInformation.REV", (DependencyInformation.REV, DependencyInformation,), {})  # type: ignore




class _UniffiConverterTypeDependencyInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DependencyInformation.VERSION(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return DependencyInformation.TAG(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return DependencyInformation.BRANCH(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return DependencyInformation.REV(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_version():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_tag():
            buf.write_i32(2)
            _UniffiConverterString.write(value.value, buf)
        if value.is_branch():
            buf.write_i32(3)
            _UniffiConverterString.write(value.value, buf)
        if value.is_rev():
            buf.write_i32(4)
            _UniffiConverterString.write(value.value, buf)






class DepositResourceEvent:
    def __init__(self):
        raise RuntimeError("DepositResourceEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "DepositResourceEvent.AMOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.value != other.value:
                return False
            return True
    class IDS:
        value: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[NonFungibleLocalId]"):
            
            self.value = value
            

        def __str__(self):
            return "DepositResourceEvent.IDS(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, DepositResourceEvent.AMOUNT)
    def is_ids(self) -> bool:
        return isinstance(self, DepositResourceEvent.IDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DepositResourceEvent.AMOUNT = type("DepositResourceEvent.AMOUNT", (DepositResourceEvent.AMOUNT, DepositResourceEvent,), {})  # type: ignore
DepositResourceEvent.IDS = type("DepositResourceEvent.IDS", (DepositResourceEvent.IDS, DepositResourceEvent,), {})  # type: ignore




class _UniffiConverterTypeDepositResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DepositResourceEvent.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return DepositResourceEvent.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)






class Emitter:
    def __init__(self):
        raise RuntimeError("Emitter cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNCTION:
        address: "Address";blueprint_name: "str";

        @typing.no_type_check
        def __init__(self,address: "Address", blueprint_name: "str"):
            
            self.address = address
            self.blueprint_name = blueprint_name
            

        def __str__(self):
            return "Emitter.FUNCTION(address={}, blueprint_name={})".format(self.address, self.blueprint_name)

        def __eq__(self, other):
            if not other.is_function():
                return False
            if self.address != other.address:
                return False
            if self.blueprint_name != other.blueprint_name:
                return False
            return True
    class METHOD:
        address: "Address";object_module_id: "ObjectModuleId";

        @typing.no_type_check
        def __init__(self,address: "Address", object_module_id: "ObjectModuleId"):
            
            self.address = address
            self.object_module_id = object_module_id
            

        def __str__(self):
            return "Emitter.METHOD(address={}, object_module_id={})".format(self.address, self.object_module_id)

        def __eq__(self, other):
            if not other.is_method():
                return False
            if self.address != other.address:
                return False
            if self.object_module_id != other.object_module_id:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_function(self) -> bool:
        return isinstance(self, Emitter.FUNCTION)
    def is_method(self) -> bool:
        return isinstance(self, Emitter.METHOD)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Emitter.FUNCTION = type("Emitter.FUNCTION", (Emitter.FUNCTION, Emitter,), {})  # type: ignore
Emitter.METHOD = type("Emitter.METHOD", (Emitter.METHOD, Emitter,), {})  # type: ignore




class _UniffiConverterTypeEmitter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Emitter.FUNCTION(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return Emitter.METHOD(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeObjectModuleId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_function():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterString.write(value.blueprint_name, buf)
        if value.is_method():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterTypeObjectModuleId.write(value.object_module_id, buf)






class EntityType(enum.Enum):
    GLOBAL_PACKAGE = 1
    GLOBAL_FUNGIBLE_RESOURCE_MANAGER = 2
    GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER = 3
    GLOBAL_CONSENSUS_MANAGER = 4
    GLOBAL_VALIDATOR = 5
    GLOBAL_ACCESS_CONTROLLER = 6
    GLOBAL_ACCOUNT = 7
    GLOBAL_IDENTITY = 8
    GLOBAL_GENERIC_COMPONENT = 9
    GLOBAL_VIRTUAL_SECP256K1_ACCOUNT = 10
    GLOBAL_VIRTUAL_ED25519_ACCOUNT = 11
    GLOBAL_VIRTUAL_SECP256K1_IDENTITY = 12
    GLOBAL_VIRTUAL_ED25519_IDENTITY = 13
    GLOBAL_ONE_RESOURCE_POOL = 14
    GLOBAL_TWO_RESOURCE_POOL = 15
    GLOBAL_MULTI_RESOURCE_POOL = 16
    GLOBAL_TRANSACTION_TRACKER = 17
    INTERNAL_FUNGIBLE_VAULT = 18
    INTERNAL_NON_FUNGIBLE_VAULT = 19
    INTERNAL_ACCOUNT = 20
    INTERNAL_GENERIC_COMPONENT = 21
    INTERNAL_KEY_VALUE_STORE = 22
    


class _UniffiConverterTypeEntityType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EntityType.GLOBAL_PACKAGE
        if variant == 2:
            return EntityType.GLOBAL_FUNGIBLE_RESOURCE_MANAGER
        if variant == 3:
            return EntityType.GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER
        if variant == 4:
            return EntityType.GLOBAL_CONSENSUS_MANAGER
        if variant == 5:
            return EntityType.GLOBAL_VALIDATOR
        if variant == 6:
            return EntityType.GLOBAL_ACCESS_CONTROLLER
        if variant == 7:
            return EntityType.GLOBAL_ACCOUNT
        if variant == 8:
            return EntityType.GLOBAL_IDENTITY
        if variant == 9:
            return EntityType.GLOBAL_GENERIC_COMPONENT
        if variant == 10:
            return EntityType.GLOBAL_VIRTUAL_SECP256K1_ACCOUNT
        if variant == 11:
            return EntityType.GLOBAL_VIRTUAL_ED25519_ACCOUNT
        if variant == 12:
            return EntityType.GLOBAL_VIRTUAL_SECP256K1_IDENTITY
        if variant == 13:
            return EntityType.GLOBAL_VIRTUAL_ED25519_IDENTITY
        if variant == 14:
            return EntityType.GLOBAL_ONE_RESOURCE_POOL
        if variant == 15:
            return EntityType.GLOBAL_TWO_RESOURCE_POOL
        if variant == 16:
            return EntityType.GLOBAL_MULTI_RESOURCE_POOL
        if variant == 17:
            return EntityType.GLOBAL_TRANSACTION_TRACKER
        if variant == 18:
            return EntityType.INTERNAL_FUNGIBLE_VAULT
        if variant == 19:
            return EntityType.INTERNAL_NON_FUNGIBLE_VAULT
        if variant == 20:
            return EntityType.INTERNAL_ACCOUNT
        if variant == 21:
            return EntityType.INTERNAL_GENERIC_COMPONENT
        if variant == 22:
            return EntityType.INTERNAL_KEY_VALUE_STORE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == EntityType.GLOBAL_PACKAGE:
            buf.write_i32(1)
        if value == EntityType.GLOBAL_FUNGIBLE_RESOURCE_MANAGER:
            buf.write_i32(2)
        if value == EntityType.GLOBAL_NON_FUNGIBLE_RESOURCE_MANAGER:
            buf.write_i32(3)
        if value == EntityType.GLOBAL_CONSENSUS_MANAGER:
            buf.write_i32(4)
        if value == EntityType.GLOBAL_VALIDATOR:
            buf.write_i32(5)
        if value == EntityType.GLOBAL_ACCESS_CONTROLLER:
            buf.write_i32(6)
        if value == EntityType.GLOBAL_ACCOUNT:
            buf.write_i32(7)
        if value == EntityType.GLOBAL_IDENTITY:
            buf.write_i32(8)
        if value == EntityType.GLOBAL_GENERIC_COMPONENT:
            buf.write_i32(9)
        if value == EntityType.GLOBAL_VIRTUAL_SECP256K1_ACCOUNT:
            buf.write_i32(10)
        if value == EntityType.GLOBAL_VIRTUAL_ED25519_ACCOUNT:
            buf.write_i32(11)
        if value == EntityType.GLOBAL_VIRTUAL_SECP256K1_IDENTITY:
            buf.write_i32(12)
        if value == EntityType.GLOBAL_VIRTUAL_ED25519_IDENTITY:
            buf.write_i32(13)
        if value == EntityType.GLOBAL_ONE_RESOURCE_POOL:
            buf.write_i32(14)
        if value == EntityType.GLOBAL_TWO_RESOURCE_POOL:
            buf.write_i32(15)
        if value == EntityType.GLOBAL_MULTI_RESOURCE_POOL:
            buf.write_i32(16)
        if value == EntityType.GLOBAL_TRANSACTION_TRACKER:
            buf.write_i32(17)
        if value == EntityType.INTERNAL_FUNGIBLE_VAULT:
            buf.write_i32(18)
        if value == EntityType.INTERNAL_NON_FUNGIBLE_VAULT:
            buf.write_i32(19)
        if value == EntityType.INTERNAL_ACCOUNT:
            buf.write_i32(20)
        if value == EntityType.INTERNAL_GENERIC_COMPONENT:
            buf.write_i32(21)
        if value == EntityType.INTERNAL_KEY_VALUE_STORE:
            buf.write_i32(22)






class Instruction:
    def __init__(self):
        raise RuntimeError("Instruction cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TAKE_ALL_FROM_WORKTOP:
        resource_address: "Address";

        @typing.no_type_check
        def __init__(self,resource_address: "Address"):
            
            self.resource_address = resource_address
            

        def __str__(self):
            return "Instruction.TAKE_ALL_FROM_WORKTOP(resource_address={})".format(self.resource_address)

        def __eq__(self, other):
            if not other.is_take_all_from_worktop():
                return False
            if self.resource_address != other.resource_address:
                return False
            return True
    class TAKE_FROM_WORKTOP:
        resource_address: "Address";amount: "Decimal";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "Decimal"):
            
            self.resource_address = resource_address
            self.amount = amount
            

        def __str__(self):
            return "Instruction.TAKE_FROM_WORKTOP(resource_address={}, amount={})".format(self.resource_address, self.amount)

        def __eq__(self, other):
            if not other.is_take_from_worktop():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class TAKE_NON_FUNGIBLES_FROM_WORKTOP:
        resource_address: "Address";ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"):
            
            self.resource_address = resource_address
            self.ids = ids
            

        def __str__(self):
            return "Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP(resource_address={}, ids={})".format(self.resource_address, self.ids)

        def __eq__(self, other):
            if not other.is_take_non_fungibles_from_worktop():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True
    class RETURN_TO_WORKTOP:
        bucket_id: "ManifestBucket";

        @typing.no_type_check
        def __init__(self,bucket_id: "ManifestBucket"):
            
            self.bucket_id = bucket_id
            

        def __str__(self):
            return "Instruction.RETURN_TO_WORKTOP(bucket_id={})".format(self.bucket_id)

        def __eq__(self, other):
            if not other.is_return_to_worktop():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            return True
    class ASSERT_WORKTOP_CONTAINS:
        resource_address: "Address";amount: "Decimal";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "Decimal"):
            
            self.resource_address = resource_address
            self.amount = amount
            

        def __str__(self):
            return "Instruction.ASSERT_WORKTOP_CONTAINS(resource_address={}, amount={})".format(self.resource_address, self.amount)

        def __eq__(self, other):
            if not other.is_assert_worktop_contains():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class ASSERT_WORKTOP_CONTAINS_ANY:
        resource_address: "Address";

        @typing.no_type_check
        def __init__(self,resource_address: "Address"):
            
            self.resource_address = resource_address
            

        def __str__(self):
            return "Instruction.ASSERT_WORKTOP_CONTAINS_ANY(resource_address={})".format(self.resource_address)

        def __eq__(self, other):
            if not other.is_assert_worktop_contains_any():
                return False
            if self.resource_address != other.resource_address:
                return False
            return True
    class ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES:
        resource_address: "Address";ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"):
            
            self.resource_address = resource_address
            self.ids = ids
            

        def __str__(self):
            return "Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES(resource_address={}, ids={})".format(self.resource_address, self.ids)

        def __eq__(self, other):
            if not other.is_assert_worktop_contains_non_fungibles():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True
    class POP_FROM_AUTH_ZONE:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Instruction.POP_FROM_AUTH_ZONE()".format()

        def __eq__(self, other):
            if not other.is_pop_from_auth_zone():
                return False
            return True
    class PUSH_TO_AUTH_ZONE:
        proof_id: "ManifestProof";

        @typing.no_type_check
        def __init__(self,proof_id: "ManifestProof"):
            
            self.proof_id = proof_id
            

        def __str__(self):
            return "Instruction.PUSH_TO_AUTH_ZONE(proof_id={})".format(self.proof_id)

        def __eq__(self, other):
            if not other.is_push_to_auth_zone():
                return False
            if self.proof_id != other.proof_id:
                return False
            return True
    class CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT:
        resource_address: "Address";amount: "Decimal";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "Decimal"):
            
            self.resource_address = resource_address
            self.amount = amount
            

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT(resource_address={}, amount={})".format(self.resource_address, self.amount)

        def __eq__(self, other):
            if not other.is_create_proof_from_auth_zone_of_amount():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES:
        resource_address: "Address";ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"):
            
            self.resource_address = resource_address
            self.ids = ids
            

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES(resource_address={}, ids={})".format(self.resource_address, self.ids)

        def __eq__(self, other):
            if not other.is_create_proof_from_auth_zone_of_non_fungibles():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True
    class CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL:
        resource_address: "Address";

        @typing.no_type_check
        def __init__(self,resource_address: "Address"):
            
            self.resource_address = resource_address
            

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL(resource_address={})".format(self.resource_address)

        def __eq__(self, other):
            if not other.is_create_proof_from_auth_zone_of_all():
                return False
            if self.resource_address != other.resource_address:
                return False
            return True
    class DROP_ALL_PROOFS:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Instruction.DROP_ALL_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_all_proofs():
                return False
            return True
    class DROP_NAMED_PROOFS:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Instruction.DROP_NAMED_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_named_proofs():
                return False
            return True
    class DROP_AUTH_ZONE_PROOFS:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Instruction.DROP_AUTH_ZONE_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_auth_zone_proofs():
                return False
            return True
    class DROP_AUTH_ZONE_REGULAR_PROOFS:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_auth_zone_regular_proofs():
                return False
            return True
    class DROP_AUTH_ZONE_SIGNATURE_PROOFS:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS()".format()

        def __eq__(self, other):
            if not other.is_drop_auth_zone_signature_proofs():
                return False
            return True
    class CREATE_PROOF_FROM_BUCKET_OF_AMOUNT:
        bucket_id: "ManifestBucket";amount: "Decimal";

        @typing.no_type_check
        def __init__(self,bucket_id: "ManifestBucket", amount: "Decimal"):
            
            self.bucket_id = bucket_id
            self.amount = amount
            

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT(bucket_id={}, amount={})".format(self.bucket_id, self.amount)

        def __eq__(self, other):
            if not other.is_create_proof_from_bucket_of_amount():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            if self.amount != other.amount:
                return False
            return True
    class CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES:
        bucket_id: "ManifestBucket";ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,bucket_id: "ManifestBucket", ids: "typing.List[NonFungibleLocalId]"):
            
            self.bucket_id = bucket_id
            self.ids = ids
            

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES(bucket_id={}, ids={})".format(self.bucket_id, self.ids)

        def __eq__(self, other):
            if not other.is_create_proof_from_bucket_of_non_fungibles():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            if self.ids != other.ids:
                return False
            return True
    class CREATE_PROOF_FROM_BUCKET_OF_ALL:
        bucket_id: "ManifestBucket";

        @typing.no_type_check
        def __init__(self,bucket_id: "ManifestBucket"):
            
            self.bucket_id = bucket_id
            

        def __str__(self):
            return "Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL(bucket_id={})".format(self.bucket_id)

        def __eq__(self, other):
            if not other.is_create_proof_from_bucket_of_all():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            return True
    class BURN_RESOURCE:
        bucket_id: "ManifestBucket";

        @typing.no_type_check
        def __init__(self,bucket_id: "ManifestBucket"):
            
            self.bucket_id = bucket_id
            

        def __str__(self):
            return "Instruction.BURN_RESOURCE(bucket_id={})".format(self.bucket_id)

        def __eq__(self, other):
            if not other.is_burn_resource():
                return False
            if self.bucket_id != other.bucket_id:
                return False
            return True
    class CLONE_PROOF:
        proof_id: "ManifestProof";

        @typing.no_type_check
        def __init__(self,proof_id: "ManifestProof"):
            
            self.proof_id = proof_id
            

        def __str__(self):
            return "Instruction.CLONE_PROOF(proof_id={})".format(self.proof_id)

        def __eq__(self, other):
            if not other.is_clone_proof():
                return False
            if self.proof_id != other.proof_id:
                return False
            return True
    class DROP_PROOF:
        proof_id: "ManifestProof";

        @typing.no_type_check
        def __init__(self,proof_id: "ManifestProof"):
            
            self.proof_id = proof_id
            

        def __str__(self):
            return "Instruction.DROP_PROOF(proof_id={})".format(self.proof_id)

        def __eq__(self, other):
            if not other.is_drop_proof():
                return False
            if self.proof_id != other.proof_id:
                return False
            return True
    class CALL_FUNCTION:
        package_address: "ManifestAddress";blueprint_name: "str";function_name: "str";args: "ManifestValue";

        @typing.no_type_check
        def __init__(self,package_address: "ManifestAddress", blueprint_name: "str", function_name: "str", args: "ManifestValue"):
            
            self.package_address = package_address
            self.blueprint_name = blueprint_name
            self.function_name = function_name
            self.args = args
            

        def __str__(self):
            return "Instruction.CALL_FUNCTION(package_address={}, blueprint_name={}, function_name={}, args={})".format(self.package_address, self.blueprint_name, self.function_name, self.args)

        def __eq__(self, other):
            if not other.is_call_function():
                return False
            if self.package_address != other.package_address:
                return False
            if self.blueprint_name != other.blueprint_name:
                return False
            if self.function_name != other.function_name:
                return False
            if self.args != other.args:
                return False
            return True
    class CALL_METHOD:
        address: "ManifestAddress";method_name: "str";args: "ManifestValue";

        @typing.no_type_check
        def __init__(self,address: "ManifestAddress", method_name: "str", args: "ManifestValue"):
            
            self.address = address
            self.method_name = method_name
            self.args = args
            

        def __str__(self):
            return "Instruction.CALL_METHOD(address={}, method_name={}, args={})".format(self.address, self.method_name, self.args)

        def __eq__(self, other):
            if not other.is_call_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True
    class CALL_ROYALTY_METHOD:
        address: "ManifestAddress";method_name: "str";args: "ManifestValue";

        @typing.no_type_check
        def __init__(self,address: "ManifestAddress", method_name: "str", args: "ManifestValue"):
            
            self.address = address
            self.method_name = method_name
            self.args = args
            

        def __str__(self):
            return "Instruction.CALL_ROYALTY_METHOD(address={}, method_name={}, args={})".format(self.address, self.method_name, self.args)

        def __eq__(self, other):
            if not other.is_call_royalty_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True
    class CALL_METADATA_METHOD:
        address: "ManifestAddress";method_name: "str";args: "ManifestValue";

        @typing.no_type_check
        def __init__(self,address: "ManifestAddress", method_name: "str", args: "ManifestValue"):
            
            self.address = address
            self.method_name = method_name
            self.args = args
            

        def __str__(self):
            return "Instruction.CALL_METADATA_METHOD(address={}, method_name={}, args={})".format(self.address, self.method_name, self.args)

        def __eq__(self, other):
            if not other.is_call_metadata_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True
    class CALL_ROLE_ASSIGNMENT_METHOD:
        address: "ManifestAddress";method_name: "str";args: "ManifestValue";

        @typing.no_type_check
        def __init__(self,address: "ManifestAddress", method_name: "str", args: "ManifestValue"):
            
            self.address = address
            self.method_name = method_name
            self.args = args
            

        def __str__(self):
            return "Instruction.CALL_ROLE_ASSIGNMENT_METHOD(address={}, method_name={}, args={})".format(self.address, self.method_name, self.args)

        def __eq__(self, other):
            if not other.is_call_role_assignment_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True
    class CALL_DIRECT_VAULT_METHOD:
        address: "Address";method_name: "str";args: "ManifestValue";

        @typing.no_type_check
        def __init__(self,address: "Address", method_name: "str", args: "ManifestValue"):
            
            self.address = address
            self.method_name = method_name
            self.args = args
            

        def __str__(self):
            return "Instruction.CALL_DIRECT_VAULT_METHOD(address={}, method_name={}, args={})".format(self.address, self.method_name, self.args)

        def __eq__(self, other):
            if not other.is_call_direct_vault_method():
                return False
            if self.address != other.address:
                return False
            if self.method_name != other.method_name:
                return False
            if self.args != other.args:
                return False
            return True
    class ALLOCATE_GLOBAL_ADDRESS:
        package_address: "Address";blueprint_name: "str";

        @typing.no_type_check
        def __init__(self,package_address: "Address", blueprint_name: "str"):
            
            self.package_address = package_address
            self.blueprint_name = blueprint_name
            

        def __str__(self):
            return "Instruction.ALLOCATE_GLOBAL_ADDRESS(package_address={}, blueprint_name={})".format(self.package_address, self.blueprint_name)

        def __eq__(self, other):
            if not other.is_allocate_global_address():
                return False
            if self.package_address != other.package_address:
                return False
            if self.blueprint_name != other.blueprint_name:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_take_all_from_worktop(self) -> bool:
        return isinstance(self, Instruction.TAKE_ALL_FROM_WORKTOP)
    def is_take_from_worktop(self) -> bool:
        return isinstance(self, Instruction.TAKE_FROM_WORKTOP)
    def is_take_non_fungibles_from_worktop(self) -> bool:
        return isinstance(self, Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP)
    def is_return_to_worktop(self) -> bool:
        return isinstance(self, Instruction.RETURN_TO_WORKTOP)
    def is_assert_worktop_contains(self) -> bool:
        return isinstance(self, Instruction.ASSERT_WORKTOP_CONTAINS)
    def is_assert_worktop_contains_any(self) -> bool:
        return isinstance(self, Instruction.ASSERT_WORKTOP_CONTAINS_ANY)
    def is_assert_worktop_contains_non_fungibles(self) -> bool:
        return isinstance(self, Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES)
    def is_pop_from_auth_zone(self) -> bool:
        return isinstance(self, Instruction.POP_FROM_AUTH_ZONE)
    def is_push_to_auth_zone(self) -> bool:
        return isinstance(self, Instruction.PUSH_TO_AUTH_ZONE)
    def is_create_proof_from_auth_zone_of_amount(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT)
    def is_create_proof_from_auth_zone_of_non_fungibles(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES)
    def is_create_proof_from_auth_zone_of_all(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL)
    def is_drop_all_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_ALL_PROOFS)
    def is_drop_named_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_NAMED_PROOFS)
    def is_drop_auth_zone_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_AUTH_ZONE_PROOFS)
    def is_drop_auth_zone_regular_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS)
    def is_drop_auth_zone_signature_proofs(self) -> bool:
        return isinstance(self, Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS)
    def is_create_proof_from_bucket_of_amount(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT)
    def is_create_proof_from_bucket_of_non_fungibles(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES)
    def is_create_proof_from_bucket_of_all(self) -> bool:
        return isinstance(self, Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL)
    def is_burn_resource(self) -> bool:
        return isinstance(self, Instruction.BURN_RESOURCE)
    def is_clone_proof(self) -> bool:
        return isinstance(self, Instruction.CLONE_PROOF)
    def is_drop_proof(self) -> bool:
        return isinstance(self, Instruction.DROP_PROOF)
    def is_call_function(self) -> bool:
        return isinstance(self, Instruction.CALL_FUNCTION)
    def is_call_method(self) -> bool:
        return isinstance(self, Instruction.CALL_METHOD)
    def is_call_royalty_method(self) -> bool:
        return isinstance(self, Instruction.CALL_ROYALTY_METHOD)
    def is_call_metadata_method(self) -> bool:
        return isinstance(self, Instruction.CALL_METADATA_METHOD)
    def is_call_role_assignment_method(self) -> bool:
        return isinstance(self, Instruction.CALL_ROLE_ASSIGNMENT_METHOD)
    def is_call_direct_vault_method(self) -> bool:
        return isinstance(self, Instruction.CALL_DIRECT_VAULT_METHOD)
    def is_allocate_global_address(self) -> bool:
        return isinstance(self, Instruction.ALLOCATE_GLOBAL_ADDRESS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Instruction.TAKE_ALL_FROM_WORKTOP = type("Instruction.TAKE_ALL_FROM_WORKTOP", (Instruction.TAKE_ALL_FROM_WORKTOP, Instruction,), {})  # type: ignore
Instruction.TAKE_FROM_WORKTOP = type("Instruction.TAKE_FROM_WORKTOP", (Instruction.TAKE_FROM_WORKTOP, Instruction,), {})  # type: ignore
Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP = type("Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP", (Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP, Instruction,), {})  # type: ignore
Instruction.RETURN_TO_WORKTOP = type("Instruction.RETURN_TO_WORKTOP", (Instruction.RETURN_TO_WORKTOP, Instruction,), {})  # type: ignore
Instruction.ASSERT_WORKTOP_CONTAINS = type("Instruction.ASSERT_WORKTOP_CONTAINS", (Instruction.ASSERT_WORKTOP_CONTAINS, Instruction,), {})  # type: ignore
Instruction.ASSERT_WORKTOP_CONTAINS_ANY = type("Instruction.ASSERT_WORKTOP_CONTAINS_ANY", (Instruction.ASSERT_WORKTOP_CONTAINS_ANY, Instruction,), {})  # type: ignore
Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES = type("Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES", (Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES, Instruction,), {})  # type: ignore
Instruction.POP_FROM_AUTH_ZONE = type("Instruction.POP_FROM_AUTH_ZONE", (Instruction.POP_FROM_AUTH_ZONE, Instruction,), {})  # type: ignore
Instruction.PUSH_TO_AUTH_ZONE = type("Instruction.PUSH_TO_AUTH_ZONE", (Instruction.PUSH_TO_AUTH_ZONE, Instruction,), {})  # type: ignore
Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT = type("Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT", (Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT, Instruction,), {})  # type: ignore
Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES = type("Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES", (Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES, Instruction,), {})  # type: ignore
Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL = type("Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL", (Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL, Instruction,), {})  # type: ignore
Instruction.DROP_ALL_PROOFS = type("Instruction.DROP_ALL_PROOFS", (Instruction.DROP_ALL_PROOFS, Instruction,), {})  # type: ignore
Instruction.DROP_NAMED_PROOFS = type("Instruction.DROP_NAMED_PROOFS", (Instruction.DROP_NAMED_PROOFS, Instruction,), {})  # type: ignore
Instruction.DROP_AUTH_ZONE_PROOFS = type("Instruction.DROP_AUTH_ZONE_PROOFS", (Instruction.DROP_AUTH_ZONE_PROOFS, Instruction,), {})  # type: ignore
Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS = type("Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS", (Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS, Instruction,), {})  # type: ignore
Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS = type("Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS", (Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS, Instruction,), {})  # type: ignore
Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT = type("Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT", (Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT, Instruction,), {})  # type: ignore
Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES = type("Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES", (Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES, Instruction,), {})  # type: ignore
Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL = type("Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL", (Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL, Instruction,), {})  # type: ignore
Instruction.BURN_RESOURCE = type("Instruction.BURN_RESOURCE", (Instruction.BURN_RESOURCE, Instruction,), {})  # type: ignore
Instruction.CLONE_PROOF = type("Instruction.CLONE_PROOF", (Instruction.CLONE_PROOF, Instruction,), {})  # type: ignore
Instruction.DROP_PROOF = type("Instruction.DROP_PROOF", (Instruction.DROP_PROOF, Instruction,), {})  # type: ignore
Instruction.CALL_FUNCTION = type("Instruction.CALL_FUNCTION", (Instruction.CALL_FUNCTION, Instruction,), {})  # type: ignore
Instruction.CALL_METHOD = type("Instruction.CALL_METHOD", (Instruction.CALL_METHOD, Instruction,), {})  # type: ignore
Instruction.CALL_ROYALTY_METHOD = type("Instruction.CALL_ROYALTY_METHOD", (Instruction.CALL_ROYALTY_METHOD, Instruction,), {})  # type: ignore
Instruction.CALL_METADATA_METHOD = type("Instruction.CALL_METADATA_METHOD", (Instruction.CALL_METADATA_METHOD, Instruction,), {})  # type: ignore
Instruction.CALL_ROLE_ASSIGNMENT_METHOD = type("Instruction.CALL_ROLE_ASSIGNMENT_METHOD", (Instruction.CALL_ROLE_ASSIGNMENT_METHOD, Instruction,), {})  # type: ignore
Instruction.CALL_DIRECT_VAULT_METHOD = type("Instruction.CALL_DIRECT_VAULT_METHOD", (Instruction.CALL_DIRECT_VAULT_METHOD, Instruction,), {})  # type: ignore
Instruction.ALLOCATE_GLOBAL_ADDRESS = type("Instruction.ALLOCATE_GLOBAL_ADDRESS", (Instruction.ALLOCATE_GLOBAL_ADDRESS, Instruction,), {})  # type: ignore




class _UniffiConverterTypeInstruction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Instruction.TAKE_ALL_FROM_WORKTOP(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 2:
            return Instruction.TAKE_FROM_WORKTOP(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 3:
            return Instruction.TAKE_NON_FUNGIBLES_FROM_WORKTOP(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 4:
            return Instruction.RETURN_TO_WORKTOP(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 5:
            return Instruction.ASSERT_WORKTOP_CONTAINS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 6:
            return Instruction.ASSERT_WORKTOP_CONTAINS_ANY(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 7:
            return Instruction.ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 8:
            return Instruction.POP_FROM_AUTH_ZONE(
            )
        if variant == 9:
            return Instruction.PUSH_TO_AUTH_ZONE(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 10:
            return Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 11:
            return Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 12:
            return Instruction.CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 13:
            return Instruction.DROP_ALL_PROOFS(
            )
        if variant == 14:
            return Instruction.DROP_NAMED_PROOFS(
            )
        if variant == 15:
            return Instruction.DROP_AUTH_ZONE_PROOFS(
            )
        if variant == 16:
            return Instruction.DROP_AUTH_ZONE_REGULAR_PROOFS(
            )
        if variant == 17:
            return Instruction.DROP_AUTH_ZONE_SIGNATURE_PROOFS(
            )
        if variant == 18:
            return Instruction.CREATE_PROOF_FROM_BUCKET_OF_AMOUNT(
                _UniffiConverterTypeManifestBucket.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 19:
            return Instruction.CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES(
                _UniffiConverterTypeManifestBucket.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 20:
            return Instruction.CREATE_PROOF_FROM_BUCKET_OF_ALL(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 21:
            return Instruction.BURN_RESOURCE(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 22:
            return Instruction.CLONE_PROOF(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 23:
            return Instruction.DROP_PROOF(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 24:
            return Instruction.CALL_FUNCTION(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 25:
            return Instruction.CALL_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 26:
            return Instruction.CALL_ROYALTY_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 27:
            return Instruction.CALL_METADATA_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 28:
            return Instruction.CALL_ROLE_ASSIGNMENT_METHOD(
                _UniffiConverterTypeManifestAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 29:
            return Instruction.CALL_DIRECT_VAULT_METHOD(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
                _UniffiConverterTypeManifestValue.read(buf),
            )
        if variant == 30:
            return Instruction.ALLOCATE_GLOBAL_ADDRESS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_take_all_from_worktop():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
        if value.is_take_from_worktop():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_take_non_fungibles_from_worktop():
            buf.write_i32(3)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_return_to_worktop():
            buf.write_i32(4)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
        if value.is_assert_worktop_contains():
            buf.write_i32(5)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_assert_worktop_contains_any():
            buf.write_i32(6)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
        if value.is_assert_worktop_contains_non_fungibles():
            buf.write_i32(7)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_pop_from_auth_zone():
            buf.write_i32(8)
        if value.is_push_to_auth_zone():
            buf.write_i32(9)
            _UniffiConverterTypeManifestProof.write(value.proof_id, buf)
        if value.is_create_proof_from_auth_zone_of_amount():
            buf.write_i32(10)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_create_proof_from_auth_zone_of_non_fungibles():
            buf.write_i32(11)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_create_proof_from_auth_zone_of_all():
            buf.write_i32(12)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
        if value.is_drop_all_proofs():
            buf.write_i32(13)
        if value.is_drop_named_proofs():
            buf.write_i32(14)
        if value.is_drop_auth_zone_proofs():
            buf.write_i32(15)
        if value.is_drop_auth_zone_regular_proofs():
            buf.write_i32(16)
        if value.is_drop_auth_zone_signature_proofs():
            buf.write_i32(17)
        if value.is_create_proof_from_bucket_of_amount():
            buf.write_i32(18)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_create_proof_from_bucket_of_non_fungibles():
            buf.write_i32(19)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)
        if value.is_create_proof_from_bucket_of_all():
            buf.write_i32(20)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
        if value.is_burn_resource():
            buf.write_i32(21)
            _UniffiConverterTypeManifestBucket.write(value.bucket_id, buf)
        if value.is_clone_proof():
            buf.write_i32(22)
            _UniffiConverterTypeManifestProof.write(value.proof_id, buf)
        if value.is_drop_proof():
            buf.write_i32(23)
            _UniffiConverterTypeManifestProof.write(value.proof_id, buf)
        if value.is_call_function():
            buf.write_i32(24)
            _UniffiConverterTypeManifestAddress.write(value.package_address, buf)
            _UniffiConverterString.write(value.blueprint_name, buf)
            _UniffiConverterString.write(value.function_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_method():
            buf.write_i32(25)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_royalty_method():
            buf.write_i32(26)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_metadata_method():
            buf.write_i32(27)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_role_assignment_method():
            buf.write_i32(28)
            _UniffiConverterTypeManifestAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_call_direct_vault_method():
            buf.write_i32(29)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterString.write(value.method_name, buf)
            _UniffiConverterTypeManifestValue.write(value.args, buf)
        if value.is_allocate_global_address():
            buf.write_i32(30)
            _UniffiConverterTypeAddress.write(value.package_address, buf)
            _UniffiConverterString.write(value.blueprint_name, buf)






class LocalTypeIndex:
    def __init__(self):
        raise RuntimeError("LocalTypeIndex cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class WELL_KNOWN:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "LocalTypeIndex.WELL_KNOWN(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_well_known():
                return False
            if self.value != other.value:
                return False
            return True
    class SCHEMA_LOCAL_INDEX:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "LocalTypeIndex.SCHEMA_LOCAL_INDEX(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_schema_local_index():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_well_known(self) -> bool:
        return isinstance(self, LocalTypeIndex.WELL_KNOWN)
    def is_schema_local_index(self) -> bool:
        return isinstance(self, LocalTypeIndex.SCHEMA_LOCAL_INDEX)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LocalTypeIndex.WELL_KNOWN = type("LocalTypeIndex.WELL_KNOWN", (LocalTypeIndex.WELL_KNOWN, LocalTypeIndex,), {})  # type: ignore
LocalTypeIndex.SCHEMA_LOCAL_INDEX = type("LocalTypeIndex.SCHEMA_LOCAL_INDEX", (LocalTypeIndex.SCHEMA_LOCAL_INDEX, LocalTypeIndex,), {})  # type: ignore




class _UniffiConverterTypeLocalTypeIndex(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LocalTypeIndex.WELL_KNOWN(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 2:
            return LocalTypeIndex.SCHEMA_LOCAL_INDEX(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_well_known():
            buf.write_i32(1)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_schema_local_index():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.value, buf)






class ManifestAddress:
    def __init__(self):
        raise RuntimeError("ManifestAddress cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NAMED:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestAddress.NAMED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_named():
                return False
            if self.value != other.value:
                return False
            return True
    class STATIC:
        value: "Address";

        @typing.no_type_check
        def __init__(self,value: "Address"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestAddress.STATIC(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_static():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_named(self) -> bool:
        return isinstance(self, ManifestAddress.NAMED)
    def is_static(self) -> bool:
        return isinstance(self, ManifestAddress.STATIC)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestAddress.NAMED = type("ManifestAddress.NAMED", (ManifestAddress.NAMED, ManifestAddress,), {})  # type: ignore
ManifestAddress.STATIC = type("ManifestAddress.STATIC", (ManifestAddress.STATIC, ManifestAddress,), {})  # type: ignore




class _UniffiConverterTypeManifestAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestAddress.NAMED(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 2:
            return ManifestAddress.STATIC(
                _UniffiConverterTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_named():
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_static():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.value, buf)






class ManifestBuilderAddress:
    def __init__(self):
        raise RuntimeError("ManifestBuilderAddress cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NAMED:
        value: "ManifestBuilderNamedAddress";

        @typing.no_type_check
        def __init__(self,value: "ManifestBuilderNamedAddress"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderAddress.NAMED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_named():
                return False
            if self.value != other.value:
                return False
            return True
    class STATIC:
        value: "Address";

        @typing.no_type_check
        def __init__(self,value: "Address"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderAddress.STATIC(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_static():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_named(self) -> bool:
        return isinstance(self, ManifestBuilderAddress.NAMED)
    def is_static(self) -> bool:
        return isinstance(self, ManifestBuilderAddress.STATIC)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestBuilderAddress.NAMED = type("ManifestBuilderAddress.NAMED", (ManifestBuilderAddress.NAMED, ManifestBuilderAddress,), {})  # type: ignore
ManifestBuilderAddress.STATIC = type("ManifestBuilderAddress.STATIC", (ManifestBuilderAddress.STATIC, ManifestBuilderAddress,), {})  # type: ignore




class _UniffiConverterTypeManifestBuilderAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestBuilderAddress.NAMED(
                _UniffiConverterTypeManifestBuilderNamedAddress.read(buf),
            )
        if variant == 2:
            return ManifestBuilderAddress.STATIC(
                _UniffiConverterTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_named():
            buf.write_i32(1)
            _UniffiConverterTypeManifestBuilderNamedAddress.write(value.value, buf)
        if value.is_static():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.value, buf)






class ManifestBuilderValue:
    def __init__(self):
        raise RuntimeError("ManifestBuilderValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL_VALUE:
        value: "bool";

        @typing.no_type_check
        def __init__(self,value: "bool"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.BOOL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I8_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.I8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i8_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I16_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.I16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i16_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I32_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.I32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I64_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.I64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I128_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.I128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i128_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U8_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.U8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U16_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.U16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u16_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U32_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.U32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U64_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.U64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U128_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.U128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u128_value():
                return False
            if self.value != other.value:
                return False
            return True
    class STRING_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.STRING_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ENUM_VALUE:
        discriminator: "int";fields: "typing.List[ManifestBuilderValue]";

        @typing.no_type_check
        def __init__(self,discriminator: "int", fields: "typing.List[ManifestBuilderValue]"):
            
            self.discriminator = discriminator
            self.fields = fields
            

        def __str__(self):
            return "ManifestBuilderValue.ENUM_VALUE(discriminator={}, fields={})".format(self.discriminator, self.fields)

        def __eq__(self, other):
            if not other.is_enum_value():
                return False
            if self.discriminator != other.discriminator:
                return False
            if self.fields != other.fields:
                return False
            return True
    class ARRAY_VALUE:
        element_value_kind: "ManifestBuilderValueKind";elements: "typing.List[ManifestBuilderValue]";

        @typing.no_type_check
        def __init__(self,element_value_kind: "ManifestBuilderValueKind", elements: "typing.List[ManifestBuilderValue]"):
            
            self.element_value_kind = element_value_kind
            self.elements = elements
            

        def __str__(self):
            return "ManifestBuilderValue.ARRAY_VALUE(element_value_kind={}, elements={})".format(self.element_value_kind, self.elements)

        def __eq__(self, other):
            if not other.is_array_value():
                return False
            if self.element_value_kind != other.element_value_kind:
                return False
            if self.elements != other.elements:
                return False
            return True
    class TUPLE_VALUE:
        fields: "typing.List[ManifestBuilderValue]";

        @typing.no_type_check
        def __init__(self,fields: "typing.List[ManifestBuilderValue]"):
            
            self.fields = fields
            

        def __str__(self):
            return "ManifestBuilderValue.TUPLE_VALUE(fields={})".format(self.fields)

        def __eq__(self, other):
            if not other.is_tuple_value():
                return False
            if self.fields != other.fields:
                return False
            return True
    class MAP_VALUE:
        key_value_kind: "ManifestBuilderValueKind";value_value_kind: "ManifestBuilderValueKind";entries: "typing.List[ManifestBuilderMapEntry]";

        @typing.no_type_check
        def __init__(self,key_value_kind: "ManifestBuilderValueKind", value_value_kind: "ManifestBuilderValueKind", entries: "typing.List[ManifestBuilderMapEntry]"):
            
            self.key_value_kind = key_value_kind
            self.value_value_kind = value_value_kind
            self.entries = entries
            

        def __str__(self):
            return "ManifestBuilderValue.MAP_VALUE(key_value_kind={}, value_value_kind={}, entries={})".format(self.key_value_kind, self.value_value_kind, self.entries)

        def __eq__(self, other):
            if not other.is_map_value():
                return False
            if self.key_value_kind != other.key_value_kind:
                return False
            if self.value_value_kind != other.value_value_kind:
                return False
            if self.entries != other.entries:
                return False
            return True
    class ADDRESS_VALUE:
        value: "ManifestBuilderAddress";

        @typing.no_type_check
        def __init__(self,value: "ManifestBuilderAddress"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.ADDRESS_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_address_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BUCKET_VALUE:
        value: "ManifestBuilderBucket";

        @typing.no_type_check
        def __init__(self,value: "ManifestBuilderBucket"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.BUCKET_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bucket_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PROOF_VALUE:
        value: "ManifestBuilderProof";

        @typing.no_type_check
        def __init__(self,value: "ManifestBuilderProof"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.PROOF_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_proof_value():
                return False
            if self.value != other.value:
                return False
            return True
    class EXPRESSION_VALUE:
        value: "ManifestExpression";

        @typing.no_type_check
        def __init__(self,value: "ManifestExpression"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.EXPRESSION_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_expression_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BLOB_VALUE:
        value: "ManifestBlobRef";

        @typing.no_type_check
        def __init__(self,value: "ManifestBlobRef"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.BLOB_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_blob_value():
                return False
            if self.value != other.value:
                return False
            return True
    class DECIMAL_VALUE:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PRECISE_DECIMAL_VALUE:
        value: "PreciseDecimal";

        @typing.no_type_check
        def __init__(self,value: "PreciseDecimal"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.PRECISE_DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_precise_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_LOCAL_ID_VALUE:
        value: "NonFungibleLocalId";

        @typing.no_type_check
        def __init__(self,value: "NonFungibleLocalId"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ADDRESS_RESERVATION_VALUE:
        value: "ManifestBuilderAddressReservation";

        @typing.no_type_check
        def __init__(self,value: "ManifestBuilderAddressReservation"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestBuilderValue.ADDRESS_RESERVATION_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_address_reservation_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bool_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.BOOL_VALUE)
    def is_i8_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I8_VALUE)
    def is_i16_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I16_VALUE)
    def is_i32_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I32_VALUE)
    def is_i64_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I64_VALUE)
    def is_i128_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.I128_VALUE)
    def is_u8_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U8_VALUE)
    def is_u16_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U16_VALUE)
    def is_u32_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U32_VALUE)
    def is_u64_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U64_VALUE)
    def is_u128_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.U128_VALUE)
    def is_string_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.STRING_VALUE)
    def is_enum_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ENUM_VALUE)
    def is_array_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ARRAY_VALUE)
    def is_tuple_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.TUPLE_VALUE)
    def is_map_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.MAP_VALUE)
    def is_address_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ADDRESS_VALUE)
    def is_bucket_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.BUCKET_VALUE)
    def is_proof_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.PROOF_VALUE)
    def is_expression_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.EXPRESSION_VALUE)
    def is_blob_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.BLOB_VALUE)
    def is_decimal_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.DECIMAL_VALUE)
    def is_precise_decimal_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.PRECISE_DECIMAL_VALUE)
    def is_non_fungible_local_id_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE)
    def is_address_reservation_value(self) -> bool:
        return isinstance(self, ManifestBuilderValue.ADDRESS_RESERVATION_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestBuilderValue.BOOL_VALUE = type("ManifestBuilderValue.BOOL_VALUE", (ManifestBuilderValue.BOOL_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.I8_VALUE = type("ManifestBuilderValue.I8_VALUE", (ManifestBuilderValue.I8_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.I16_VALUE = type("ManifestBuilderValue.I16_VALUE", (ManifestBuilderValue.I16_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.I32_VALUE = type("ManifestBuilderValue.I32_VALUE", (ManifestBuilderValue.I32_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.I64_VALUE = type("ManifestBuilderValue.I64_VALUE", (ManifestBuilderValue.I64_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.I128_VALUE = type("ManifestBuilderValue.I128_VALUE", (ManifestBuilderValue.I128_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.U8_VALUE = type("ManifestBuilderValue.U8_VALUE", (ManifestBuilderValue.U8_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.U16_VALUE = type("ManifestBuilderValue.U16_VALUE", (ManifestBuilderValue.U16_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.U32_VALUE = type("ManifestBuilderValue.U32_VALUE", (ManifestBuilderValue.U32_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.U64_VALUE = type("ManifestBuilderValue.U64_VALUE", (ManifestBuilderValue.U64_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.U128_VALUE = type("ManifestBuilderValue.U128_VALUE", (ManifestBuilderValue.U128_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.STRING_VALUE = type("ManifestBuilderValue.STRING_VALUE", (ManifestBuilderValue.STRING_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.ENUM_VALUE = type("ManifestBuilderValue.ENUM_VALUE", (ManifestBuilderValue.ENUM_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.ARRAY_VALUE = type("ManifestBuilderValue.ARRAY_VALUE", (ManifestBuilderValue.ARRAY_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.TUPLE_VALUE = type("ManifestBuilderValue.TUPLE_VALUE", (ManifestBuilderValue.TUPLE_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.MAP_VALUE = type("ManifestBuilderValue.MAP_VALUE", (ManifestBuilderValue.MAP_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.ADDRESS_VALUE = type("ManifestBuilderValue.ADDRESS_VALUE", (ManifestBuilderValue.ADDRESS_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.BUCKET_VALUE = type("ManifestBuilderValue.BUCKET_VALUE", (ManifestBuilderValue.BUCKET_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.PROOF_VALUE = type("ManifestBuilderValue.PROOF_VALUE", (ManifestBuilderValue.PROOF_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.EXPRESSION_VALUE = type("ManifestBuilderValue.EXPRESSION_VALUE", (ManifestBuilderValue.EXPRESSION_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.BLOB_VALUE = type("ManifestBuilderValue.BLOB_VALUE", (ManifestBuilderValue.BLOB_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.DECIMAL_VALUE = type("ManifestBuilderValue.DECIMAL_VALUE", (ManifestBuilderValue.DECIMAL_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.PRECISE_DECIMAL_VALUE = type("ManifestBuilderValue.PRECISE_DECIMAL_VALUE", (ManifestBuilderValue.PRECISE_DECIMAL_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE = type("ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE", (ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE, ManifestBuilderValue,), {})  # type: ignore
ManifestBuilderValue.ADDRESS_RESERVATION_VALUE = type("ManifestBuilderValue.ADDRESS_RESERVATION_VALUE", (ManifestBuilderValue.ADDRESS_RESERVATION_VALUE, ManifestBuilderValue,), {})  # type: ignore




class _UniffiConverterTypeManifestBuilderValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestBuilderValue.BOOL_VALUE(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return ManifestBuilderValue.I8_VALUE(
                _UniffiConverterInt8.read(buf),
            )
        if variant == 3:
            return ManifestBuilderValue.I16_VALUE(
                _UniffiConverterInt16.read(buf),
            )
        if variant == 4:
            return ManifestBuilderValue.I32_VALUE(
                _UniffiConverterInt32.read(buf),
            )
        if variant == 5:
            return ManifestBuilderValue.I64_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 6:
            return ManifestBuilderValue.I128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ManifestBuilderValue.U8_VALUE(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 8:
            return ManifestBuilderValue.U16_VALUE(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 9:
            return ManifestBuilderValue.U32_VALUE(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return ManifestBuilderValue.U64_VALUE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 11:
            return ManifestBuilderValue.U128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return ManifestBuilderValue.STRING_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return ManifestBuilderValue.ENUM_VALUE(
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterSequenceTypeManifestBuilderValue.read(buf),
            )
        if variant == 14:
            return ManifestBuilderValue.ARRAY_VALUE(
                _UniffiConverterTypeManifestBuilderValueKind.read(buf),
                _UniffiConverterSequenceTypeManifestBuilderValue.read(buf),
            )
        if variant == 15:
            return ManifestBuilderValue.TUPLE_VALUE(
                _UniffiConverterSequenceTypeManifestBuilderValue.read(buf),
            )
        if variant == 16:
            return ManifestBuilderValue.MAP_VALUE(
                _UniffiConverterTypeManifestBuilderValueKind.read(buf),
                _UniffiConverterTypeManifestBuilderValueKind.read(buf),
                _UniffiConverterSequenceTypeManifestBuilderMapEntry.read(buf),
            )
        if variant == 17:
            return ManifestBuilderValue.ADDRESS_VALUE(
                _UniffiConverterTypeManifestBuilderAddress.read(buf),
            )
        if variant == 18:
            return ManifestBuilderValue.BUCKET_VALUE(
                _UniffiConverterTypeManifestBuilderBucket.read(buf),
            )
        if variant == 19:
            return ManifestBuilderValue.PROOF_VALUE(
                _UniffiConverterTypeManifestBuilderProof.read(buf),
            )
        if variant == 20:
            return ManifestBuilderValue.EXPRESSION_VALUE(
                _UniffiConverterTypeManifestExpression.read(buf),
            )
        if variant == 21:
            return ManifestBuilderValue.BLOB_VALUE(
                _UniffiConverterTypeManifestBlobRef.read(buf),
            )
        if variant == 22:
            return ManifestBuilderValue.DECIMAL_VALUE(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 23:
            return ManifestBuilderValue.PRECISE_DECIMAL_VALUE(
                _UniffiConverterTypePreciseDecimal.read(buf),
            )
        if variant == 24:
            return ManifestBuilderValue.NON_FUNGIBLE_LOCAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleLocalId.read(buf),
            )
        if variant == 25:
            return ManifestBuilderValue.ADDRESS_RESERVATION_VALUE(
                _UniffiConverterTypeManifestBuilderAddressReservation.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bool_value():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.value, buf)
        if value.is_i8_value():
            buf.write_i32(2)
            _UniffiConverterInt8.write(value.value, buf)
        if value.is_i16_value():
            buf.write_i32(3)
            _UniffiConverterInt16.write(value.value, buf)
        if value.is_i32_value():
            buf.write_i32(4)
            _UniffiConverterInt32.write(value.value, buf)
        if value.is_i64_value():
            buf.write_i32(5)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_i128_value():
            buf.write_i32(6)
            _UniffiConverterString.write(value.value, buf)
        if value.is_u8_value():
            buf.write_i32(7)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_u16_value():
            buf.write_i32(8)
            _UniffiConverterUInt16.write(value.value, buf)
        if value.is_u32_value():
            buf.write_i32(9)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_u64_value():
            buf.write_i32(10)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_u128_value():
            buf.write_i32(11)
            _UniffiConverterString.write(value.value, buf)
        if value.is_string_value():
            buf.write_i32(12)
            _UniffiConverterString.write(value.value, buf)
        if value.is_enum_value():
            buf.write_i32(13)
            _UniffiConverterUInt8.write(value.discriminator, buf)
            _UniffiConverterSequenceTypeManifestBuilderValue.write(value.fields, buf)
        if value.is_array_value():
            buf.write_i32(14)
            _UniffiConverterTypeManifestBuilderValueKind.write(value.element_value_kind, buf)
            _UniffiConverterSequenceTypeManifestBuilderValue.write(value.elements, buf)
        if value.is_tuple_value():
            buf.write_i32(15)
            _UniffiConverterSequenceTypeManifestBuilderValue.write(value.fields, buf)
        if value.is_map_value():
            buf.write_i32(16)
            _UniffiConverterTypeManifestBuilderValueKind.write(value.key_value_kind, buf)
            _UniffiConverterTypeManifestBuilderValueKind.write(value.value_value_kind, buf)
            _UniffiConverterSequenceTypeManifestBuilderMapEntry.write(value.entries, buf)
        if value.is_address_value():
            buf.write_i32(17)
            _UniffiConverterTypeManifestBuilderAddress.write(value.value, buf)
        if value.is_bucket_value():
            buf.write_i32(18)
            _UniffiConverterTypeManifestBuilderBucket.write(value.value, buf)
        if value.is_proof_value():
            buf.write_i32(19)
            _UniffiConverterTypeManifestBuilderProof.write(value.value, buf)
        if value.is_expression_value():
            buf.write_i32(20)
            _UniffiConverterTypeManifestExpression.write(value.value, buf)
        if value.is_blob_value():
            buf.write_i32(21)
            _UniffiConverterTypeManifestBlobRef.write(value.value, buf)
        if value.is_decimal_value():
            buf.write_i32(22)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_precise_decimal_value():
            buf.write_i32(23)
            _UniffiConverterTypePreciseDecimal.write(value.value, buf)
        if value.is_non_fungible_local_id_value():
            buf.write_i32(24)
            _UniffiConverterTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_address_reservation_value():
            buf.write_i32(25)
            _UniffiConverterTypeManifestBuilderAddressReservation.write(value.value, buf)






class ManifestBuilderValueKind(enum.Enum):
    BOOL_VALUE = 1
    I8_VALUE = 2
    I16_VALUE = 3
    I32_VALUE = 4
    I64_VALUE = 5
    I128_VALUE = 6
    U8_VALUE = 7
    U16_VALUE = 8
    U32_VALUE = 9
    U64_VALUE = 10
    U128_VALUE = 11
    STRING_VALUE = 12
    ENUM_VALUE = 13
    ARRAY_VALUE = 14
    TUPLE_VALUE = 15
    MAP_VALUE = 16
    ADDRESS_VALUE = 17
    BUCKET_VALUE = 18
    PROOF_VALUE = 19
    EXPRESSION_VALUE = 20
    BLOB_VALUE = 21
    DECIMAL_VALUE = 22
    PRECISE_DECIMAL_VALUE = 23
    NON_FUNGIBLE_LOCAL_ID_VALUE = 24
    ADDRESS_RESERVATION_VALUE = 25
    


class _UniffiConverterTypeManifestBuilderValueKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestBuilderValueKind.BOOL_VALUE
        if variant == 2:
            return ManifestBuilderValueKind.I8_VALUE
        if variant == 3:
            return ManifestBuilderValueKind.I16_VALUE
        if variant == 4:
            return ManifestBuilderValueKind.I32_VALUE
        if variant == 5:
            return ManifestBuilderValueKind.I64_VALUE
        if variant == 6:
            return ManifestBuilderValueKind.I128_VALUE
        if variant == 7:
            return ManifestBuilderValueKind.U8_VALUE
        if variant == 8:
            return ManifestBuilderValueKind.U16_VALUE
        if variant == 9:
            return ManifestBuilderValueKind.U32_VALUE
        if variant == 10:
            return ManifestBuilderValueKind.U64_VALUE
        if variant == 11:
            return ManifestBuilderValueKind.U128_VALUE
        if variant == 12:
            return ManifestBuilderValueKind.STRING_VALUE
        if variant == 13:
            return ManifestBuilderValueKind.ENUM_VALUE
        if variant == 14:
            return ManifestBuilderValueKind.ARRAY_VALUE
        if variant == 15:
            return ManifestBuilderValueKind.TUPLE_VALUE
        if variant == 16:
            return ManifestBuilderValueKind.MAP_VALUE
        if variant == 17:
            return ManifestBuilderValueKind.ADDRESS_VALUE
        if variant == 18:
            return ManifestBuilderValueKind.BUCKET_VALUE
        if variant == 19:
            return ManifestBuilderValueKind.PROOF_VALUE
        if variant == 20:
            return ManifestBuilderValueKind.EXPRESSION_VALUE
        if variant == 21:
            return ManifestBuilderValueKind.BLOB_VALUE
        if variant == 22:
            return ManifestBuilderValueKind.DECIMAL_VALUE
        if variant == 23:
            return ManifestBuilderValueKind.PRECISE_DECIMAL_VALUE
        if variant == 24:
            return ManifestBuilderValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE
        if variant == 25:
            return ManifestBuilderValueKind.ADDRESS_RESERVATION_VALUE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestBuilderValueKind.BOOL_VALUE:
            buf.write_i32(1)
        if value == ManifestBuilderValueKind.I8_VALUE:
            buf.write_i32(2)
        if value == ManifestBuilderValueKind.I16_VALUE:
            buf.write_i32(3)
        if value == ManifestBuilderValueKind.I32_VALUE:
            buf.write_i32(4)
        if value == ManifestBuilderValueKind.I64_VALUE:
            buf.write_i32(5)
        if value == ManifestBuilderValueKind.I128_VALUE:
            buf.write_i32(6)
        if value == ManifestBuilderValueKind.U8_VALUE:
            buf.write_i32(7)
        if value == ManifestBuilderValueKind.U16_VALUE:
            buf.write_i32(8)
        if value == ManifestBuilderValueKind.U32_VALUE:
            buf.write_i32(9)
        if value == ManifestBuilderValueKind.U64_VALUE:
            buf.write_i32(10)
        if value == ManifestBuilderValueKind.U128_VALUE:
            buf.write_i32(11)
        if value == ManifestBuilderValueKind.STRING_VALUE:
            buf.write_i32(12)
        if value == ManifestBuilderValueKind.ENUM_VALUE:
            buf.write_i32(13)
        if value == ManifestBuilderValueKind.ARRAY_VALUE:
            buf.write_i32(14)
        if value == ManifestBuilderValueKind.TUPLE_VALUE:
            buf.write_i32(15)
        if value == ManifestBuilderValueKind.MAP_VALUE:
            buf.write_i32(16)
        if value == ManifestBuilderValueKind.ADDRESS_VALUE:
            buf.write_i32(17)
        if value == ManifestBuilderValueKind.BUCKET_VALUE:
            buf.write_i32(18)
        if value == ManifestBuilderValueKind.PROOF_VALUE:
            buf.write_i32(19)
        if value == ManifestBuilderValueKind.EXPRESSION_VALUE:
            buf.write_i32(20)
        if value == ManifestBuilderValueKind.BLOB_VALUE:
            buf.write_i32(21)
        if value == ManifestBuilderValueKind.DECIMAL_VALUE:
            buf.write_i32(22)
        if value == ManifestBuilderValueKind.PRECISE_DECIMAL_VALUE:
            buf.write_i32(23)
        if value == ManifestBuilderValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE:
            buf.write_i32(24)
        if value == ManifestBuilderValueKind.ADDRESS_RESERVATION_VALUE:
            buf.write_i32(25)






class ManifestExpression(enum.Enum):
    ENTIRE_WORKTOP = 1
    ENTIRE_AUTH_ZONE = 2
    


class _UniffiConverterTypeManifestExpression(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestExpression.ENTIRE_WORKTOP
        if variant == 2:
            return ManifestExpression.ENTIRE_AUTH_ZONE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestExpression.ENTIRE_WORKTOP:
            buf.write_i32(1)
        if value == ManifestExpression.ENTIRE_AUTH_ZONE:
            buf.write_i32(2)






class ManifestSborStringRepresentation:
    def __init__(self):
        raise RuntimeError("ManifestSborStringRepresentation cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MANIFEST_STRING:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ManifestSborStringRepresentation.MANIFEST_STRING()".format()

        def __eq__(self, other):
            if not other.is_manifest_string():
                return False
            return True
    class JSON:
        value: "SerializationMode";

        @typing.no_type_check
        def __init__(self,value: "SerializationMode"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestSborStringRepresentation.JSON(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_json():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_manifest_string(self) -> bool:
        return isinstance(self, ManifestSborStringRepresentation.MANIFEST_STRING)
    def is_json(self) -> bool:
        return isinstance(self, ManifestSborStringRepresentation.JSON)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestSborStringRepresentation.MANIFEST_STRING = type("ManifestSborStringRepresentation.MANIFEST_STRING", (ManifestSborStringRepresentation.MANIFEST_STRING, ManifestSborStringRepresentation,), {})  # type: ignore
ManifestSborStringRepresentation.JSON = type("ManifestSborStringRepresentation.JSON", (ManifestSborStringRepresentation.JSON, ManifestSborStringRepresentation,), {})  # type: ignore




class _UniffiConverterTypeManifestSborStringRepresentation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestSborStringRepresentation.MANIFEST_STRING(
            )
        if variant == 2:
            return ManifestSborStringRepresentation.JSON(
                _UniffiConverterTypeSerializationMode.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_manifest_string():
            buf.write_i32(1)
        if value.is_json():
            buf.write_i32(2)
            _UniffiConverterTypeSerializationMode.write(value.value, buf)






class ManifestValue:
    def __init__(self):
        raise RuntimeError("ManifestValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BOOL_VALUE:
        value: "bool";

        @typing.no_type_check
        def __init__(self,value: "bool"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.BOOL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I8_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.I8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i8_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I16_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.I16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i16_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I32_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.I32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I64_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.I64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I128_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.I128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i128_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U8_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.U8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U16_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.U16_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u16_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U32_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.U32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U64_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.U64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U128_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.U128_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u128_value():
                return False
            if self.value != other.value:
                return False
            return True
    class STRING_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.STRING_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ENUM_VALUE:
        discriminator: "int";fields: "typing.List[ManifestValue]";

        @typing.no_type_check
        def __init__(self,discriminator: "int", fields: "typing.List[ManifestValue]"):
            
            self.discriminator = discriminator
            self.fields = fields
            

        def __str__(self):
            return "ManifestValue.ENUM_VALUE(discriminator={}, fields={})".format(self.discriminator, self.fields)

        def __eq__(self, other):
            if not other.is_enum_value():
                return False
            if self.discriminator != other.discriminator:
                return False
            if self.fields != other.fields:
                return False
            return True
    class ARRAY_VALUE:
        element_value_kind: "ManifestValueKind";elements: "typing.List[ManifestValue]";

        @typing.no_type_check
        def __init__(self,element_value_kind: "ManifestValueKind", elements: "typing.List[ManifestValue]"):
            
            self.element_value_kind = element_value_kind
            self.elements = elements
            

        def __str__(self):
            return "ManifestValue.ARRAY_VALUE(element_value_kind={}, elements={})".format(self.element_value_kind, self.elements)

        def __eq__(self, other):
            if not other.is_array_value():
                return False
            if self.element_value_kind != other.element_value_kind:
                return False
            if self.elements != other.elements:
                return False
            return True
    class TUPLE_VALUE:
        fields: "typing.List[ManifestValue]";

        @typing.no_type_check
        def __init__(self,fields: "typing.List[ManifestValue]"):
            
            self.fields = fields
            

        def __str__(self):
            return "ManifestValue.TUPLE_VALUE(fields={})".format(self.fields)

        def __eq__(self, other):
            if not other.is_tuple_value():
                return False
            if self.fields != other.fields:
                return False
            return True
    class MAP_VALUE:
        key_value_kind: "ManifestValueKind";value_value_kind: "ManifestValueKind";entries: "typing.List[MapEntry]";

        @typing.no_type_check
        def __init__(self,key_value_kind: "ManifestValueKind", value_value_kind: "ManifestValueKind", entries: "typing.List[MapEntry]"):
            
            self.key_value_kind = key_value_kind
            self.value_value_kind = value_value_kind
            self.entries = entries
            

        def __str__(self):
            return "ManifestValue.MAP_VALUE(key_value_kind={}, value_value_kind={}, entries={})".format(self.key_value_kind, self.value_value_kind, self.entries)

        def __eq__(self, other):
            if not other.is_map_value():
                return False
            if self.key_value_kind != other.key_value_kind:
                return False
            if self.value_value_kind != other.value_value_kind:
                return False
            if self.entries != other.entries:
                return False
            return True
    class ADDRESS_VALUE:
        value: "ManifestAddress";

        @typing.no_type_check
        def __init__(self,value: "ManifestAddress"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.ADDRESS_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_address_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BUCKET_VALUE:
        value: "ManifestBucket";

        @typing.no_type_check
        def __init__(self,value: "ManifestBucket"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.BUCKET_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bucket_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PROOF_VALUE:
        value: "ManifestProof";

        @typing.no_type_check
        def __init__(self,value: "ManifestProof"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.PROOF_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_proof_value():
                return False
            if self.value != other.value:
                return False
            return True
    class EXPRESSION_VALUE:
        value: "ManifestExpression";

        @typing.no_type_check
        def __init__(self,value: "ManifestExpression"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.EXPRESSION_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_expression_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BLOB_VALUE:
        value: "ManifestBlobRef";

        @typing.no_type_check
        def __init__(self,value: "ManifestBlobRef"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.BLOB_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_blob_value():
                return False
            if self.value != other.value:
                return False
            return True
    class DECIMAL_VALUE:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PRECISE_DECIMAL_VALUE:
        value: "PreciseDecimal";

        @typing.no_type_check
        def __init__(self,value: "PreciseDecimal"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.PRECISE_DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_precise_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_LOCAL_ID_VALUE:
        value: "NonFungibleLocalId";

        @typing.no_type_check
        def __init__(self,value: "NonFungibleLocalId"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ADDRESS_RESERVATION_VALUE:
        value: "ManifestAddressReservation";

        @typing.no_type_check
        def __init__(self,value: "ManifestAddressReservation"):
            
            self.value = value
            

        def __str__(self):
            return "ManifestValue.ADDRESS_RESERVATION_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_address_reservation_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bool_value(self) -> bool:
        return isinstance(self, ManifestValue.BOOL_VALUE)
    def is_i8_value(self) -> bool:
        return isinstance(self, ManifestValue.I8_VALUE)
    def is_i16_value(self) -> bool:
        return isinstance(self, ManifestValue.I16_VALUE)
    def is_i32_value(self) -> bool:
        return isinstance(self, ManifestValue.I32_VALUE)
    def is_i64_value(self) -> bool:
        return isinstance(self, ManifestValue.I64_VALUE)
    def is_i128_value(self) -> bool:
        return isinstance(self, ManifestValue.I128_VALUE)
    def is_u8_value(self) -> bool:
        return isinstance(self, ManifestValue.U8_VALUE)
    def is_u16_value(self) -> bool:
        return isinstance(self, ManifestValue.U16_VALUE)
    def is_u32_value(self) -> bool:
        return isinstance(self, ManifestValue.U32_VALUE)
    def is_u64_value(self) -> bool:
        return isinstance(self, ManifestValue.U64_VALUE)
    def is_u128_value(self) -> bool:
        return isinstance(self, ManifestValue.U128_VALUE)
    def is_string_value(self) -> bool:
        return isinstance(self, ManifestValue.STRING_VALUE)
    def is_enum_value(self) -> bool:
        return isinstance(self, ManifestValue.ENUM_VALUE)
    def is_array_value(self) -> bool:
        return isinstance(self, ManifestValue.ARRAY_VALUE)
    def is_tuple_value(self) -> bool:
        return isinstance(self, ManifestValue.TUPLE_VALUE)
    def is_map_value(self) -> bool:
        return isinstance(self, ManifestValue.MAP_VALUE)
    def is_address_value(self) -> bool:
        return isinstance(self, ManifestValue.ADDRESS_VALUE)
    def is_bucket_value(self) -> bool:
        return isinstance(self, ManifestValue.BUCKET_VALUE)
    def is_proof_value(self) -> bool:
        return isinstance(self, ManifestValue.PROOF_VALUE)
    def is_expression_value(self) -> bool:
        return isinstance(self, ManifestValue.EXPRESSION_VALUE)
    def is_blob_value(self) -> bool:
        return isinstance(self, ManifestValue.BLOB_VALUE)
    def is_decimal_value(self) -> bool:
        return isinstance(self, ManifestValue.DECIMAL_VALUE)
    def is_precise_decimal_value(self) -> bool:
        return isinstance(self, ManifestValue.PRECISE_DECIMAL_VALUE)
    def is_non_fungible_local_id_value(self) -> bool:
        return isinstance(self, ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE)
    def is_address_reservation_value(self) -> bool:
        return isinstance(self, ManifestValue.ADDRESS_RESERVATION_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ManifestValue.BOOL_VALUE = type("ManifestValue.BOOL_VALUE", (ManifestValue.BOOL_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.I8_VALUE = type("ManifestValue.I8_VALUE", (ManifestValue.I8_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.I16_VALUE = type("ManifestValue.I16_VALUE", (ManifestValue.I16_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.I32_VALUE = type("ManifestValue.I32_VALUE", (ManifestValue.I32_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.I64_VALUE = type("ManifestValue.I64_VALUE", (ManifestValue.I64_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.I128_VALUE = type("ManifestValue.I128_VALUE", (ManifestValue.I128_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.U8_VALUE = type("ManifestValue.U8_VALUE", (ManifestValue.U8_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.U16_VALUE = type("ManifestValue.U16_VALUE", (ManifestValue.U16_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.U32_VALUE = type("ManifestValue.U32_VALUE", (ManifestValue.U32_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.U64_VALUE = type("ManifestValue.U64_VALUE", (ManifestValue.U64_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.U128_VALUE = type("ManifestValue.U128_VALUE", (ManifestValue.U128_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.STRING_VALUE = type("ManifestValue.STRING_VALUE", (ManifestValue.STRING_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.ENUM_VALUE = type("ManifestValue.ENUM_VALUE", (ManifestValue.ENUM_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.ARRAY_VALUE = type("ManifestValue.ARRAY_VALUE", (ManifestValue.ARRAY_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.TUPLE_VALUE = type("ManifestValue.TUPLE_VALUE", (ManifestValue.TUPLE_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.MAP_VALUE = type("ManifestValue.MAP_VALUE", (ManifestValue.MAP_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.ADDRESS_VALUE = type("ManifestValue.ADDRESS_VALUE", (ManifestValue.ADDRESS_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.BUCKET_VALUE = type("ManifestValue.BUCKET_VALUE", (ManifestValue.BUCKET_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.PROOF_VALUE = type("ManifestValue.PROOF_VALUE", (ManifestValue.PROOF_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.EXPRESSION_VALUE = type("ManifestValue.EXPRESSION_VALUE", (ManifestValue.EXPRESSION_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.BLOB_VALUE = type("ManifestValue.BLOB_VALUE", (ManifestValue.BLOB_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.DECIMAL_VALUE = type("ManifestValue.DECIMAL_VALUE", (ManifestValue.DECIMAL_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.PRECISE_DECIMAL_VALUE = type("ManifestValue.PRECISE_DECIMAL_VALUE", (ManifestValue.PRECISE_DECIMAL_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE = type("ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE", (ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE, ManifestValue,), {})  # type: ignore
ManifestValue.ADDRESS_RESERVATION_VALUE = type("ManifestValue.ADDRESS_RESERVATION_VALUE", (ManifestValue.ADDRESS_RESERVATION_VALUE, ManifestValue,), {})  # type: ignore




class _UniffiConverterTypeManifestValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestValue.BOOL_VALUE(
                _UniffiConverterBool.read(buf),
            )
        if variant == 2:
            return ManifestValue.I8_VALUE(
                _UniffiConverterInt8.read(buf),
            )
        if variant == 3:
            return ManifestValue.I16_VALUE(
                _UniffiConverterInt16.read(buf),
            )
        if variant == 4:
            return ManifestValue.I32_VALUE(
                _UniffiConverterInt32.read(buf),
            )
        if variant == 5:
            return ManifestValue.I64_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 6:
            return ManifestValue.I128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ManifestValue.U8_VALUE(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 8:
            return ManifestValue.U16_VALUE(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 9:
            return ManifestValue.U32_VALUE(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return ManifestValue.U64_VALUE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 11:
            return ManifestValue.U128_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return ManifestValue.STRING_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return ManifestValue.ENUM_VALUE(
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterSequenceTypeManifestValue.read(buf),
            )
        if variant == 14:
            return ManifestValue.ARRAY_VALUE(
                _UniffiConverterTypeManifestValueKind.read(buf),
                _UniffiConverterSequenceTypeManifestValue.read(buf),
            )
        if variant == 15:
            return ManifestValue.TUPLE_VALUE(
                _UniffiConverterSequenceTypeManifestValue.read(buf),
            )
        if variant == 16:
            return ManifestValue.MAP_VALUE(
                _UniffiConverterTypeManifestValueKind.read(buf),
                _UniffiConverterTypeManifestValueKind.read(buf),
                _UniffiConverterSequenceTypeMapEntry.read(buf),
            )
        if variant == 17:
            return ManifestValue.ADDRESS_VALUE(
                _UniffiConverterTypeManifestAddress.read(buf),
            )
        if variant == 18:
            return ManifestValue.BUCKET_VALUE(
                _UniffiConverterTypeManifestBucket.read(buf),
            )
        if variant == 19:
            return ManifestValue.PROOF_VALUE(
                _UniffiConverterTypeManifestProof.read(buf),
            )
        if variant == 20:
            return ManifestValue.EXPRESSION_VALUE(
                _UniffiConverterTypeManifestExpression.read(buf),
            )
        if variant == 21:
            return ManifestValue.BLOB_VALUE(
                _UniffiConverterTypeManifestBlobRef.read(buf),
            )
        if variant == 22:
            return ManifestValue.DECIMAL_VALUE(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 23:
            return ManifestValue.PRECISE_DECIMAL_VALUE(
                _UniffiConverterTypePreciseDecimal.read(buf),
            )
        if variant == 24:
            return ManifestValue.NON_FUNGIBLE_LOCAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleLocalId.read(buf),
            )
        if variant == 25:
            return ManifestValue.ADDRESS_RESERVATION_VALUE(
                _UniffiConverterTypeManifestAddressReservation.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bool_value():
            buf.write_i32(1)
            _UniffiConverterBool.write(value.value, buf)
        if value.is_i8_value():
            buf.write_i32(2)
            _UniffiConverterInt8.write(value.value, buf)
        if value.is_i16_value():
            buf.write_i32(3)
            _UniffiConverterInt16.write(value.value, buf)
        if value.is_i32_value():
            buf.write_i32(4)
            _UniffiConverterInt32.write(value.value, buf)
        if value.is_i64_value():
            buf.write_i32(5)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_i128_value():
            buf.write_i32(6)
            _UniffiConverterString.write(value.value, buf)
        if value.is_u8_value():
            buf.write_i32(7)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_u16_value():
            buf.write_i32(8)
            _UniffiConverterUInt16.write(value.value, buf)
        if value.is_u32_value():
            buf.write_i32(9)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_u64_value():
            buf.write_i32(10)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_u128_value():
            buf.write_i32(11)
            _UniffiConverterString.write(value.value, buf)
        if value.is_string_value():
            buf.write_i32(12)
            _UniffiConverterString.write(value.value, buf)
        if value.is_enum_value():
            buf.write_i32(13)
            _UniffiConverterUInt8.write(value.discriminator, buf)
            _UniffiConverterSequenceTypeManifestValue.write(value.fields, buf)
        if value.is_array_value():
            buf.write_i32(14)
            _UniffiConverterTypeManifestValueKind.write(value.element_value_kind, buf)
            _UniffiConverterSequenceTypeManifestValue.write(value.elements, buf)
        if value.is_tuple_value():
            buf.write_i32(15)
            _UniffiConverterSequenceTypeManifestValue.write(value.fields, buf)
        if value.is_map_value():
            buf.write_i32(16)
            _UniffiConverterTypeManifestValueKind.write(value.key_value_kind, buf)
            _UniffiConverterTypeManifestValueKind.write(value.value_value_kind, buf)
            _UniffiConverterSequenceTypeMapEntry.write(value.entries, buf)
        if value.is_address_value():
            buf.write_i32(17)
            _UniffiConverterTypeManifestAddress.write(value.value, buf)
        if value.is_bucket_value():
            buf.write_i32(18)
            _UniffiConverterTypeManifestBucket.write(value.value, buf)
        if value.is_proof_value():
            buf.write_i32(19)
            _UniffiConverterTypeManifestProof.write(value.value, buf)
        if value.is_expression_value():
            buf.write_i32(20)
            _UniffiConverterTypeManifestExpression.write(value.value, buf)
        if value.is_blob_value():
            buf.write_i32(21)
            _UniffiConverterTypeManifestBlobRef.write(value.value, buf)
        if value.is_decimal_value():
            buf.write_i32(22)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_precise_decimal_value():
            buf.write_i32(23)
            _UniffiConverterTypePreciseDecimal.write(value.value, buf)
        if value.is_non_fungible_local_id_value():
            buf.write_i32(24)
            _UniffiConverterTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_address_reservation_value():
            buf.write_i32(25)
            _UniffiConverterTypeManifestAddressReservation.write(value.value, buf)






class ManifestValueKind(enum.Enum):
    BOOL_VALUE = 1
    I8_VALUE = 2
    I16_VALUE = 3
    I32_VALUE = 4
    I64_VALUE = 5
    I128_VALUE = 6
    U8_VALUE = 7
    U16_VALUE = 8
    U32_VALUE = 9
    U64_VALUE = 10
    U128_VALUE = 11
    STRING_VALUE = 12
    ENUM_VALUE = 13
    ARRAY_VALUE = 14
    TUPLE_VALUE = 15
    MAP_VALUE = 16
    ADDRESS_VALUE = 17
    BUCKET_VALUE = 18
    PROOF_VALUE = 19
    EXPRESSION_VALUE = 20
    BLOB_VALUE = 21
    DECIMAL_VALUE = 22
    PRECISE_DECIMAL_VALUE = 23
    NON_FUNGIBLE_LOCAL_ID_VALUE = 24
    ADDRESS_RESERVATION_VALUE = 25
    


class _UniffiConverterTypeManifestValueKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ManifestValueKind.BOOL_VALUE
        if variant == 2:
            return ManifestValueKind.I8_VALUE
        if variant == 3:
            return ManifestValueKind.I16_VALUE
        if variant == 4:
            return ManifestValueKind.I32_VALUE
        if variant == 5:
            return ManifestValueKind.I64_VALUE
        if variant == 6:
            return ManifestValueKind.I128_VALUE
        if variant == 7:
            return ManifestValueKind.U8_VALUE
        if variant == 8:
            return ManifestValueKind.U16_VALUE
        if variant == 9:
            return ManifestValueKind.U32_VALUE
        if variant == 10:
            return ManifestValueKind.U64_VALUE
        if variant == 11:
            return ManifestValueKind.U128_VALUE
        if variant == 12:
            return ManifestValueKind.STRING_VALUE
        if variant == 13:
            return ManifestValueKind.ENUM_VALUE
        if variant == 14:
            return ManifestValueKind.ARRAY_VALUE
        if variant == 15:
            return ManifestValueKind.TUPLE_VALUE
        if variant == 16:
            return ManifestValueKind.MAP_VALUE
        if variant == 17:
            return ManifestValueKind.ADDRESS_VALUE
        if variant == 18:
            return ManifestValueKind.BUCKET_VALUE
        if variant == 19:
            return ManifestValueKind.PROOF_VALUE
        if variant == 20:
            return ManifestValueKind.EXPRESSION_VALUE
        if variant == 21:
            return ManifestValueKind.BLOB_VALUE
        if variant == 22:
            return ManifestValueKind.DECIMAL_VALUE
        if variant == 23:
            return ManifestValueKind.PRECISE_DECIMAL_VALUE
        if variant == 24:
            return ManifestValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE
        if variant == 25:
            return ManifestValueKind.ADDRESS_RESERVATION_VALUE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ManifestValueKind.BOOL_VALUE:
            buf.write_i32(1)
        if value == ManifestValueKind.I8_VALUE:
            buf.write_i32(2)
        if value == ManifestValueKind.I16_VALUE:
            buf.write_i32(3)
        if value == ManifestValueKind.I32_VALUE:
            buf.write_i32(4)
        if value == ManifestValueKind.I64_VALUE:
            buf.write_i32(5)
        if value == ManifestValueKind.I128_VALUE:
            buf.write_i32(6)
        if value == ManifestValueKind.U8_VALUE:
            buf.write_i32(7)
        if value == ManifestValueKind.U16_VALUE:
            buf.write_i32(8)
        if value == ManifestValueKind.U32_VALUE:
            buf.write_i32(9)
        if value == ManifestValueKind.U64_VALUE:
            buf.write_i32(10)
        if value == ManifestValueKind.U128_VALUE:
            buf.write_i32(11)
        if value == ManifestValueKind.STRING_VALUE:
            buf.write_i32(12)
        if value == ManifestValueKind.ENUM_VALUE:
            buf.write_i32(13)
        if value == ManifestValueKind.ARRAY_VALUE:
            buf.write_i32(14)
        if value == ManifestValueKind.TUPLE_VALUE:
            buf.write_i32(15)
        if value == ManifestValueKind.MAP_VALUE:
            buf.write_i32(16)
        if value == ManifestValueKind.ADDRESS_VALUE:
            buf.write_i32(17)
        if value == ManifestValueKind.BUCKET_VALUE:
            buf.write_i32(18)
        if value == ManifestValueKind.PROOF_VALUE:
            buf.write_i32(19)
        if value == ManifestValueKind.EXPRESSION_VALUE:
            buf.write_i32(20)
        if value == ManifestValueKind.BLOB_VALUE:
            buf.write_i32(21)
        if value == ManifestValueKind.DECIMAL_VALUE:
            buf.write_i32(22)
        if value == ManifestValueKind.PRECISE_DECIMAL_VALUE:
            buf.write_i32(23)
        if value == ManifestValueKind.NON_FUNGIBLE_LOCAL_ID_VALUE:
            buf.write_i32(24)
        if value == ManifestValueKind.ADDRESS_RESERVATION_VALUE:
            buf.write_i32(25)






class Message:
    def __init__(self):
        raise RuntimeError("Message cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NONE:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Message.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    class PLAIN_TEXT:
        value: "PlainTextMessage";

        @typing.no_type_check
        def __init__(self,value: "PlainTextMessage"):
            
            self.value = value
            

        def __str__(self):
            return "Message.PLAIN_TEXT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_plain_text():
                return False
            if self.value != other.value:
                return False
            return True
    class ENCRYPTED:
        value: "EncryptedMessage";

        @typing.no_type_check
        def __init__(self,value: "EncryptedMessage"):
            
            self.value = value
            

        def __str__(self):
            return "Message.ENCRYPTED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_encrypted():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_none(self) -> bool:
        return isinstance(self, Message.NONE)
    def is_plain_text(self) -> bool:
        return isinstance(self, Message.PLAIN_TEXT)
    def is_encrypted(self) -> bool:
        return isinstance(self, Message.ENCRYPTED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Message.NONE = type("Message.NONE", (Message.NONE, Message,), {})  # type: ignore
Message.PLAIN_TEXT = type("Message.PLAIN_TEXT", (Message.PLAIN_TEXT, Message,), {})  # type: ignore
Message.ENCRYPTED = type("Message.ENCRYPTED", (Message.ENCRYPTED, Message,), {})  # type: ignore




class _UniffiConverterTypeMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Message.NONE(
            )
        if variant == 2:
            return Message.PLAIN_TEXT(
                _UniffiConverterTypePlainTextMessage.read(buf),
            )
        if variant == 3:
            return Message.ENCRYPTED(
                _UniffiConverterTypeEncryptedMessage.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_none():
            buf.write_i32(1)
        if value.is_plain_text():
            buf.write_i32(2)
            _UniffiConverterTypePlainTextMessage.write(value.value, buf)
        if value.is_encrypted():
            buf.write_i32(3)
            _UniffiConverterTypeEncryptedMessage.write(value.value, buf)






class MessageContent:
    def __init__(self):
        raise RuntimeError("MessageContent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class STR:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "MessageContent.STR(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.value != other.value:
                return False
            return True
    class BYTES:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MessageContent.BYTES(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bytes():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_str(self) -> bool:
        return isinstance(self, MessageContent.STR)
    def is_bytes(self) -> bool:
        return isinstance(self, MessageContent.BYTES)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MessageContent.STR = type("MessageContent.STR", (MessageContent.STR, MessageContent,), {})  # type: ignore
MessageContent.BYTES = type("MessageContent.BYTES", (MessageContent.BYTES, MessageContent,), {})  # type: ignore




class _UniffiConverterTypeMessageContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MessageContent.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return MessageContent.BYTES(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_str():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_bytes():
            buf.write_i32(2)
            _UniffiConverterSequenceUInt8.write(value.value, buf)






class MetadataValue:
    def __init__(self):
        raise RuntimeError("MetadataValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class STRING_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.STRING_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BOOL_VALUE:
        value: "bool";

        @typing.no_type_check
        def __init__(self,value: "bool"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.BOOL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U8_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.U8_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U32_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.U32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U64_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.U64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I32_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.I32_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I64_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.I64_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_value():
                return False
            if self.value != other.value:
                return False
            return True
    class DECIMAL_VALUE:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.DECIMAL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_value():
                return False
            if self.value != other.value:
                return False
            return True
    class GLOBAL_ADDRESS_VALUE:
        value: "Address";

        @typing.no_type_check
        def __init__(self,value: "Address"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.GLOBAL_ADDRESS_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_global_address_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PUBLIC_KEY_VALUE:
        value: "PublicKey";

        @typing.no_type_check
        def __init__(self,value: "PublicKey"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_value():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_GLOBAL_ID_VALUE:
        value: "NonFungibleGlobalId";

        @typing.no_type_check
        def __init__(self,value: "NonFungibleGlobalId"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_global_id_value():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_LOCAL_ID_VALUE:
        value: "NonFungibleLocalId";

        @typing.no_type_check
        def __init__(self,value: "NonFungibleLocalId"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_value():
                return False
            if self.value != other.value:
                return False
            return True
    class INSTANT_VALUE:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.INSTANT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_instant_value():
                return False
            if self.value != other.value:
                return False
            return True
    class URL_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.URL_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_url_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ORIGIN_VALUE:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.ORIGIN_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_origin_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PUBLIC_KEY_HASH_VALUE:
        value: "PublicKeyHash";

        @typing.no_type_check
        def __init__(self,value: "PublicKeyHash"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_HASH_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_hash_value():
                return False
            if self.value != other.value:
                return False
            return True
    class STRING_ARRAY_VALUE:
        value: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[str]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.STRING_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_string_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BOOL_ARRAY_VALUE:
        value: "typing.List[bool]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[bool]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.BOOL_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bool_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U8_ARRAY_VALUE:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.U8_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u8_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U32_ARRAY_VALUE:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.U32_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u32_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class U64_ARRAY_VALUE:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.U64_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_u64_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I32_ARRAY_VALUE:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.I32_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i32_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class I64_ARRAY_VALUE:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.I64_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_i64_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class DECIMAL_ARRAY_VALUE:
        value: "typing.List[Decimal]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[Decimal]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.DECIMAL_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_decimal_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class GLOBAL_ADDRESS_ARRAY_VALUE:
        value: "typing.List[Address]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[Address]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_global_address_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PUBLIC_KEY_ARRAY_VALUE:
        value: "typing.List[PublicKey]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[PublicKey]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE:
        value: "typing.List[NonFungibleGlobalId]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[NonFungibleGlobalId]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_global_id_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE:
        value: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[NonFungibleLocalId]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_local_id_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class INSTANT_ARRAY_VALUE:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.INSTANT_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_instant_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class URL_ARRAY_VALUE:
        value: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[str]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.URL_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_url_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ORIGIN_ARRAY_VALUE:
        value: "typing.List[str]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[str]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.ORIGIN_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_origin_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PUBLIC_KEY_HASH_ARRAY_VALUE:
        value: "typing.List[PublicKeyHash]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[PublicKeyHash]"):
            
            self.value = value
            

        def __str__(self):
            return "MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_public_key_hash_array_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_string_value(self) -> bool:
        return isinstance(self, MetadataValue.STRING_VALUE)
    def is_bool_value(self) -> bool:
        return isinstance(self, MetadataValue.BOOL_VALUE)
    def is_u8_value(self) -> bool:
        return isinstance(self, MetadataValue.U8_VALUE)
    def is_u32_value(self) -> bool:
        return isinstance(self, MetadataValue.U32_VALUE)
    def is_u64_value(self) -> bool:
        return isinstance(self, MetadataValue.U64_VALUE)
    def is_i32_value(self) -> bool:
        return isinstance(self, MetadataValue.I32_VALUE)
    def is_i64_value(self) -> bool:
        return isinstance(self, MetadataValue.I64_VALUE)
    def is_decimal_value(self) -> bool:
        return isinstance(self, MetadataValue.DECIMAL_VALUE)
    def is_global_address_value(self) -> bool:
        return isinstance(self, MetadataValue.GLOBAL_ADDRESS_VALUE)
    def is_public_key_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_VALUE)
    def is_non_fungible_global_id_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE)
    def is_non_fungible_local_id_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE)
    def is_instant_value(self) -> bool:
        return isinstance(self, MetadataValue.INSTANT_VALUE)
    def is_url_value(self) -> bool:
        return isinstance(self, MetadataValue.URL_VALUE)
    def is_origin_value(self) -> bool:
        return isinstance(self, MetadataValue.ORIGIN_VALUE)
    def is_public_key_hash_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_HASH_VALUE)
    def is_string_array_value(self) -> bool:
        return isinstance(self, MetadataValue.STRING_ARRAY_VALUE)
    def is_bool_array_value(self) -> bool:
        return isinstance(self, MetadataValue.BOOL_ARRAY_VALUE)
    def is_u8_array_value(self) -> bool:
        return isinstance(self, MetadataValue.U8_ARRAY_VALUE)
    def is_u32_array_value(self) -> bool:
        return isinstance(self, MetadataValue.U32_ARRAY_VALUE)
    def is_u64_array_value(self) -> bool:
        return isinstance(self, MetadataValue.U64_ARRAY_VALUE)
    def is_i32_array_value(self) -> bool:
        return isinstance(self, MetadataValue.I32_ARRAY_VALUE)
    def is_i64_array_value(self) -> bool:
        return isinstance(self, MetadataValue.I64_ARRAY_VALUE)
    def is_decimal_array_value(self) -> bool:
        return isinstance(self, MetadataValue.DECIMAL_ARRAY_VALUE)
    def is_global_address_array_value(self) -> bool:
        return isinstance(self, MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE)
    def is_public_key_array_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_ARRAY_VALUE)
    def is_non_fungible_global_id_array_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE)
    def is_non_fungible_local_id_array_value(self) -> bool:
        return isinstance(self, MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE)
    def is_instant_array_value(self) -> bool:
        return isinstance(self, MetadataValue.INSTANT_ARRAY_VALUE)
    def is_url_array_value(self) -> bool:
        return isinstance(self, MetadataValue.URL_ARRAY_VALUE)
    def is_origin_array_value(self) -> bool:
        return isinstance(self, MetadataValue.ORIGIN_ARRAY_VALUE)
    def is_public_key_hash_array_value(self) -> bool:
        return isinstance(self, MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MetadataValue.STRING_VALUE = type("MetadataValue.STRING_VALUE", (MetadataValue.STRING_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.BOOL_VALUE = type("MetadataValue.BOOL_VALUE", (MetadataValue.BOOL_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.U8_VALUE = type("MetadataValue.U8_VALUE", (MetadataValue.U8_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.U32_VALUE = type("MetadataValue.U32_VALUE", (MetadataValue.U32_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.U64_VALUE = type("MetadataValue.U64_VALUE", (MetadataValue.U64_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.I32_VALUE = type("MetadataValue.I32_VALUE", (MetadataValue.I32_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.I64_VALUE = type("MetadataValue.I64_VALUE", (MetadataValue.I64_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.DECIMAL_VALUE = type("MetadataValue.DECIMAL_VALUE", (MetadataValue.DECIMAL_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.GLOBAL_ADDRESS_VALUE = type("MetadataValue.GLOBAL_ADDRESS_VALUE", (MetadataValue.GLOBAL_ADDRESS_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.PUBLIC_KEY_VALUE = type("MetadataValue.PUBLIC_KEY_VALUE", (MetadataValue.PUBLIC_KEY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE = type("MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE", (MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE = type("MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE", (MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.INSTANT_VALUE = type("MetadataValue.INSTANT_VALUE", (MetadataValue.INSTANT_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.URL_VALUE = type("MetadataValue.URL_VALUE", (MetadataValue.URL_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.ORIGIN_VALUE = type("MetadataValue.ORIGIN_VALUE", (MetadataValue.ORIGIN_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.PUBLIC_KEY_HASH_VALUE = type("MetadataValue.PUBLIC_KEY_HASH_VALUE", (MetadataValue.PUBLIC_KEY_HASH_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.STRING_ARRAY_VALUE = type("MetadataValue.STRING_ARRAY_VALUE", (MetadataValue.STRING_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.BOOL_ARRAY_VALUE = type("MetadataValue.BOOL_ARRAY_VALUE", (MetadataValue.BOOL_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.U8_ARRAY_VALUE = type("MetadataValue.U8_ARRAY_VALUE", (MetadataValue.U8_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.U32_ARRAY_VALUE = type("MetadataValue.U32_ARRAY_VALUE", (MetadataValue.U32_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.U64_ARRAY_VALUE = type("MetadataValue.U64_ARRAY_VALUE", (MetadataValue.U64_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.I32_ARRAY_VALUE = type("MetadataValue.I32_ARRAY_VALUE", (MetadataValue.I32_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.I64_ARRAY_VALUE = type("MetadataValue.I64_ARRAY_VALUE", (MetadataValue.I64_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.DECIMAL_ARRAY_VALUE = type("MetadataValue.DECIMAL_ARRAY_VALUE", (MetadataValue.DECIMAL_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE = type("MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE", (MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.PUBLIC_KEY_ARRAY_VALUE = type("MetadataValue.PUBLIC_KEY_ARRAY_VALUE", (MetadataValue.PUBLIC_KEY_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE = type("MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE", (MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE = type("MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE", (MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.INSTANT_ARRAY_VALUE = type("MetadataValue.INSTANT_ARRAY_VALUE", (MetadataValue.INSTANT_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.URL_ARRAY_VALUE = type("MetadataValue.URL_ARRAY_VALUE", (MetadataValue.URL_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.ORIGIN_ARRAY_VALUE = type("MetadataValue.ORIGIN_ARRAY_VALUE", (MetadataValue.ORIGIN_ARRAY_VALUE, MetadataValue,), {})  # type: ignore
MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE = type("MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE", (MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE, MetadataValue,), {})  # type: ignore




class _UniffiConverterTypeMetadataValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MetadataValue.STRING_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return MetadataValue.BOOL_VALUE(
                _UniffiConverterBool.read(buf),
            )
        if variant == 3:
            return MetadataValue.U8_VALUE(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 4:
            return MetadataValue.U32_VALUE(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 5:
            return MetadataValue.U64_VALUE(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 6:
            return MetadataValue.I32_VALUE(
                _UniffiConverterInt32.read(buf),
            )
        if variant == 7:
            return MetadataValue.I64_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 8:
            return MetadataValue.DECIMAL_VALUE(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 9:
            return MetadataValue.GLOBAL_ADDRESS_VALUE(
                _UniffiConverterTypeAddress.read(buf),
            )
        if variant == 10:
            return MetadataValue.PUBLIC_KEY_VALUE(
                _UniffiConverterTypePublicKey.read(buf),
            )
        if variant == 11:
            return MetadataValue.NON_FUNGIBLE_GLOBAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleGlobalId.read(buf),
            )
        if variant == 12:
            return MetadataValue.NON_FUNGIBLE_LOCAL_ID_VALUE(
                _UniffiConverterTypeNonFungibleLocalId.read(buf),
            )
        if variant == 13:
            return MetadataValue.INSTANT_VALUE(
                _UniffiConverterInt64.read(buf),
            )
        if variant == 14:
            return MetadataValue.URL_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return MetadataValue.ORIGIN_VALUE(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return MetadataValue.PUBLIC_KEY_HASH_VALUE(
                _UniffiConverterTypePublicKeyHash.read(buf),
            )
        if variant == 17:
            return MetadataValue.STRING_ARRAY_VALUE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 18:
            return MetadataValue.BOOL_ARRAY_VALUE(
                _UniffiConverterSequenceBool.read(buf),
            )
        if variant == 19:
            return MetadataValue.U8_ARRAY_VALUE(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 20:
            return MetadataValue.U32_ARRAY_VALUE(
                _UniffiConverterSequenceUInt32.read(buf),
            )
        if variant == 21:
            return MetadataValue.U64_ARRAY_VALUE(
                _UniffiConverterSequenceUInt64.read(buf),
            )
        if variant == 22:
            return MetadataValue.I32_ARRAY_VALUE(
                _UniffiConverterSequenceInt32.read(buf),
            )
        if variant == 23:
            return MetadataValue.I64_ARRAY_VALUE(
                _UniffiConverterSequenceInt64.read(buf),
            )
        if variant == 24:
            return MetadataValue.DECIMAL_ARRAY_VALUE(
                _UniffiConverterSequenceTypeDecimal.read(buf),
            )
        if variant == 25:
            return MetadataValue.GLOBAL_ADDRESS_ARRAY_VALUE(
                _UniffiConverterSequenceTypeAddress.read(buf),
            )
        if variant == 26:
            return MetadataValue.PUBLIC_KEY_ARRAY_VALUE(
                _UniffiConverterSequenceTypePublicKey.read(buf),
            )
        if variant == 27:
            return MetadataValue.NON_FUNGIBLE_GLOBAL_ID_ARRAY_VALUE(
                _UniffiConverterSequenceTypeNonFungibleGlobalId.read(buf),
            )
        if variant == 28:
            return MetadataValue.NON_FUNGIBLE_LOCAL_ID_ARRAY_VALUE(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 29:
            return MetadataValue.INSTANT_ARRAY_VALUE(
                _UniffiConverterSequenceInt64.read(buf),
            )
        if variant == 30:
            return MetadataValue.URL_ARRAY_VALUE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 31:
            return MetadataValue.ORIGIN_ARRAY_VALUE(
                _UniffiConverterSequenceString.read(buf),
            )
        if variant == 32:
            return MetadataValue.PUBLIC_KEY_HASH_ARRAY_VALUE(
                _UniffiConverterSequenceTypePublicKeyHash.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_string_value():
            buf.write_i32(1)
            _UniffiConverterString.write(value.value, buf)
        if value.is_bool_value():
            buf.write_i32(2)
            _UniffiConverterBool.write(value.value, buf)
        if value.is_u8_value():
            buf.write_i32(3)
            _UniffiConverterUInt8.write(value.value, buf)
        if value.is_u32_value():
            buf.write_i32(4)
            _UniffiConverterUInt32.write(value.value, buf)
        if value.is_u64_value():
            buf.write_i32(5)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_i32_value():
            buf.write_i32(6)
            _UniffiConverterInt32.write(value.value, buf)
        if value.is_i64_value():
            buf.write_i32(7)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_decimal_value():
            buf.write_i32(8)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_global_address_value():
            buf.write_i32(9)
            _UniffiConverterTypeAddress.write(value.value, buf)
        if value.is_public_key_value():
            buf.write_i32(10)
            _UniffiConverterTypePublicKey.write(value.value, buf)
        if value.is_non_fungible_global_id_value():
            buf.write_i32(11)
            _UniffiConverterTypeNonFungibleGlobalId.write(value.value, buf)
        if value.is_non_fungible_local_id_value():
            buf.write_i32(12)
            _UniffiConverterTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_instant_value():
            buf.write_i32(13)
            _UniffiConverterInt64.write(value.value, buf)
        if value.is_url_value():
            buf.write_i32(14)
            _UniffiConverterString.write(value.value, buf)
        if value.is_origin_value():
            buf.write_i32(15)
            _UniffiConverterString.write(value.value, buf)
        if value.is_public_key_hash_value():
            buf.write_i32(16)
            _UniffiConverterTypePublicKeyHash.write(value.value, buf)
        if value.is_string_array_value():
            buf.write_i32(17)
            _UniffiConverterSequenceString.write(value.value, buf)
        if value.is_bool_array_value():
            buf.write_i32(18)
            _UniffiConverterSequenceBool.write(value.value, buf)
        if value.is_u8_array_value():
            buf.write_i32(19)
            _UniffiConverterSequenceUInt8.write(value.value, buf)
        if value.is_u32_array_value():
            buf.write_i32(20)
            _UniffiConverterSequenceUInt32.write(value.value, buf)
        if value.is_u64_array_value():
            buf.write_i32(21)
            _UniffiConverterSequenceUInt64.write(value.value, buf)
        if value.is_i32_array_value():
            buf.write_i32(22)
            _UniffiConverterSequenceInt32.write(value.value, buf)
        if value.is_i64_array_value():
            buf.write_i32(23)
            _UniffiConverterSequenceInt64.write(value.value, buf)
        if value.is_decimal_array_value():
            buf.write_i32(24)
            _UniffiConverterSequenceTypeDecimal.write(value.value, buf)
        if value.is_global_address_array_value():
            buf.write_i32(25)
            _UniffiConverterSequenceTypeAddress.write(value.value, buf)
        if value.is_public_key_array_value():
            buf.write_i32(26)
            _UniffiConverterSequenceTypePublicKey.write(value.value, buf)
        if value.is_non_fungible_global_id_array_value():
            buf.write_i32(27)
            _UniffiConverterSequenceTypeNonFungibleGlobalId.write(value.value, buf)
        if value.is_non_fungible_local_id_array_value():
            buf.write_i32(28)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_instant_array_value():
            buf.write_i32(29)
            _UniffiConverterSequenceInt64.write(value.value, buf)
        if value.is_url_array_value():
            buf.write_i32(30)
            _UniffiConverterSequenceString.write(value.value, buf)
        if value.is_origin_array_value():
            buf.write_i32(31)
            _UniffiConverterSequenceString.write(value.value, buf)
        if value.is_public_key_hash_array_value():
            buf.write_i32(32)
            _UniffiConverterSequenceTypePublicKeyHash.write(value.value, buf)






class NameRecordError:
    def __init__(self):
        raise RuntimeError("NameRecordError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OBJECT_NAME_IS_ALREADY_TAKEN:
        object: "str";name: "str";

        @typing.no_type_check
        def __init__(self,object: "str", name: "str"):
            
            self.object = object
            self.name = name
            

        def __str__(self):
            return "NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN(object={}, name={})".format(self.object, self.name)

        def __eq__(self, other):
            if not other.is_object_name_is_already_taken():
                return False
            if self.object != other.object:
                return False
            if self.name != other.name:
                return False
            return True
    class OBJECT_DOES_NOT_EXIST:
        object: "str";name: "str";

        @typing.no_type_check
        def __init__(self,object: "str", name: "str"):
            
            self.object = object
            self.name = name
            

        def __str__(self):
            return "NameRecordError.OBJECT_DOES_NOT_EXIST(object={}, name={})".format(self.object, self.name)

        def __eq__(self, other):
            if not other.is_object_does_not_exist():
                return False
            if self.object != other.object:
                return False
            if self.name != other.name:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_object_name_is_already_taken(self) -> bool:
        return isinstance(self, NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN)
    def is_object_does_not_exist(self) -> bool:
        return isinstance(self, NameRecordError.OBJECT_DOES_NOT_EXIST)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN = type("NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN", (NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN, NameRecordError,), {})  # type: ignore
NameRecordError.OBJECT_DOES_NOT_EXIST = type("NameRecordError.OBJECT_DOES_NOT_EXIST", (NameRecordError.OBJECT_DOES_NOT_EXIST, NameRecordError,), {})  # type: ignore




class _UniffiConverterTypeNameRecordError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NameRecordError.OBJECT_NAME_IS_ALREADY_TAKEN(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return NameRecordError.OBJECT_DOES_NOT_EXIST(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_object_name_is_already_taken():
            buf.write_i32(1)
            _UniffiConverterString.write(value.object, buf)
            _UniffiConverterString.write(value.name, buf)
        if value.is_object_does_not_exist():
            buf.write_i32(2)
            _UniffiConverterString.write(value.object, buf)
            _UniffiConverterString.write(value.name, buf)






class NonFungibleLocalId:
    def __init__(self):
        raise RuntimeError("NonFungibleLocalId cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INTEGER:
        value: "int";

        @typing.no_type_check
        def __init__(self,value: "int"):
            
            self.value = value
            

        def __str__(self):
            return "NonFungibleLocalId.INTEGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_integer():
                return False
            if self.value != other.value:
                return False
            return True
    class STR:
        value: "str";

        @typing.no_type_check
        def __init__(self,value: "str"):
            
            self.value = value
            

        def __str__(self):
            return "NonFungibleLocalId.STR(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.value != other.value:
                return False
            return True
    class BYTES:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "NonFungibleLocalId.BYTES(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_bytes():
                return False
            if self.value != other.value:
                return False
            return True
    class RUID:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "NonFungibleLocalId.RUID(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ruid():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_integer(self) -> bool:
        return isinstance(self, NonFungibleLocalId.INTEGER)
    def is_str(self) -> bool:
        return isinstance(self, NonFungibleLocalId.STR)
    def is_bytes(self) -> bool:
        return isinstance(self, NonFungibleLocalId.BYTES)
    def is_ruid(self) -> bool:
        return isinstance(self, NonFungibleLocalId.RUID)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NonFungibleLocalId.INTEGER = type("NonFungibleLocalId.INTEGER", (NonFungibleLocalId.INTEGER, NonFungibleLocalId,), {})  # type: ignore
NonFungibleLocalId.STR = type("NonFungibleLocalId.STR", (NonFungibleLocalId.STR, NonFungibleLocalId,), {})  # type: ignore
NonFungibleLocalId.BYTES = type("NonFungibleLocalId.BYTES", (NonFungibleLocalId.BYTES, NonFungibleLocalId,), {})  # type: ignore
NonFungibleLocalId.RUID = type("NonFungibleLocalId.RUID", (NonFungibleLocalId.RUID, NonFungibleLocalId,), {})  # type: ignore




class _UniffiConverterTypeNonFungibleLocalId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NonFungibleLocalId.INTEGER(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return NonFungibleLocalId.STR(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return NonFungibleLocalId.BYTES(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 4:
            return NonFungibleLocalId.RUID(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_integer():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.value, buf)
        if value.is_str():
            buf.write_i32(2)
            _UniffiConverterString.write(value.value, buf)
        if value.is_bytes():
            buf.write_i32(3)
            _UniffiConverterSequenceUInt8.write(value.value, buf)
        if value.is_ruid():
            buf.write_i32(4)
            _UniffiConverterSequenceUInt8.write(value.value, buf)






class NonFungibleLocalIdVecSource:
    def __init__(self):
        raise RuntimeError("NonFungibleLocalIdVecSource cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GUARANTEED:
        value: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[NonFungibleLocalId]"):
            
            self.value = value
            

        def __str__(self):
            return "NonFungibleLocalIdVecSource.GUARANTEED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_guaranteed():
                return False
            if self.value != other.value:
                return False
            return True
    class PREDICTED:
        instruction_index: "int";value: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,instruction_index: "int", value: "typing.List[NonFungibleLocalId]"):
            
            self.instruction_index = instruction_index
            self.value = value
            

        def __str__(self):
            return "NonFungibleLocalIdVecSource.PREDICTED(instruction_index={}, value={})".format(self.instruction_index, self.value)

        def __eq__(self, other):
            if not other.is_predicted():
                return False
            if self.instruction_index != other.instruction_index:
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_guaranteed(self) -> bool:
        return isinstance(self, NonFungibleLocalIdVecSource.GUARANTEED)
    def is_predicted(self) -> bool:
        return isinstance(self, NonFungibleLocalIdVecSource.PREDICTED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NonFungibleLocalIdVecSource.GUARANTEED = type("NonFungibleLocalIdVecSource.GUARANTEED", (NonFungibleLocalIdVecSource.GUARANTEED, NonFungibleLocalIdVecSource,), {})  # type: ignore
NonFungibleLocalIdVecSource.PREDICTED = type("NonFungibleLocalIdVecSource.PREDICTED", (NonFungibleLocalIdVecSource.PREDICTED, NonFungibleLocalIdVecSource,), {})  # type: ignore




class _UniffiConverterTypeNonFungibleLocalIdVecSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NonFungibleLocalIdVecSource.GUARANTEED(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        if variant == 2:
            return NonFungibleLocalIdVecSource.PREDICTED(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_guaranteed():
            buf.write_i32(1)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)
        if value.is_predicted():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.instruction_index, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)






class ObjectModuleId(enum.Enum):
    MAIN = 1
    METADATA = 2
    ROYALTY = 3
    ROLE_ASSIGNMENT = 4
    


class _UniffiConverterTypeObjectModuleId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ObjectModuleId.MAIN
        if variant == 2:
            return ObjectModuleId.METADATA
        if variant == 3:
            return ObjectModuleId.ROYALTY
        if variant == 4:
            return ObjectModuleId.ROLE_ASSIGNMENT
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ObjectModuleId.MAIN:
            buf.write_i32(1)
        if value == ObjectModuleId.METADATA:
            buf.write_i32(2)
        if value == ObjectModuleId.ROYALTY:
            buf.write_i32(3)
        if value == ObjectModuleId.ROLE_ASSIGNMENT:
            buf.write_i32(4)






class OlympiaNetwork(enum.Enum):
    MAINNET = 1
    STOKENET = 2
    RELEASENET = 3
    RC_NET = 4
    MILESTONENET = 5
    DEVOPSNET = 6
    SANDPITNET = 7
    LOCALNET = 8
    


class _UniffiConverterTypeOlympiaNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OlympiaNetwork.MAINNET
        if variant == 2:
            return OlympiaNetwork.STOKENET
        if variant == 3:
            return OlympiaNetwork.RELEASENET
        if variant == 4:
            return OlympiaNetwork.RC_NET
        if variant == 5:
            return OlympiaNetwork.MILESTONENET
        if variant == 6:
            return OlympiaNetwork.DEVOPSNET
        if variant == 7:
            return OlympiaNetwork.SANDPITNET
        if variant == 8:
            return OlympiaNetwork.LOCALNET
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == OlympiaNetwork.MAINNET:
            buf.write_i32(1)
        if value == OlympiaNetwork.STOKENET:
            buf.write_i32(2)
        if value == OlympiaNetwork.RELEASENET:
            buf.write_i32(3)
        if value == OlympiaNetwork.RC_NET:
            buf.write_i32(4)
        if value == OlympiaNetwork.MILESTONENET:
            buf.write_i32(5)
        if value == OlympiaNetwork.DEVOPSNET:
            buf.write_i32(6)
        if value == OlympiaNetwork.SANDPITNET:
            buf.write_i32(7)
        if value == OlympiaNetwork.LOCALNET:
            buf.write_i32(8)






class OwnerRole:
    def __init__(self):
        raise RuntimeError("OwnerRole cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NONE:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "OwnerRole.NONE()".format()

        def __eq__(self, other):
            if not other.is_none():
                return False
            return True
    class FIXED:
        value: "AccessRule";

        @typing.no_type_check
        def __init__(self,value: "AccessRule"):
            
            self.value = value
            

        def __str__(self):
            return "OwnerRole.FIXED(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_fixed():
                return False
            if self.value != other.value:
                return False
            return True
    class UPDATABLE:
        value: "AccessRule";

        @typing.no_type_check
        def __init__(self,value: "AccessRule"):
            
            self.value = value
            

        def __str__(self):
            return "OwnerRole.UPDATABLE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_updatable():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_none(self) -> bool:
        return isinstance(self, OwnerRole.NONE)
    def is_fixed(self) -> bool:
        return isinstance(self, OwnerRole.FIXED)
    def is_updatable(self) -> bool:
        return isinstance(self, OwnerRole.UPDATABLE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
OwnerRole.NONE = type("OwnerRole.NONE", (OwnerRole.NONE, OwnerRole,), {})  # type: ignore
OwnerRole.FIXED = type("OwnerRole.FIXED", (OwnerRole.FIXED, OwnerRole,), {})  # type: ignore
OwnerRole.UPDATABLE = type("OwnerRole.UPDATABLE", (OwnerRole.UPDATABLE, OwnerRole,), {})  # type: ignore




class _UniffiConverterTypeOwnerRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OwnerRole.NONE(
            )
        if variant == 2:
            return OwnerRole.FIXED(
                _UniffiConverterTypeAccessRule.read(buf),
            )
        if variant == 3:
            return OwnerRole.UPDATABLE(
                _UniffiConverterTypeAccessRule.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_none():
            buf.write_i32(1)
        if value.is_fixed():
            buf.write_i32(2)
            _UniffiConverterTypeAccessRule.write(value.value, buf)
        if value.is_updatable():
            buf.write_i32(3)
            _UniffiConverterTypeAccessRule.write(value.value, buf)






class Proposer(enum.Enum):
    PRIMARY = 1
    RECOVERY = 2
    


class _UniffiConverterTypeProposer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Proposer.PRIMARY
        if variant == 2:
            return Proposer.RECOVERY
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Proposer.PRIMARY:
            buf.write_i32(1)
        if value == Proposer.RECOVERY:
            buf.write_i32(2)






class PublicKey:
    def __init__(self):
        raise RuntimeError("PublicKey cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "PublicKey.SECP256K1(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.value != other.value:
                return False
            return True
    class ED25519:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "PublicKey.ED25519(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, PublicKey.SECP256K1)
    def is_ed25519(self) -> bool:
        return isinstance(self, PublicKey.ED25519)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PublicKey.SECP256K1 = type("PublicKey.SECP256K1", (PublicKey.SECP256K1, PublicKey,), {})  # type: ignore
PublicKey.ED25519 = type("PublicKey.ED25519", (PublicKey.ED25519, PublicKey,), {})  # type: ignore




class _UniffiConverterTypePublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PublicKey.SECP256K1(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 2:
            return PublicKey.ED25519(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterSequenceUInt8.write(value.value, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterSequenceUInt8.write(value.value, buf)






class PublicKeyHash:
    def __init__(self):
        raise RuntimeError("PublicKeyHash cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "PublicKeyHash.SECP256K1(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.value != other.value:
                return False
            return True
    class ED25519:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "PublicKeyHash.ED25519(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, PublicKeyHash.SECP256K1)
    def is_ed25519(self) -> bool:
        return isinstance(self, PublicKeyHash.ED25519)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PublicKeyHash.SECP256K1 = type("PublicKeyHash.SECP256K1", (PublicKeyHash.SECP256K1, PublicKeyHash,), {})  # type: ignore
PublicKeyHash.ED25519 = type("PublicKeyHash.ED25519", (PublicKeyHash.ED25519, PublicKeyHash,), {})  # type: ignore




class _UniffiConverterTypePublicKeyHash(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PublicKeyHash.SECP256K1(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 2:
            return PublicKeyHash.ED25519(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterSequenceUInt8.write(value.value, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterSequenceUInt8.write(value.value, buf)



# RadixEngineToolkitError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RadixEngineToolkitError(Exception):
    pass

_UniffiTempRadixEngineToolkitError = RadixEngineToolkitError

class RadixEngineToolkitError:  # type: ignore
    class InvalidLength(_UniffiTempRadixEngineToolkitError):
        def __init__(self, expected, actual, data):
            super().__init__(", ".join([
                "expected={!r}".format(expected),
                "actual={!r}".format(actual),
                "data={!r}".format(data),
            ]))
            self.expected = expected
            self.actual = actual
            self.data = data
        def __repr__(self):
            return "RadixEngineToolkitError.InvalidLength({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.InvalidLength = InvalidLength # type: ignore
    class FailedToExtractNetwork(_UniffiTempRadixEngineToolkitError):
        def __init__(self, address):
            super().__init__(", ".join([
                "address={!r}".format(address),
            ]))
            self.address = address
        def __repr__(self):
            return "RadixEngineToolkitError.FailedToExtractNetwork({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.FailedToExtractNetwork = FailedToExtractNetwork # type: ignore
    class Bech32DecodeError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.Bech32DecodeError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.Bech32DecodeError = Bech32DecodeError # type: ignore
    class ParseError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, type_name, error):
            super().__init__(", ".join([
                "type_name={!r}".format(type_name),
                "error={!r}".format(error),
            ]))
            self.type_name = type_name
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.ParseError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.ParseError = ParseError # type: ignore
    class NonFungibleContentValidationError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.NonFungibleContentValidationError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.NonFungibleContentValidationError = NonFungibleContentValidationError # type: ignore
    class EntityTypeMismatchError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, expected, actual):
            super().__init__(", ".join([
                "expected={!r}".format(expected),
                "actual={!r}".format(actual),
            ]))
            self.expected = expected
            self.actual = actual
        def __repr__(self):
            return "RadixEngineToolkitError.EntityTypeMismatchError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.EntityTypeMismatchError = EntityTypeMismatchError # type: ignore
    class DerivationError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.DerivationError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.DerivationError = DerivationError # type: ignore
    class InvalidPublicKey(_UniffiTempRadixEngineToolkitError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RadixEngineToolkitError.InvalidPublicKey({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.InvalidPublicKey = InvalidPublicKey # type: ignore
    class CompileError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.CompileError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.CompileError = CompileError # type: ignore
    class DecompileError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.DecompileError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.DecompileError = DecompileError # type: ignore
    class PrepareError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.PrepareError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.PrepareError = PrepareError # type: ignore
    class EncodeError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.EncodeError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.EncodeError = EncodeError # type: ignore
    class DecodeError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.DecodeError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.DecodeError = DecodeError # type: ignore
    class TransactionValidationFailed(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.TransactionValidationFailed({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.TransactionValidationFailed = TransactionValidationFailed # type: ignore
    class ExecutionModuleError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.ExecutionModuleError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.ExecutionModuleError = ExecutionModuleError # type: ignore
    class ManifestSborError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.ManifestSborError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.ManifestSborError = ManifestSborError # type: ignore
    class ScryptoSborError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.ScryptoSborError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.ScryptoSborError = ScryptoSborError # type: ignore
    class TypedNativeEventError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.TypedNativeEventError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.TypedNativeEventError = TypedNativeEventError # type: ignore
    class FailedToDecodeTransactionHash(_UniffiTempRadixEngineToolkitError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RadixEngineToolkitError.FailedToDecodeTransactionHash({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.FailedToDecodeTransactionHash = FailedToDecodeTransactionHash # type: ignore
    class ManifestBuilderNameRecordError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.ManifestBuilderNameRecordError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.ManifestBuilderNameRecordError = ManifestBuilderNameRecordError # type: ignore
    class ManifestModificationError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.ManifestModificationError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.ManifestModificationError = ManifestModificationError # type: ignore
    class InvalidEntityTypeIdError(_UniffiTempRadixEngineToolkitError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error
        def __repr__(self):
            return "RadixEngineToolkitError.InvalidEntityTypeIdError({})".format(str(self))
    _UniffiTempRadixEngineToolkitError.InvalidEntityTypeIdError = InvalidEntityTypeIdError # type: ignore

RadixEngineToolkitError = _UniffiTempRadixEngineToolkitError # type: ignore
del _UniffiTempRadixEngineToolkitError


class _UniffiConverterTypeRadixEngineToolkitError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RadixEngineToolkitError.InvalidLength(
                expected=_UniffiConverterUInt64.read(buf),
                actual=_UniffiConverterUInt64.read(buf),
                data=_UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 2:
            return RadixEngineToolkitError.FailedToExtractNetwork(
                address=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return RadixEngineToolkitError.Bech32DecodeError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return RadixEngineToolkitError.ParseError(
                type_name=_UniffiConverterString.read(buf),
                error=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return RadixEngineToolkitError.NonFungibleContentValidationError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 6:
            return RadixEngineToolkitError.EntityTypeMismatchError(
                expected=_UniffiConverterSequenceTypeEntityType.read(buf),
                actual=_UniffiConverterTypeEntityType.read(buf),
            )
        if variant == 7:
            return RadixEngineToolkitError.DerivationError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return RadixEngineToolkitError.InvalidPublicKey(
            )
        if variant == 9:
            return RadixEngineToolkitError.CompileError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return RadixEngineToolkitError.DecompileError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 11:
            return RadixEngineToolkitError.PrepareError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 12:
            return RadixEngineToolkitError.EncodeError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 13:
            return RadixEngineToolkitError.DecodeError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 14:
            return RadixEngineToolkitError.TransactionValidationFailed(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 15:
            return RadixEngineToolkitError.ExecutionModuleError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 16:
            return RadixEngineToolkitError.ManifestSborError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 17:
            return RadixEngineToolkitError.ScryptoSborError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 18:
            return RadixEngineToolkitError.TypedNativeEventError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 19:
            return RadixEngineToolkitError.FailedToDecodeTransactionHash(
            )
        if variant == 20:
            return RadixEngineToolkitError.ManifestBuilderNameRecordError(
                error=_UniffiConverterTypeNameRecordError.read(buf),
            )
        if variant == 21:
            return RadixEngineToolkitError.ManifestModificationError(
                error=_UniffiConverterString.read(buf),
            )
        if variant == 22:
            return RadixEngineToolkitError.InvalidEntityTypeIdError(
                error=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, RadixEngineToolkitError.InvalidLength):
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.expected, buf)
            _UniffiConverterUInt64.write(value.actual, buf)
            _UniffiConverterSequenceUInt8.write(value.data, buf)
        if isinstance(value, RadixEngineToolkitError.FailedToExtractNetwork):
            buf.write_i32(2)
            _UniffiConverterString.write(value.address, buf)
        if isinstance(value, RadixEngineToolkitError.Bech32DecodeError):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ParseError):
            buf.write_i32(4)
            _UniffiConverterString.write(value.type_name, buf)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.NonFungibleContentValidationError):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.EntityTypeMismatchError):
            buf.write_i32(6)
            _UniffiConverterSequenceTypeEntityType.write(value.expected, buf)
            _UniffiConverterTypeEntityType.write(value.actual, buf)
        if isinstance(value, RadixEngineToolkitError.DerivationError):
            buf.write_i32(7)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.InvalidPublicKey):
            buf.write_i32(8)
        if isinstance(value, RadixEngineToolkitError.CompileError):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.DecompileError):
            buf.write_i32(10)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.PrepareError):
            buf.write_i32(11)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.EncodeError):
            buf.write_i32(12)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.DecodeError):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.TransactionValidationFailed):
            buf.write_i32(14)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ExecutionModuleError):
            buf.write_i32(15)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ManifestSborError):
            buf.write_i32(16)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ScryptoSborError):
            buf.write_i32(17)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.TypedNativeEventError):
            buf.write_i32(18)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.FailedToDecodeTransactionHash):
            buf.write_i32(19)
        if isinstance(value, RadixEngineToolkitError.ManifestBuilderNameRecordError):
            buf.write_i32(20)
            _UniffiConverterTypeNameRecordError.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.ManifestModificationError):
            buf.write_i32(21)
            _UniffiConverterString.write(value.error, buf)
        if isinstance(value, RadixEngineToolkitError.InvalidEntityTypeIdError):
            buf.write_i32(22)
            _UniffiConverterString.write(value.error, buf)





class RecallResourceEvent:
    def __init__(self):
        raise RuntimeError("RecallResourceEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "RecallResourceEvent.AMOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.value != other.value:
                return False
            return True
    class IDS:
        value: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[NonFungibleLocalId]"):
            
            self.value = value
            

        def __str__(self):
            return "RecallResourceEvent.IDS(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, RecallResourceEvent.AMOUNT)
    def is_ids(self) -> bool:
        return isinstance(self, RecallResourceEvent.IDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RecallResourceEvent.AMOUNT = type("RecallResourceEvent.AMOUNT", (RecallResourceEvent.AMOUNT, RecallResourceEvent,), {})  # type: ignore
RecallResourceEvent.IDS = type("RecallResourceEvent.IDS", (RecallResourceEvent.IDS, RecallResourceEvent,), {})  # type: ignore




class _UniffiConverterTypeRecallResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RecallResourceEvent.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return RecallResourceEvent.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)






class ReservedInstruction(enum.Enum):
    ACCOUNT_LOCK_FEE = 1
    ACCOUNT_SECURIFY = 2
    IDENTITY_SECURIFY = 3
    ACCOUNT_UPDATE_SETTINGS = 4
    ACCESS_CONTROLLER = 5
    


class _UniffiConverterTypeReservedInstruction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ReservedInstruction.ACCOUNT_LOCK_FEE
        if variant == 2:
            return ReservedInstruction.ACCOUNT_SECURIFY
        if variant == 3:
            return ReservedInstruction.IDENTITY_SECURIFY
        if variant == 4:
            return ReservedInstruction.ACCOUNT_UPDATE_SETTINGS
        if variant == 5:
            return ReservedInstruction.ACCESS_CONTROLLER
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ReservedInstruction.ACCOUNT_LOCK_FEE:
            buf.write_i32(1)
        if value == ReservedInstruction.ACCOUNT_SECURIFY:
            buf.write_i32(2)
        if value == ReservedInstruction.IDENTITY_SECURIFY:
            buf.write_i32(3)
        if value == ReservedInstruction.ACCOUNT_UPDATE_SETTINGS:
            buf.write_i32(4)
        if value == ReservedInstruction.ACCESS_CONTROLLER:
            buf.write_i32(5)






class ResourceOrNonFungible:
    def __init__(self):
        raise RuntimeError("ResourceOrNonFungible cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NON_FUNGIBLE:
        value: "NonFungibleGlobalId";

        @typing.no_type_check
        def __init__(self,value: "NonFungibleGlobalId"):
            
            self.value = value
            

        def __str__(self):
            return "ResourceOrNonFungible.NON_FUNGIBLE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.value != other.value:
                return False
            return True
    class RESOURCE:
        value: "Address";

        @typing.no_type_check
        def __init__(self,value: "Address"):
            
            self.value = value
            

        def __str__(self):
            return "ResourceOrNonFungible.RESOURCE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_resource():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_non_fungible(self) -> bool:
        return isinstance(self, ResourceOrNonFungible.NON_FUNGIBLE)
    def is_resource(self) -> bool:
        return isinstance(self, ResourceOrNonFungible.RESOURCE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourceOrNonFungible.NON_FUNGIBLE = type("ResourceOrNonFungible.NON_FUNGIBLE", (ResourceOrNonFungible.NON_FUNGIBLE, ResourceOrNonFungible,), {})  # type: ignore
ResourceOrNonFungible.RESOURCE = type("ResourceOrNonFungible.RESOURCE", (ResourceOrNonFungible.RESOURCE, ResourceOrNonFungible,), {})  # type: ignore




class _UniffiConverterTypeResourceOrNonFungible(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourceOrNonFungible.NON_FUNGIBLE(
                _UniffiConverterTypeNonFungibleGlobalId.read(buf),
            )
        if variant == 2:
            return ResourceOrNonFungible.RESOURCE(
                _UniffiConverterTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_non_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeNonFungibleGlobalId.write(value.value, buf)
        if value.is_resource():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.value, buf)






class ResourcePreference(enum.Enum):
    ALLOWED = 1
    DISALLOWED = 2
    


class _UniffiConverterTypeResourcePreference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourcePreference.ALLOWED
        if variant == 2:
            return ResourcePreference.DISALLOWED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ResourcePreference.ALLOWED:
            buf.write_i32(1)
        if value == ResourcePreference.DISALLOWED:
            buf.write_i32(2)






class ResourcePreferenceAction:
    def __init__(self):
        raise RuntimeError("ResourcePreferenceAction cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SET:
        value: "ResourcePreference";

        @typing.no_type_check
        def __init__(self,value: "ResourcePreference"):
            
            self.value = value
            

        def __str__(self):
            return "ResourcePreferenceAction.SET(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set():
                return False
            if self.value != other.value:
                return False
            return True
    class REMOVE:
        

        @typing.no_type_check
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "ResourcePreferenceAction.REMOVE()".format()

        def __eq__(self, other):
            if not other.is_remove():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_set(self) -> bool:
        return isinstance(self, ResourcePreferenceAction.SET)
    def is_remove(self) -> bool:
        return isinstance(self, ResourcePreferenceAction.REMOVE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourcePreferenceAction.SET = type("ResourcePreferenceAction.SET", (ResourcePreferenceAction.SET, ResourcePreferenceAction,), {})  # type: ignore
ResourcePreferenceAction.REMOVE = type("ResourcePreferenceAction.REMOVE", (ResourcePreferenceAction.REMOVE, ResourcePreferenceAction,), {})  # type: ignore




class _UniffiConverterTypeResourcePreferenceAction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourcePreferenceAction.SET(
                _UniffiConverterTypeResourcePreference.read(buf),
            )
        if variant == 2:
            return ResourcePreferenceAction.REMOVE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_set():
            buf.write_i32(1)
            _UniffiConverterTypeResourcePreference.write(value.value, buf)
        if value.is_remove():
            buf.write_i32(2)






class ResourceSpecifier:
    def __init__(self):
        raise RuntimeError("ResourceSpecifier cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        resource_address: "Address";amount: "Decimal";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "Decimal"):
            
            self.resource_address = resource_address
            self.amount = amount
            

        def __str__(self):
            return "ResourceSpecifier.AMOUNT(resource_address={}, amount={})".format(self.resource_address, self.amount)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class IDS:
        resource_address: "Address";ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", ids: "typing.List[NonFungibleLocalId]"):
            
            self.resource_address = resource_address
            self.ids = ids
            

        def __str__(self):
            return "ResourceSpecifier.IDS(resource_address={}, ids={})".format(self.resource_address, self.ids)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.ids != other.ids:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, ResourceSpecifier.AMOUNT)
    def is_ids(self) -> bool:
        return isinstance(self, ResourceSpecifier.IDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourceSpecifier.AMOUNT = type("ResourceSpecifier.AMOUNT", (ResourceSpecifier.AMOUNT, ResourceSpecifier,), {})  # type: ignore
ResourceSpecifier.IDS = type("ResourceSpecifier.IDS", (ResourceSpecifier.IDS, ResourceSpecifier,), {})  # type: ignore




class _UniffiConverterTypeResourceSpecifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourceSpecifier.AMOUNT(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return ResourceSpecifier.IDS(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)






class ResourceTracker:
    def __init__(self):
        raise RuntimeError("ResourceTracker cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE:
        resource_address: "Address";amount: "DecimalSource";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "DecimalSource"):
            
            self.resource_address = resource_address
            self.amount = amount
            

        def __str__(self):
            return "ResourceTracker.FUNGIBLE(resource_address={}, amount={})".format(self.resource_address, self.amount)

        def __eq__(self, other):
            if not other.is_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class NON_FUNGIBLE:
        resource_address: "Address";amount: "DecimalSource";ids: "NonFungibleLocalIdVecSource";

        @typing.no_type_check
        def __init__(self,resource_address: "Address", amount: "DecimalSource", ids: "NonFungibleLocalIdVecSource"):
            
            self.resource_address = resource_address
            self.amount = amount
            self.ids = ids
            

        def __str__(self):
            return "ResourceTracker.NON_FUNGIBLE(resource_address={}, amount={}, ids={})".format(self.resource_address, self.amount, self.ids)

        def __eq__(self, other):
            if not other.is_non_fungible():
                return False
            if self.resource_address != other.resource_address:
                return False
            if self.amount != other.amount:
                return False
            if self.ids != other.ids:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible(self) -> bool:
        return isinstance(self, ResourceTracker.FUNGIBLE)
    def is_non_fungible(self) -> bool:
        return isinstance(self, ResourceTracker.NON_FUNGIBLE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ResourceTracker.FUNGIBLE = type("ResourceTracker.FUNGIBLE", (ResourceTracker.FUNGIBLE, ResourceTracker,), {})  # type: ignore
ResourceTracker.NON_FUNGIBLE = type("ResourceTracker.NON_FUNGIBLE", (ResourceTracker.NON_FUNGIBLE, ResourceTracker,), {})  # type: ignore




class _UniffiConverterTypeResourceTracker(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ResourceTracker.FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimalSource.read(buf),
            )
        if variant == 2:
            return ResourceTracker.NON_FUNGIBLE(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeDecimalSource.read(buf),
                _UniffiConverterTypeNonFungibleLocalIdVecSource.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimalSource.write(value.amount, buf)
        if value.is_non_fungible():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value.resource_address, buf)
            _UniffiConverterTypeDecimalSource.write(value.amount, buf)
            _UniffiConverterTypeNonFungibleLocalIdVecSource.write(value.ids, buf)






class Resources:
    def __init__(self):
        raise RuntimeError("Resources cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        amount: "Decimal";

        @typing.no_type_check
        def __init__(self,amount: "Decimal"):
            
            self.amount = amount
            

        def __str__(self):
            return "Resources.AMOUNT(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.amount != other.amount:
                return False
            return True
    class IDS:
        ids: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,ids: "typing.List[NonFungibleLocalId]"):
            
            self.ids = ids
            

        def __str__(self):
            return "Resources.IDS(ids={})".format(self.ids)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.ids != other.ids:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, Resources.AMOUNT)
    def is_ids(self) -> bool:
        return isinstance(self, Resources.IDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Resources.AMOUNT = type("Resources.AMOUNT", (Resources.AMOUNT, Resources,), {})  # type: ignore
Resources.IDS = type("Resources.IDS", (Resources.IDS, Resources,), {})  # type: ignore




class _UniffiConverterTypeResources(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Resources.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return Resources.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.amount, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.ids, buf)






class Role(enum.Enum):
    PRIMARY = 1
    RECOVERY = 2
    CONFIRMATION = 3
    


class _UniffiConverterTypeRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Role.PRIMARY
        if variant == 2:
            return Role.RECOVERY
        if variant == 3:
            return Role.CONFIRMATION
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Role.PRIMARY:
            buf.write_i32(1)
        if value == Role.RECOVERY:
            buf.write_i32(2)
        if value == Role.CONFIRMATION:
            buf.write_i32(3)






class RoundingMode(enum.Enum):
    TO_POSITIVE_INFINITY = 1
    TO_NEGATIVE_INFINITY = 2
    TO_ZERO = 3
    AWAY_FROM_ZERO = 4
    TO_NEAREST_MIDPOINT_TOWARD_ZERO = 5
    TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO = 6
    TO_NEAREST_MIDPOINT_TO_EVEN = 7
    


class _UniffiConverterTypeRoundingMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RoundingMode.TO_POSITIVE_INFINITY
        if variant == 2:
            return RoundingMode.TO_NEGATIVE_INFINITY
        if variant == 3:
            return RoundingMode.TO_ZERO
        if variant == 4:
            return RoundingMode.AWAY_FROM_ZERO
        if variant == 5:
            return RoundingMode.TO_NEAREST_MIDPOINT_TOWARD_ZERO
        if variant == 6:
            return RoundingMode.TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO
        if variant == 7:
            return RoundingMode.TO_NEAREST_MIDPOINT_TO_EVEN
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == RoundingMode.TO_POSITIVE_INFINITY:
            buf.write_i32(1)
        if value == RoundingMode.TO_NEGATIVE_INFINITY:
            buf.write_i32(2)
        if value == RoundingMode.TO_ZERO:
            buf.write_i32(3)
        if value == RoundingMode.AWAY_FROM_ZERO:
            buf.write_i32(4)
        if value == RoundingMode.TO_NEAREST_MIDPOINT_TOWARD_ZERO:
            buf.write_i32(5)
        if value == RoundingMode.TO_NEAREST_MIDPOINT_AWAY_FROM_ZERO:
            buf.write_i32(6)
        if value == RoundingMode.TO_NEAREST_MIDPOINT_TO_EVEN:
            buf.write_i32(7)






class SerializationMode(enum.Enum):
    PROGRAMMATIC = 1
    NATURAL = 2
    


class _UniffiConverterTypeSerializationMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SerializationMode.PROGRAMMATIC
        if variant == 2:
            return SerializationMode.NATURAL
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == SerializationMode.PROGRAMMATIC:
            buf.write_i32(1)
        if value == SerializationMode.NATURAL:
            buf.write_i32(2)






class Signature:
    def __init__(self):
        raise RuntimeError("Signature cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "Signature.SECP256K1(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.value != other.value:
                return False
            return True
    class ED25519:
        value: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[int]"):
            
            self.value = value
            

        def __str__(self):
            return "Signature.ED25519(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, Signature.SECP256K1)
    def is_ed25519(self) -> bool:
        return isinstance(self, Signature.ED25519)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Signature.SECP256K1 = type("Signature.SECP256K1", (Signature.SECP256K1, Signature,), {})  # type: ignore
Signature.ED25519 = type("Signature.ED25519", (Signature.ED25519, Signature,), {})  # type: ignore




class _UniffiConverterTypeSignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Signature.SECP256K1(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 2:
            return Signature.ED25519(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterSequenceUInt8.write(value.value, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterSequenceUInt8.write(value.value, buf)






class SignatureWithPublicKey:
    def __init__(self):
        raise RuntimeError("SignatureWithPublicKey cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SECP256K1:
        signature: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,signature: "typing.List[int]"):
            
            self.signature = signature
            

        def __str__(self):
            return "SignatureWithPublicKey.SECP256K1(signature={})".format(self.signature)

        def __eq__(self, other):
            if not other.is_secp256k1():
                return False
            if self.signature != other.signature:
                return False
            return True
    class ED25519:
        signature: "typing.List[int]";public_key: "typing.List[int]";

        @typing.no_type_check
        def __init__(self,signature: "typing.List[int]", public_key: "typing.List[int]"):
            
            self.signature = signature
            self.public_key = public_key
            

        def __str__(self):
            return "SignatureWithPublicKey.ED25519(signature={}, public_key={})".format(self.signature, self.public_key)

        def __eq__(self, other):
            if not other.is_ed25519():
                return False
            if self.signature != other.signature:
                return False
            if self.public_key != other.public_key:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_secp256k1(self) -> bool:
        return isinstance(self, SignatureWithPublicKey.SECP256K1)
    def is_ed25519(self) -> bool:
        return isinstance(self, SignatureWithPublicKey.ED25519)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SignatureWithPublicKey.SECP256K1 = type("SignatureWithPublicKey.SECP256K1", (SignatureWithPublicKey.SECP256K1, SignatureWithPublicKey,), {})  # type: ignore
SignatureWithPublicKey.ED25519 = type("SignatureWithPublicKey.ED25519", (SignatureWithPublicKey.ED25519, SignatureWithPublicKey,), {})  # type: ignore




class _UniffiConverterTypeSignatureWithPublicKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignatureWithPublicKey.SECP256K1(
                _UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 2:
            return SignatureWithPublicKey.ED25519(
                _UniffiConverterSequenceUInt8.read(buf),
                _UniffiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_secp256k1():
            buf.write_i32(1)
            _UniffiConverterSequenceUInt8.write(value.signature, buf)
        if value.is_ed25519():
            buf.write_i32(2)
            _UniffiConverterSequenceUInt8.write(value.signature, buf)
            _UniffiConverterSequenceUInt8.write(value.public_key, buf)






class TransactionType:
    def __init__(self):
        raise RuntimeError("TransactionType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SIMPLE_TRANSFER:
        _from: "Address";to: "Address";transferred: "ResourceSpecifier";

        @typing.no_type_check
        def __init__(self,_from: "Address", to: "Address", transferred: "ResourceSpecifier"):
            
            self._from = _from
            self.to = to
            self.transferred = transferred
            

        def __str__(self):
            return "TransactionType.SIMPLE_TRANSFER(_from={}, to={}, transferred={})".format(self._from, self.to, self.transferred)

        def __eq__(self, other):
            if not other.is_simple_transfer():
                return False
            if self._from != other._from:
                return False
            if self.to != other.to:
                return False
            if self.transferred != other.transferred:
                return False
            return True
    class TRANSFER:
        _from: "Address";transfers: "dict";

        @typing.no_type_check
        def __init__(self,_from: "Address", transfers: "dict"):
            
            self._from = _from
            self.transfers = transfers
            

        def __str__(self):
            return "TransactionType.TRANSFER(_from={}, transfers={})".format(self._from, self.transfers)

        def __eq__(self, other):
            if not other.is_transfer():
                return False
            if self._from != other._from:
                return False
            if self.transfers != other.transfers:
                return False
            return True
    class ACCOUNT_DEPOSIT_SETTINGS:
        resource_preference_changes: "dict";default_deposit_rule_changes: "dict";authorized_depositors_changes: "dict";

        @typing.no_type_check
        def __init__(self,resource_preference_changes: "dict", default_deposit_rule_changes: "dict", authorized_depositors_changes: "dict"):
            
            self.resource_preference_changes = resource_preference_changes
            self.default_deposit_rule_changes = default_deposit_rule_changes
            self.authorized_depositors_changes = authorized_depositors_changes
            

        def __str__(self):
            return "TransactionType.ACCOUNT_DEPOSIT_SETTINGS(resource_preference_changes={}, default_deposit_rule_changes={}, authorized_depositors_changes={})".format(self.resource_preference_changes, self.default_deposit_rule_changes, self.authorized_depositors_changes)

        def __eq__(self, other):
            if not other.is_account_deposit_settings():
                return False
            if self.resource_preference_changes != other.resource_preference_changes:
                return False
            if self.default_deposit_rule_changes != other.default_deposit_rule_changes:
                return False
            if self.authorized_depositors_changes != other.authorized_depositors_changes:
                return False
            return True
    class GENERAL_TRANSACTION:
        account_proofs: "typing.List[Address]";account_withdraws: "dict";account_deposits: "dict";addresses_in_manifest: "dict";metadata_of_newly_created_entities: "dict";data_of_newly_minted_non_fungibles: "dict";addresses_of_newly_created_entities: "typing.List[Address]";

        @typing.no_type_check
        def __init__(self,account_proofs: "typing.List[Address]", account_withdraws: "dict", account_deposits: "dict", addresses_in_manifest: "dict", metadata_of_newly_created_entities: "dict", data_of_newly_minted_non_fungibles: "dict", addresses_of_newly_created_entities: "typing.List[Address]"):
            
            self.account_proofs = account_proofs
            self.account_withdraws = account_withdraws
            self.account_deposits = account_deposits
            self.addresses_in_manifest = addresses_in_manifest
            self.metadata_of_newly_created_entities = metadata_of_newly_created_entities
            self.data_of_newly_minted_non_fungibles = data_of_newly_minted_non_fungibles
            self.addresses_of_newly_created_entities = addresses_of_newly_created_entities
            

        def __str__(self):
            return "TransactionType.GENERAL_TRANSACTION(account_proofs={}, account_withdraws={}, account_deposits={}, addresses_in_manifest={}, metadata_of_newly_created_entities={}, data_of_newly_minted_non_fungibles={}, addresses_of_newly_created_entities={})".format(self.account_proofs, self.account_withdraws, self.account_deposits, self.addresses_in_manifest, self.metadata_of_newly_created_entities, self.data_of_newly_minted_non_fungibles, self.addresses_of_newly_created_entities)

        def __eq__(self, other):
            if not other.is_general_transaction():
                return False
            if self.account_proofs != other.account_proofs:
                return False
            if self.account_withdraws != other.account_withdraws:
                return False
            if self.account_deposits != other.account_deposits:
                return False
            if self.addresses_in_manifest != other.addresses_in_manifest:
                return False
            if self.metadata_of_newly_created_entities != other.metadata_of_newly_created_entities:
                return False
            if self.data_of_newly_minted_non_fungibles != other.data_of_newly_minted_non_fungibles:
                return False
            if self.addresses_of_newly_created_entities != other.addresses_of_newly_created_entities:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_simple_transfer(self) -> bool:
        return isinstance(self, TransactionType.SIMPLE_TRANSFER)
    def is_transfer(self) -> bool:
        return isinstance(self, TransactionType.TRANSFER)
    def is_account_deposit_settings(self) -> bool:
        return isinstance(self, TransactionType.ACCOUNT_DEPOSIT_SETTINGS)
    def is_general_transaction(self) -> bool:
        return isinstance(self, TransactionType.GENERAL_TRANSACTION)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TransactionType.SIMPLE_TRANSFER = type("TransactionType.SIMPLE_TRANSFER", (TransactionType.SIMPLE_TRANSFER, TransactionType,), {})  # type: ignore
TransactionType.TRANSFER = type("TransactionType.TRANSFER", (TransactionType.TRANSFER, TransactionType,), {})  # type: ignore
TransactionType.ACCOUNT_DEPOSIT_SETTINGS = type("TransactionType.ACCOUNT_DEPOSIT_SETTINGS", (TransactionType.ACCOUNT_DEPOSIT_SETTINGS, TransactionType,), {})  # type: ignore
TransactionType.GENERAL_TRANSACTION = type("TransactionType.GENERAL_TRANSACTION", (TransactionType.GENERAL_TRANSACTION, TransactionType,), {})  # type: ignore




class _UniffiConverterTypeTransactionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionType.SIMPLE_TRANSFER(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterTypeResourceSpecifier.read(buf),
            )
        if variant == 2:
            return TransactionType.TRANSFER(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterMapStringMapStringTypeResources.read(buf),
            )
        if variant == 3:
            return TransactionType.ACCOUNT_DEPOSIT_SETTINGS(
                _UniffiConverterMapStringMapStringTypeResourcePreferenceAction.read(buf),
                _UniffiConverterMapStringTypeAccountDefaultDepositRule.read(buf),
                _UniffiConverterMapStringTypeAuthorizedDepositorsChanges.read(buf),
            )
        if variant == 4:
            return TransactionType.GENERAL_TRANSACTION(
                _UniffiConverterSequenceTypeAddress.read(buf),
                _UniffiConverterMapStringSequenceTypeResourceTracker.read(buf),
                _UniffiConverterMapStringSequenceTypeResourceTracker.read(buf),
                _UniffiConverterMapTypeEntityTypeSequenceTypeAddress.read(buf),
                _UniffiConverterMapStringMapStringOptionalTypeMetadataValue.read(buf),
                _UniffiConverterMapStringMapTypeNonFungibleLocalIdSequenceUInt8.read(buf),
                _UniffiConverterSequenceTypeAddress.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_simple_transfer():
            buf.write_i32(1)
            _UniffiConverterTypeAddress.write(value._from, buf)
            _UniffiConverterTypeAddress.write(value.to, buf)
            _UniffiConverterTypeResourceSpecifier.write(value.transferred, buf)
        if value.is_transfer():
            buf.write_i32(2)
            _UniffiConverterTypeAddress.write(value._from, buf)
            _UniffiConverterMapStringMapStringTypeResources.write(value.transfers, buf)
        if value.is_account_deposit_settings():
            buf.write_i32(3)
            _UniffiConverterMapStringMapStringTypeResourcePreferenceAction.write(value.resource_preference_changes, buf)
            _UniffiConverterMapStringTypeAccountDefaultDepositRule.write(value.default_deposit_rule_changes, buf)
            _UniffiConverterMapStringTypeAuthorizedDepositorsChanges.write(value.authorized_depositors_changes, buf)
        if value.is_general_transaction():
            buf.write_i32(4)
            _UniffiConverterSequenceTypeAddress.write(value.account_proofs, buf)
            _UniffiConverterMapStringSequenceTypeResourceTracker.write(value.account_withdraws, buf)
            _UniffiConverterMapStringSequenceTypeResourceTracker.write(value.account_deposits, buf)
            _UniffiConverterMapTypeEntityTypeSequenceTypeAddress.write(value.addresses_in_manifest, buf)
            _UniffiConverterMapStringMapStringOptionalTypeMetadataValue.write(value.metadata_of_newly_created_entities, buf)
            _UniffiConverterMapStringMapTypeNonFungibleLocalIdSequenceUInt8.write(value.data_of_newly_minted_non_fungibles, buf)
            _UniffiConverterSequenceTypeAddress.write(value.addresses_of_newly_created_entities, buf)






class TypedAccessControllerBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedAccessControllerBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INITIATE_RECOVERY_EVENT_VALUE:
        value: "InitiateRecoveryEvent";

        @typing.no_type_check
        def __init__(self,value: "InitiateRecoveryEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_initiate_recovery_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE:
        value: "InitiateBadgeWithdrawAttemptEvent";

        @typing.no_type_check
        def __init__(self,value: "InitiateBadgeWithdrawAttemptEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_initiate_badge_withdraw_attempt_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class RULE_SET_UPDATE_EVENT_VALUE:
        value: "RuleSetUpdateEvent";

        @typing.no_type_check
        def __init__(self,value: "RuleSetUpdateEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_rule_set_update_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BADGE_WITHDRAW_EVENT_VALUE:
        value: "BadgeWithdrawEvent";

        @typing.no_type_check
        def __init__(self,value: "BadgeWithdrawEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_badge_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE:
        value: "CancelRecoveryProposalEvent";

        @typing.no_type_check
        def __init__(self,value: "CancelRecoveryProposalEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_cancel_recovery_proposal_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE:
        value: "CancelBadgeWithdrawAttemptEvent";

        @typing.no_type_check
        def __init__(self,value: "CancelBadgeWithdrawAttemptEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_cancel_badge_withdraw_attempt_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class LOCK_PRIMARY_ROLE_EVENT_VALUE:
        value: "LockPrimaryRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "LockPrimaryRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_lock_primary_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class UNLOCK_PRIMARY_ROLE_EVENT_VALUE:
        value: "UnlockPrimaryRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "UnlockPrimaryRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_unlock_primary_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class STOP_TIMED_RECOVERY_EVENT_VALUE:
        value: "StopTimedRecoveryEvent";

        @typing.no_type_check
        def __init__(self,value: "StopTimedRecoveryEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_stop_timed_recovery_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_initiate_recovery_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE)
    def is_initiate_badge_withdraw_attempt_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE)
    def is_rule_set_update_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE)
    def is_badge_withdraw_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE)
    def is_cancel_recovery_proposal_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE)
    def is_cancel_badge_withdraw_attempt_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE)
    def is_lock_primary_role_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE)
    def is_unlock_primary_role_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE)
    def is_stop_timed_recovery_event_value(self) -> bool:
        return isinstance(self, TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore
TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE = type("TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE", (TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE, TypedAccessControllerBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedAccessControllerBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccessControllerBlueprintEvent.INITIATE_RECOVERY_EVENT_VALUE(
                _UniffiConverterTypeInitiateRecoveryEvent.read(buf),
            )
        if variant == 2:
            return TypedAccessControllerBlueprintEvent.INITIATE_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(
                _UniffiConverterTypeInitiateBadgeWithdrawAttemptEvent.read(buf),
            )
        if variant == 3:
            return TypedAccessControllerBlueprintEvent.RULE_SET_UPDATE_EVENT_VALUE(
                _UniffiConverterTypeRuleSetUpdateEvent.read(buf),
            )
        if variant == 4:
            return TypedAccessControllerBlueprintEvent.BADGE_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeBadgeWithdrawEvent.read(buf),
            )
        if variant == 5:
            return TypedAccessControllerBlueprintEvent.CANCEL_RECOVERY_PROPOSAL_EVENT_VALUE(
                _UniffiConverterTypeCancelRecoveryProposalEvent.read(buf),
            )
        if variant == 6:
            return TypedAccessControllerBlueprintEvent.CANCEL_BADGE_WITHDRAW_ATTEMPT_EVENT_VALUE(
                _UniffiConverterTypeCancelBadgeWithdrawAttemptEvent.read(buf),
            )
        if variant == 7:
            return TypedAccessControllerBlueprintEvent.LOCK_PRIMARY_ROLE_EVENT_VALUE(
                _UniffiConverterTypeLockPrimaryRoleEvent.read(buf),
            )
        if variant == 8:
            return TypedAccessControllerBlueprintEvent.UNLOCK_PRIMARY_ROLE_EVENT_VALUE(
                _UniffiConverterTypeUnlockPrimaryRoleEvent.read(buf),
            )
        if variant == 9:
            return TypedAccessControllerBlueprintEvent.STOP_TIMED_RECOVERY_EVENT_VALUE(
                _UniffiConverterTypeStopTimedRecoveryEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_initiate_recovery_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeInitiateRecoveryEvent.write(value.value, buf)
        if value.is_initiate_badge_withdraw_attempt_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeInitiateBadgeWithdrawAttemptEvent.write(value.value, buf)
        if value.is_rule_set_update_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeRuleSetUpdateEvent.write(value.value, buf)
        if value.is_badge_withdraw_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeBadgeWithdrawEvent.write(value.value, buf)
        if value.is_cancel_recovery_proposal_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeCancelRecoveryProposalEvent.write(value.value, buf)
        if value.is_cancel_badge_withdraw_attempt_event_value():
            buf.write_i32(6)
            _UniffiConverterTypeCancelBadgeWithdrawAttemptEvent.write(value.value, buf)
        if value.is_lock_primary_role_event_value():
            buf.write_i32(7)
            _UniffiConverterTypeLockPrimaryRoleEvent.write(value.value, buf)
        if value.is_unlock_primary_role_event_value():
            buf.write_i32(8)
            _UniffiConverterTypeUnlockPrimaryRoleEvent.write(value.value, buf)
        if value.is_stop_timed_recovery_event_value():
            buf.write_i32(9)
            _UniffiConverterTypeStopTimedRecoveryEvent.write(value.value, buf)






class TypedAccessControllerPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedAccessControllerPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCESS_CONTROLLER:
        value: "TypedAccessControllerBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedAccessControllerBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedAccessControllerPackageEvent.ACCESS_CONTROLLER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_access_controller():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_access_controller(self) -> bool:
        return isinstance(self, TypedAccessControllerPackageEvent.ACCESS_CONTROLLER)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedAccessControllerPackageEvent.ACCESS_CONTROLLER = type("TypedAccessControllerPackageEvent.ACCESS_CONTROLLER", (TypedAccessControllerPackageEvent.ACCESS_CONTROLLER, TypedAccessControllerPackageEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedAccessControllerPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedAccessControllerPackageEvent.ACCESS_CONTROLLER(
                _UniffiConverterTypeTypedAccessControllerBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_access_controller():
            buf.write_i32(1)
            _UniffiConverterTypeTypedAccessControllerBlueprintEvent.write(value.value, buf)






class TypedConsensusManagerBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedConsensusManagerBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ROUND_CHANGE_EVENT_VALUE:
        value: "RoundChangeEvent";

        @typing.no_type_check
        def __init__(self,value: "RoundChangeEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_round_change_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class EPOCH_CHANGE_EVENT_VALUE:
        value: "EpochChangeEvent";

        @typing.no_type_check
        def __init__(self,value: "EpochChangeEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_epoch_change_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_round_change_event_value(self) -> bool:
        return isinstance(self, TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE)
    def is_epoch_change_event_value(self) -> bool:
        return isinstance(self, TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE = type("TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE", (TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE, TypedConsensusManagerBlueprintEvent,), {})  # type: ignore
TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE = type("TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE", (TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE, TypedConsensusManagerBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedConsensusManagerBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedConsensusManagerBlueprintEvent.ROUND_CHANGE_EVENT_VALUE(
                _UniffiConverterTypeRoundChangeEvent.read(buf),
            )
        if variant == 2:
            return TypedConsensusManagerBlueprintEvent.EPOCH_CHANGE_EVENT_VALUE(
                _UniffiConverterTypeEpochChangeEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_round_change_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeRoundChangeEvent.write(value.value, buf)
        if value.is_epoch_change_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeEpochChangeEvent.write(value.value, buf)






class TypedConsensusManagerPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedConsensusManagerPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONSENSUS_MANAGER:
        value: "TypedConsensusManagerBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedConsensusManagerBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_consensus_manager():
                return False
            if self.value != other.value:
                return False
            return True
    class VALIDATOR:
        value: "TypedValidatorBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedValidatorBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedConsensusManagerPackageEvent.VALIDATOR(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_validator():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_consensus_manager(self) -> bool:
        return isinstance(self, TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER)
    def is_validator(self) -> bool:
        return isinstance(self, TypedConsensusManagerPackageEvent.VALIDATOR)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER = type("TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER", (TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER, TypedConsensusManagerPackageEvent,), {})  # type: ignore
TypedConsensusManagerPackageEvent.VALIDATOR = type("TypedConsensusManagerPackageEvent.VALIDATOR", (TypedConsensusManagerPackageEvent.VALIDATOR, TypedConsensusManagerPackageEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedConsensusManagerPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedConsensusManagerPackageEvent.CONSENSUS_MANAGER(
                _UniffiConverterTypeTypedConsensusManagerBlueprintEvent.read(buf),
            )
        if variant == 2:
            return TypedConsensusManagerPackageEvent.VALIDATOR(
                _UniffiConverterTypeTypedValidatorBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_consensus_manager():
            buf.write_i32(1)
            _UniffiConverterTypeTypedConsensusManagerBlueprintEvent.write(value.value, buf)
        if value.is_validator():
            buf.write_i32(2)
            _UniffiConverterTypeTypedValidatorBlueprintEvent.write(value.value, buf)






class TypedFungibleResourceManagerBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedFungibleResourceManagerBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class VAULT_CREATION_EVENT_VALUE:
        value: "VaultCreationEvent";

        @typing.no_type_check
        def __init__(self,value: "VaultCreationEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_vault_creation_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class MINT_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "MintFungibleResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "MintFungibleResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_mint_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BURN_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "BurnFungibleResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "BurnFungibleResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_burn_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_vault_creation_event_value(self) -> bool:
        return isinstance(self, TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE)
    def is_mint_fungible_resource_event_value(self) -> bool:
        return isinstance(self, TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE)
    def is_burn_fungible_resource_event_value(self) -> bool:
        return isinstance(self, TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE = type("TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE", (TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE, TypedFungibleResourceManagerBlueprintEvent,), {})  # type: ignore
TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE = type("TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE", (TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE, TypedFungibleResourceManagerBlueprintEvent,), {})  # type: ignore
TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE = type("TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE", (TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE, TypedFungibleResourceManagerBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedFungibleResourceManagerBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(
                _UniffiConverterTypeVaultCreationEvent.read(buf),
            )
        if variant == 2:
            return TypedFungibleResourceManagerBlueprintEvent.MINT_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeMintFungibleResourceEvent.read(buf),
            )
        if variant == 3:
            return TypedFungibleResourceManagerBlueprintEvent.BURN_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeBurnFungibleResourceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_vault_creation_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeVaultCreationEvent.write(value.value, buf)
        if value.is_mint_fungible_resource_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeMintFungibleResourceEvent.write(value.value, buf)
        if value.is_burn_fungible_resource_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeBurnFungibleResourceEvent.write(value.value, buf)






class TypedFungibleVaultBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedFungibleVaultBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class LOCK_FEE_EVENT_VALUE:
        value: "LockFeeEvent";

        @typing.no_type_check
        def __init__(self,value: "LockFeeEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_lock_fee_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class WITHDRAW_RESOURCE_EVENT_VALUE:
        value: "WithdrawResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "WithdrawResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_withdraw_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class DEPOSIT_RESOURCE_EVENT_VALUE:
        value: "DepositResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "DepositResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_deposit_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class RECALL_RESOURCE_EVENT_VALUE:
        value: "RecallResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "RecallResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_recall_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_lock_fee_event_value(self) -> bool:
        return isinstance(self, TypedFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE)
    def is_withdraw_resource_event_value(self) -> bool:
        return isinstance(self, TypedFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE)
    def is_deposit_resource_event_value(self) -> bool:
        return isinstance(self, TypedFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE)
    def is_recall_resource_event_value(self) -> bool:
        return isinstance(self, TypedFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE = type("TypedFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE", (TypedFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE, TypedFungibleVaultBlueprintEvent,), {})  # type: ignore
TypedFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE = type("TypedFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE", (TypedFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE, TypedFungibleVaultBlueprintEvent,), {})  # type: ignore
TypedFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE = type("TypedFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE", (TypedFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE, TypedFungibleVaultBlueprintEvent,), {})  # type: ignore
TypedFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE = type("TypedFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE", (TypedFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE, TypedFungibleVaultBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedFungibleVaultBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE(
                _UniffiConverterTypeLockFeeEvent.read(buf),
            )
        if variant == 2:
            return TypedFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeWithdrawResourceEvent.read(buf),
            )
        if variant == 3:
            return TypedFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeDepositResourceEvent.read(buf),
            )
        if variant == 4:
            return TypedFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeRecallResourceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_lock_fee_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeLockFeeEvent.write(value.value, buf)
        if value.is_withdraw_resource_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeWithdrawResourceEvent.write(value.value, buf)
        if value.is_deposit_resource_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeDepositResourceEvent.write(value.value, buf)
        if value.is_recall_resource_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeRecallResourceEvent.write(value.value, buf)






class TypedMetadataBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedMetadataBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SET_METADATA_EVENT_VALUE:
        value: "SetMetadataEvent";

        @typing.no_type_check
        def __init__(self,value: "SetMetadataEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set_metadata_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class REMOVE_METADATA_EVENT_VALUE:
        value: "RemoveMetadataEvent";

        @typing.no_type_check
        def __init__(self,value: "RemoveMetadataEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_remove_metadata_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_set_metadata_event_value(self) -> bool:
        return isinstance(self, TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE)
    def is_remove_metadata_event_value(self) -> bool:
        return isinstance(self, TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE = type("TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE", (TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE, TypedMetadataBlueprintEvent,), {})  # type: ignore
TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE = type("TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE", (TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE, TypedMetadataBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedMetadataBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedMetadataBlueprintEvent.SET_METADATA_EVENT_VALUE(
                _UniffiConverterTypeSetMetadataEvent.read(buf),
            )
        if variant == 2:
            return TypedMetadataBlueprintEvent.REMOVE_METADATA_EVENT_VALUE(
                _UniffiConverterTypeRemoveMetadataEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_set_metadata_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeSetMetadataEvent.write(value.value, buf)
        if value.is_remove_metadata_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeRemoveMetadataEvent.write(value.value, buf)






class TypedMetadataPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedMetadataPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class METADATA:
        value: "TypedMetadataBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedMetadataBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMetadataPackageEvent.METADATA(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_metadata():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_metadata(self) -> bool:
        return isinstance(self, TypedMetadataPackageEvent.METADATA)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedMetadataPackageEvent.METADATA = type("TypedMetadataPackageEvent.METADATA", (TypedMetadataPackageEvent.METADATA, TypedMetadataPackageEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedMetadataPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedMetadataPackageEvent.METADATA(
                _UniffiConverterTypeTypedMetadataBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_metadata():
            buf.write_i32(1)
            _UniffiConverterTypeTypedMetadataBlueprintEvent.write(value.value, buf)






class TypedMultiResourcePoolBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedMultiResourcePoolBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE:
        value: "MultiResourcePoolContributionEvent";

        @typing.no_type_check
        def __init__(self,value: "MultiResourcePoolContributionEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_multi_resource_pool_contribution_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE:
        value: "MultiResourcePoolRedemptionEvent";

        @typing.no_type_check
        def __init__(self,value: "MultiResourcePoolRedemptionEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_multi_resource_pool_redemption_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE:
        value: "MultiResourcePoolWithdrawEvent";

        @typing.no_type_check
        def __init__(self,value: "MultiResourcePoolWithdrawEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_multi_resource_pool_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE:
        value: "MultiResourcePoolDepositEvent";

        @typing.no_type_check
        def __init__(self,value: "MultiResourcePoolDepositEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_multi_resource_pool_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_multi_resource_pool_contribution_event_value(self) -> bool:
        return isinstance(self, TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE)
    def is_multi_resource_pool_redemption_event_value(self) -> bool:
        return isinstance(self, TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE)
    def is_multi_resource_pool_withdraw_event_value(self) -> bool:
        return isinstance(self, TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE)
    def is_multi_resource_pool_deposit_event_value(self) -> bool:
        return isinstance(self, TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE = type("TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE", (TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE, TypedMultiResourcePoolBlueprintEvent,), {})  # type: ignore
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE = type("TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE", (TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE, TypedMultiResourcePoolBlueprintEvent,), {})  # type: ignore
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE = type("TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE", (TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE, TypedMultiResourcePoolBlueprintEvent,), {})  # type: ignore
TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE = type("TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE", (TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE, TypedMultiResourcePoolBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedMultiResourcePoolBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolContributionEvent.read(buf),
            )
        if variant == 2:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolRedemptionEvent.read(buf),
            )
        if variant == 3:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolWithdrawEvent.read(buf),
            )
        if variant == 4:
            return TypedMultiResourcePoolBlueprintEvent.MULTI_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeMultiResourcePoolDepositEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_multi_resource_pool_contribution_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeMultiResourcePoolContributionEvent.write(value.value, buf)
        if value.is_multi_resource_pool_redemption_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeMultiResourcePoolRedemptionEvent.write(value.value, buf)
        if value.is_multi_resource_pool_withdraw_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeMultiResourcePoolWithdrawEvent.write(value.value, buf)
        if value.is_multi_resource_pool_deposit_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeMultiResourcePoolDepositEvent.write(value.value, buf)






class TypedNativeEvent:
    def __init__(self):
        raise RuntimeError("TypedNativeEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCESS_CONTROLLER:
        value: "TypedAccessControllerPackageEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedAccessControllerPackageEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNativeEvent.ACCESS_CONTROLLER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_access_controller():
                return False
            if self.value != other.value:
                return False
            return True
    class CONSENSUS_MANAGER:
        value: "TypedConsensusManagerPackageEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedConsensusManagerPackageEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNativeEvent.CONSENSUS_MANAGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_consensus_manager():
                return False
            if self.value != other.value:
                return False
            return True
    class POOL:
        value: "TypedPoolPackageEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedPoolPackageEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNativeEvent.POOL(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_pool():
                return False
            if self.value != other.value:
                return False
            return True
    class RESOURCE:
        value: "TypedResourcePackageEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedResourcePackageEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNativeEvent.RESOURCE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_resource():
                return False
            if self.value != other.value:
                return False
            return True
    class ROLE_ASSIGNMENT:
        value: "TypedRoleAssignmentPackageEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedRoleAssignmentPackageEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNativeEvent.ROLE_ASSIGNMENT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_role_assignment():
                return False
            if self.value != other.value:
                return False
            return True
    class METADATA:
        value: "TypedMetadataPackageEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedMetadataPackageEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNativeEvent.METADATA(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_metadata():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_access_controller(self) -> bool:
        return isinstance(self, TypedNativeEvent.ACCESS_CONTROLLER)
    def is_consensus_manager(self) -> bool:
        return isinstance(self, TypedNativeEvent.CONSENSUS_MANAGER)
    def is_pool(self) -> bool:
        return isinstance(self, TypedNativeEvent.POOL)
    def is_resource(self) -> bool:
        return isinstance(self, TypedNativeEvent.RESOURCE)
    def is_role_assignment(self) -> bool:
        return isinstance(self, TypedNativeEvent.ROLE_ASSIGNMENT)
    def is_metadata(self) -> bool:
        return isinstance(self, TypedNativeEvent.METADATA)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedNativeEvent.ACCESS_CONTROLLER = type("TypedNativeEvent.ACCESS_CONTROLLER", (TypedNativeEvent.ACCESS_CONTROLLER, TypedNativeEvent,), {})  # type: ignore
TypedNativeEvent.CONSENSUS_MANAGER = type("TypedNativeEvent.CONSENSUS_MANAGER", (TypedNativeEvent.CONSENSUS_MANAGER, TypedNativeEvent,), {})  # type: ignore
TypedNativeEvent.POOL = type("TypedNativeEvent.POOL", (TypedNativeEvent.POOL, TypedNativeEvent,), {})  # type: ignore
TypedNativeEvent.RESOURCE = type("TypedNativeEvent.RESOURCE", (TypedNativeEvent.RESOURCE, TypedNativeEvent,), {})  # type: ignore
TypedNativeEvent.ROLE_ASSIGNMENT = type("TypedNativeEvent.ROLE_ASSIGNMENT", (TypedNativeEvent.ROLE_ASSIGNMENT, TypedNativeEvent,), {})  # type: ignore
TypedNativeEvent.METADATA = type("TypedNativeEvent.METADATA", (TypedNativeEvent.METADATA, TypedNativeEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedNativeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedNativeEvent.ACCESS_CONTROLLER(
                _UniffiConverterTypeTypedAccessControllerPackageEvent.read(buf),
            )
        if variant == 2:
            return TypedNativeEvent.CONSENSUS_MANAGER(
                _UniffiConverterTypeTypedConsensusManagerPackageEvent.read(buf),
            )
        if variant == 3:
            return TypedNativeEvent.POOL(
                _UniffiConverterTypeTypedPoolPackageEvent.read(buf),
            )
        if variant == 4:
            return TypedNativeEvent.RESOURCE(
                _UniffiConverterTypeTypedResourcePackageEvent.read(buf),
            )
        if variant == 5:
            return TypedNativeEvent.ROLE_ASSIGNMENT(
                _UniffiConverterTypeTypedRoleAssignmentPackageEvent.read(buf),
            )
        if variant == 6:
            return TypedNativeEvent.METADATA(
                _UniffiConverterTypeTypedMetadataPackageEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_access_controller():
            buf.write_i32(1)
            _UniffiConverterTypeTypedAccessControllerPackageEvent.write(value.value, buf)
        if value.is_consensus_manager():
            buf.write_i32(2)
            _UniffiConverterTypeTypedConsensusManagerPackageEvent.write(value.value, buf)
        if value.is_pool():
            buf.write_i32(3)
            _UniffiConverterTypeTypedPoolPackageEvent.write(value.value, buf)
        if value.is_resource():
            buf.write_i32(4)
            _UniffiConverterTypeTypedResourcePackageEvent.write(value.value, buf)
        if value.is_role_assignment():
            buf.write_i32(5)
            _UniffiConverterTypeTypedRoleAssignmentPackageEvent.write(value.value, buf)
        if value.is_metadata():
            buf.write_i32(6)
            _UniffiConverterTypeTypedMetadataPackageEvent.write(value.value, buf)






class TypedNonFungibleResourceManagerBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedNonFungibleResourceManagerBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class VAULT_CREATION_EVENT_VALUE:
        value: "VaultCreationEvent";

        @typing.no_type_check
        def __init__(self,value: "VaultCreationEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_vault_creation_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "MintNonFungibleResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "MintNonFungibleResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_mint_non_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE:
        value: "BurnNonFungibleResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "BurnNonFungibleResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_burn_non_fungible_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_vault_creation_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE)
    def is_mint_non_fungible_resource_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE)
    def is_burn_non_fungible_resource_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE = type("TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE", (TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE, TypedNonFungibleResourceManagerBlueprintEvent,), {})  # type: ignore
TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE = type("TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE", (TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE, TypedNonFungibleResourceManagerBlueprintEvent,), {})  # type: ignore
TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE = type("TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE", (TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE, TypedNonFungibleResourceManagerBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedNonFungibleResourceManagerBlueprintEvent.VAULT_CREATION_EVENT_VALUE(
                _UniffiConverterTypeVaultCreationEvent.read(buf),
            )
        if variant == 2:
            return TypedNonFungibleResourceManagerBlueprintEvent.MINT_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeMintNonFungibleResourceEvent.read(buf),
            )
        if variant == 3:
            return TypedNonFungibleResourceManagerBlueprintEvent.BURN_NON_FUNGIBLE_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeBurnNonFungibleResourceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_vault_creation_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeVaultCreationEvent.write(value.value, buf)
        if value.is_mint_non_fungible_resource_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeMintNonFungibleResourceEvent.write(value.value, buf)
        if value.is_burn_non_fungible_resource_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeBurnNonFungibleResourceEvent.write(value.value, buf)






class TypedNonFungibleVaultBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedNonFungibleVaultBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class LOCK_FEE_EVENT_VALUE:
        value: "LockFeeEvent";

        @typing.no_type_check
        def __init__(self,value: "LockFeeEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_lock_fee_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class WITHDRAW_RESOURCE_EVENT_VALUE:
        value: "WithdrawResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "WithdrawResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_withdraw_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class DEPOSIT_RESOURCE_EVENT_VALUE:
        value: "DepositResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "DepositResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_deposit_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class RECALL_RESOURCE_EVENT_VALUE:
        value: "RecallResourceEvent";

        @typing.no_type_check
        def __init__(self,value: "RecallResourceEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedNonFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_recall_resource_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_lock_fee_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE)
    def is_withdraw_resource_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE)
    def is_deposit_resource_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE)
    def is_recall_resource_event_value(self) -> bool:
        return isinstance(self, TypedNonFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedNonFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE = type("TypedNonFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE", (TypedNonFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE, TypedNonFungibleVaultBlueprintEvent,), {})  # type: ignore
TypedNonFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE = type("TypedNonFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE", (TypedNonFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE, TypedNonFungibleVaultBlueprintEvent,), {})  # type: ignore
TypedNonFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE = type("TypedNonFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE", (TypedNonFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE, TypedNonFungibleVaultBlueprintEvent,), {})  # type: ignore
TypedNonFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE = type("TypedNonFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE", (TypedNonFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE, TypedNonFungibleVaultBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedNonFungibleVaultBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedNonFungibleVaultBlueprintEvent.LOCK_FEE_EVENT_VALUE(
                _UniffiConverterTypeLockFeeEvent.read(buf),
            )
        if variant == 2:
            return TypedNonFungibleVaultBlueprintEvent.WITHDRAW_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeWithdrawResourceEvent.read(buf),
            )
        if variant == 3:
            return TypedNonFungibleVaultBlueprintEvent.DEPOSIT_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeDepositResourceEvent.read(buf),
            )
        if variant == 4:
            return TypedNonFungibleVaultBlueprintEvent.RECALL_RESOURCE_EVENT_VALUE(
                _UniffiConverterTypeRecallResourceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_lock_fee_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeLockFeeEvent.write(value.value, buf)
        if value.is_withdraw_resource_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeWithdrawResourceEvent.write(value.value, buf)
        if value.is_deposit_resource_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeDepositResourceEvent.write(value.value, buf)
        if value.is_recall_resource_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeRecallResourceEvent.write(value.value, buf)






class TypedOneResourcePoolBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedOneResourcePoolBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE:
        value: "OneResourcePoolContributionEvent";

        @typing.no_type_check
        def __init__(self,value: "OneResourcePoolContributionEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_one_resource_pool_contribution_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE:
        value: "OneResourcePoolRedemptionEvent";

        @typing.no_type_check
        def __init__(self,value: "OneResourcePoolRedemptionEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_one_resource_pool_redemption_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE:
        value: "OneResourcePoolWithdrawEvent";

        @typing.no_type_check
        def __init__(self,value: "OneResourcePoolWithdrawEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_one_resource_pool_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE:
        value: "OneResourcePoolDepositEvent";

        @typing.no_type_check
        def __init__(self,value: "OneResourcePoolDepositEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_one_resource_pool_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_one_resource_pool_contribution_event_value(self) -> bool:
        return isinstance(self, TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE)
    def is_one_resource_pool_redemption_event_value(self) -> bool:
        return isinstance(self, TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE)
    def is_one_resource_pool_withdraw_event_value(self) -> bool:
        return isinstance(self, TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE)
    def is_one_resource_pool_deposit_event_value(self) -> bool:
        return isinstance(self, TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE = type("TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE", (TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE, TypedOneResourcePoolBlueprintEvent,), {})  # type: ignore
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE = type("TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE", (TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE, TypedOneResourcePoolBlueprintEvent,), {})  # type: ignore
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE = type("TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE", (TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE, TypedOneResourcePoolBlueprintEvent,), {})  # type: ignore
TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE = type("TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE", (TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE, TypedOneResourcePoolBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedOneResourcePoolBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolContributionEvent.read(buf),
            )
        if variant == 2:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolRedemptionEvent.read(buf),
            )
        if variant == 3:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolWithdrawEvent.read(buf),
            )
        if variant == 4:
            return TypedOneResourcePoolBlueprintEvent.ONE_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeOneResourcePoolDepositEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_one_resource_pool_contribution_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeOneResourcePoolContributionEvent.write(value.value, buf)
        if value.is_one_resource_pool_redemption_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeOneResourcePoolRedemptionEvent.write(value.value, buf)
        if value.is_one_resource_pool_withdraw_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeOneResourcePoolWithdrawEvent.write(value.value, buf)
        if value.is_one_resource_pool_deposit_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeOneResourcePoolDepositEvent.write(value.value, buf)






class TypedPoolPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedPoolPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONE_RESOURCE_POOL:
        value: "TypedOneResourcePoolBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedOneResourcePoolBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedPoolPackageEvent.ONE_RESOURCE_POOL(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_one_resource_pool():
                return False
            if self.value != other.value:
                return False
            return True
    class TWO_RESOURCE_POOL:
        value: "TypedTwoResourcePoolBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedTwoResourcePoolBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedPoolPackageEvent.TWO_RESOURCE_POOL(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_two_resource_pool():
                return False
            if self.value != other.value:
                return False
            return True
    class MULTI_RESOURCE_POOL:
        value: "TypedMultiResourcePoolBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedMultiResourcePoolBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedPoolPackageEvent.MULTI_RESOURCE_POOL(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_multi_resource_pool():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_one_resource_pool(self) -> bool:
        return isinstance(self, TypedPoolPackageEvent.ONE_RESOURCE_POOL)
    def is_two_resource_pool(self) -> bool:
        return isinstance(self, TypedPoolPackageEvent.TWO_RESOURCE_POOL)
    def is_multi_resource_pool(self) -> bool:
        return isinstance(self, TypedPoolPackageEvent.MULTI_RESOURCE_POOL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedPoolPackageEvent.ONE_RESOURCE_POOL = type("TypedPoolPackageEvent.ONE_RESOURCE_POOL", (TypedPoolPackageEvent.ONE_RESOURCE_POOL, TypedPoolPackageEvent,), {})  # type: ignore
TypedPoolPackageEvent.TWO_RESOURCE_POOL = type("TypedPoolPackageEvent.TWO_RESOURCE_POOL", (TypedPoolPackageEvent.TWO_RESOURCE_POOL, TypedPoolPackageEvent,), {})  # type: ignore
TypedPoolPackageEvent.MULTI_RESOURCE_POOL = type("TypedPoolPackageEvent.MULTI_RESOURCE_POOL", (TypedPoolPackageEvent.MULTI_RESOURCE_POOL, TypedPoolPackageEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedPoolPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedPoolPackageEvent.ONE_RESOURCE_POOL(
                _UniffiConverterTypeTypedOneResourcePoolBlueprintEvent.read(buf),
            )
        if variant == 2:
            return TypedPoolPackageEvent.TWO_RESOURCE_POOL(
                _UniffiConverterTypeTypedTwoResourcePoolBlueprintEvent.read(buf),
            )
        if variant == 3:
            return TypedPoolPackageEvent.MULTI_RESOURCE_POOL(
                _UniffiConverterTypeTypedMultiResourcePoolBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_one_resource_pool():
            buf.write_i32(1)
            _UniffiConverterTypeTypedOneResourcePoolBlueprintEvent.write(value.value, buf)
        if value.is_two_resource_pool():
            buf.write_i32(2)
            _UniffiConverterTypeTypedTwoResourcePoolBlueprintEvent.write(value.value, buf)
        if value.is_multi_resource_pool():
            buf.write_i32(3)
            _UniffiConverterTypeTypedMultiResourcePoolBlueprintEvent.write(value.value, buf)






class TypedResourcePackageEvent:
    def __init__(self):
        raise RuntimeError("TypedResourcePackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FUNGIBLE_VAULT:
        value: "TypedFungibleVaultBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedFungibleVaultBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedResourcePackageEvent.FUNGIBLE_VAULT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_fungible_vault():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_VAULT:
        value: "TypedNonFungibleVaultBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedNonFungibleVaultBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedResourcePackageEvent.NON_FUNGIBLE_VAULT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_vault():
                return False
            if self.value != other.value:
                return False
            return True
    class FUNGIBLE_RESOURCE_MANAGER:
        value: "TypedFungibleResourceManagerBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedFungibleResourceManagerBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_fungible_resource_manager():
                return False
            if self.value != other.value:
                return False
            return True
    class NON_FUNGIBLE_RESOURCE_MANAGER:
        value: "TypedNonFungibleResourceManagerBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedNonFungibleResourceManagerBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_non_fungible_resource_manager():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fungible_vault(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.FUNGIBLE_VAULT)
    def is_non_fungible_vault(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.NON_FUNGIBLE_VAULT)
    def is_fungible_resource_manager(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER)
    def is_non_fungible_resource_manager(self) -> bool:
        return isinstance(self, TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedResourcePackageEvent.FUNGIBLE_VAULT = type("TypedResourcePackageEvent.FUNGIBLE_VAULT", (TypedResourcePackageEvent.FUNGIBLE_VAULT, TypedResourcePackageEvent,), {})  # type: ignore
TypedResourcePackageEvent.NON_FUNGIBLE_VAULT = type("TypedResourcePackageEvent.NON_FUNGIBLE_VAULT", (TypedResourcePackageEvent.NON_FUNGIBLE_VAULT, TypedResourcePackageEvent,), {})  # type: ignore
TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER = type("TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER", (TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER, TypedResourcePackageEvent,), {})  # type: ignore
TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER = type("TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER", (TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER, TypedResourcePackageEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedResourcePackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedResourcePackageEvent.FUNGIBLE_VAULT(
                _UniffiConverterTypeTypedFungibleVaultBlueprintEvent.read(buf),
            )
        if variant == 2:
            return TypedResourcePackageEvent.NON_FUNGIBLE_VAULT(
                _UniffiConverterTypeTypedNonFungibleVaultBlueprintEvent.read(buf),
            )
        if variant == 3:
            return TypedResourcePackageEvent.FUNGIBLE_RESOURCE_MANAGER(
                _UniffiConverterTypeTypedFungibleResourceManagerBlueprintEvent.read(buf),
            )
        if variant == 4:
            return TypedResourcePackageEvent.NON_FUNGIBLE_RESOURCE_MANAGER(
                _UniffiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_fungible_vault():
            buf.write_i32(1)
            _UniffiConverterTypeTypedFungibleVaultBlueprintEvent.write(value.value, buf)
        if value.is_non_fungible_vault():
            buf.write_i32(2)
            _UniffiConverterTypeTypedNonFungibleVaultBlueprintEvent.write(value.value, buf)
        if value.is_fungible_resource_manager():
            buf.write_i32(3)
            _UniffiConverterTypeTypedFungibleResourceManagerBlueprintEvent.write(value.value, buf)
        if value.is_non_fungible_resource_manager():
            buf.write_i32(4)
            _UniffiConverterTypeTypedNonFungibleResourceManagerBlueprintEvent.write(value.value, buf)






class TypedRoleAssignmentBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedRoleAssignmentBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SET_ROLE_EVENT_VALUE:
        value: "SetRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "SetRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class LOCK_ROLE_EVENT_VALUE:
        value: "LockRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "LockRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.LOCK_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_lock_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class SET_AND_LOCK_ROLE_EVENT_VALUE:
        value: "SetAndLockRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "SetAndLockRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set_and_lock_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class SET_OWNER_ROLE_EVENT_VALUE:
        value: "SetOwnerRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "SetOwnerRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set_owner_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class LOCK_OWNER_ROLE_EVENT_VALUE:
        value: "LockOwnerRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "LockOwnerRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_lock_owner_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE:
        value: "SetAndLockOwnerRoleEvent";

        @typing.no_type_check
        def __init__(self,value: "SetAndLockOwnerRoleEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_set_and_lock_owner_role_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_set_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE)
    def is_lock_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.LOCK_ROLE_EVENT_VALUE)
    def is_set_and_lock_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_ROLE_EVENT_VALUE)
    def is_set_owner_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE)
    def is_lock_owner_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE)
    def is_set_and_lock_owner_role_event_value(self) -> bool:
        return isinstance(self, TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE = type("TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE", (TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE, TypedRoleAssignmentBlueprintEvent,), {})  # type: ignore
TypedRoleAssignmentBlueprintEvent.LOCK_ROLE_EVENT_VALUE = type("TypedRoleAssignmentBlueprintEvent.LOCK_ROLE_EVENT_VALUE", (TypedRoleAssignmentBlueprintEvent.LOCK_ROLE_EVENT_VALUE, TypedRoleAssignmentBlueprintEvent,), {})  # type: ignore
TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_ROLE_EVENT_VALUE = type("TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_ROLE_EVENT_VALUE", (TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_ROLE_EVENT_VALUE, TypedRoleAssignmentBlueprintEvent,), {})  # type: ignore
TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE = type("TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE", (TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE, TypedRoleAssignmentBlueprintEvent,), {})  # type: ignore
TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE = type("TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE", (TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE, TypedRoleAssignmentBlueprintEvent,), {})  # type: ignore
TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE = type("TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE", (TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE, TypedRoleAssignmentBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedRoleAssignmentBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedRoleAssignmentBlueprintEvent.SET_ROLE_EVENT_VALUE(
                _UniffiConverterTypeSetRoleEvent.read(buf),
            )
        if variant == 2:
            return TypedRoleAssignmentBlueprintEvent.LOCK_ROLE_EVENT_VALUE(
                _UniffiConverterTypeLockRoleEvent.read(buf),
            )
        if variant == 3:
            return TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_ROLE_EVENT_VALUE(
                _UniffiConverterTypeSetAndLockRoleEvent.read(buf),
            )
        if variant == 4:
            return TypedRoleAssignmentBlueprintEvent.SET_OWNER_ROLE_EVENT_VALUE(
                _UniffiConverterTypeSetOwnerRoleEvent.read(buf),
            )
        if variant == 5:
            return TypedRoleAssignmentBlueprintEvent.LOCK_OWNER_ROLE_EVENT_VALUE(
                _UniffiConverterTypeLockOwnerRoleEvent.read(buf),
            )
        if variant == 6:
            return TypedRoleAssignmentBlueprintEvent.SET_AND_LOCK_OWNER_ROLE_EVENT_VALUE(
                _UniffiConverterTypeSetAndLockOwnerRoleEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_set_role_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeSetRoleEvent.write(value.value, buf)
        if value.is_lock_role_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeLockRoleEvent.write(value.value, buf)
        if value.is_set_and_lock_role_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeSetAndLockRoleEvent.write(value.value, buf)
        if value.is_set_owner_role_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeSetOwnerRoleEvent.write(value.value, buf)
        if value.is_lock_owner_role_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeLockOwnerRoleEvent.write(value.value, buf)
        if value.is_set_and_lock_owner_role_event_value():
            buf.write_i32(6)
            _UniffiConverterTypeSetAndLockOwnerRoleEvent.write(value.value, buf)






class TypedRoleAssignmentPackageEvent:
    def __init__(self):
        raise RuntimeError("TypedRoleAssignmentPackageEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ROLE_ASSIGNMENT:
        value: "TypedRoleAssignmentBlueprintEvent";

        @typing.no_type_check
        def __init__(self,value: "TypedRoleAssignmentBlueprintEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_role_assignment():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_role_assignment(self) -> bool:
        return isinstance(self, TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT = type("TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT", (TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT, TypedRoleAssignmentPackageEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedRoleAssignmentPackageEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedRoleAssignmentPackageEvent.ROLE_ASSIGNMENT(
                _UniffiConverterTypeTypedRoleAssignmentBlueprintEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_role_assignment():
            buf.write_i32(1)
            _UniffiConverterTypeTypedRoleAssignmentBlueprintEvent.write(value.value, buf)






class TypedTwoResourcePoolBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedTwoResourcePoolBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE:
        value: "TwoResourcePoolContributionEvent";

        @typing.no_type_check
        def __init__(self,value: "TwoResourcePoolContributionEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_two_resource_pool_contribution_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE:
        value: "TwoResourcePoolRedemptionEvent";

        @typing.no_type_check
        def __init__(self,value: "TwoResourcePoolRedemptionEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_two_resource_pool_redemption_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE:
        value: "TwoResourcePoolWithdrawEvent";

        @typing.no_type_check
        def __init__(self,value: "TwoResourcePoolWithdrawEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_two_resource_pool_withdraw_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE:
        value: "TwoResourcePoolDepositEvent";

        @typing.no_type_check
        def __init__(self,value: "TwoResourcePoolDepositEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_two_resource_pool_deposit_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_two_resource_pool_contribution_event_value(self) -> bool:
        return isinstance(self, TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE)
    def is_two_resource_pool_redemption_event_value(self) -> bool:
        return isinstance(self, TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE)
    def is_two_resource_pool_withdraw_event_value(self) -> bool:
        return isinstance(self, TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE)
    def is_two_resource_pool_deposit_event_value(self) -> bool:
        return isinstance(self, TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE = type("TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE", (TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE, TypedTwoResourcePoolBlueprintEvent,), {})  # type: ignore
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE = type("TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE", (TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE, TypedTwoResourcePoolBlueprintEvent,), {})  # type: ignore
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE = type("TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE", (TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE, TypedTwoResourcePoolBlueprintEvent,), {})  # type: ignore
TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE = type("TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE", (TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE, TypedTwoResourcePoolBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedTwoResourcePoolBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_CONTRIBUTION_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolContributionEvent.read(buf),
            )
        if variant == 2:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_REDEMPTION_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolRedemptionEvent.read(buf),
            )
        if variant == 3:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_WITHDRAW_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolWithdrawEvent.read(buf),
            )
        if variant == 4:
            return TypedTwoResourcePoolBlueprintEvent.TWO_RESOURCE_POOL_DEPOSIT_EVENT_VALUE(
                _UniffiConverterTypeTwoResourcePoolDepositEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_two_resource_pool_contribution_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeTwoResourcePoolContributionEvent.write(value.value, buf)
        if value.is_two_resource_pool_redemption_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeTwoResourcePoolRedemptionEvent.write(value.value, buf)
        if value.is_two_resource_pool_withdraw_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeTwoResourcePoolWithdrawEvent.write(value.value, buf)
        if value.is_two_resource_pool_deposit_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeTwoResourcePoolDepositEvent.write(value.value, buf)






class TypedValidatorBlueprintEvent:
    def __init__(self):
        raise RuntimeError("TypedValidatorBlueprintEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class REGISTER_VALIDATOR_EVENT_VALUE:
        value: "RegisterValidatorEvent";

        @typing.no_type_check
        def __init__(self,value: "RegisterValidatorEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_register_validator_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class UNREGISTER_VALIDATOR_EVENT_VALUE:
        value: "UnregisterValidatorEvent";

        @typing.no_type_check
        def __init__(self,value: "UnregisterValidatorEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_unregister_validator_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class STAKE_EVENT_VALUE:
        value: "StakeEvent";

        @typing.no_type_check
        def __init__(self,value: "StakeEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_stake_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class UNSTAKE_EVENT_VALUE:
        value: "UnstakeEvent";

        @typing.no_type_check
        def __init__(self,value: "UnstakeEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_unstake_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class CLAIM_XRD_EVENT_VALUE:
        value: "ClaimXrdEvent";

        @typing.no_type_check
        def __init__(self,value: "ClaimXrdEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_claim_xrd_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE:
        value: "UpdateAcceptingStakeDelegationStateEvent";

        @typing.no_type_check
        def __init__(self,value: "UpdateAcceptingStakeDelegationStateEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_update_accepting_stake_delegation_state_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE:
        value: "ProtocolUpdateReadinessSignalEvent";

        @typing.no_type_check
        def __init__(self,value: "ProtocolUpdateReadinessSignalEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_protocol_update_readiness_signal_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class VALIDATOR_EMISSION_APPLIED_EVENT_VALUE:
        value: "ValidatorEmissionAppliedEvent";

        @typing.no_type_check
        def __init__(self,value: "ValidatorEmissionAppliedEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_validator_emission_applied_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    class VALIDATOR_REWARD_APPLIED_EVENT_VALUE:
        value: "ValidatorRewardAppliedEvent";

        @typing.no_type_check
        def __init__(self,value: "ValidatorRewardAppliedEvent"):
            
            self.value = value
            

        def __str__(self):
            return "TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_validator_reward_applied_event_value():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_register_validator_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE)
    def is_unregister_validator_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE)
    def is_stake_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE)
    def is_unstake_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE)
    def is_claim_xrd_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE)
    def is_update_accepting_stake_delegation_state_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE)
    def is_protocol_update_readiness_signal_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE)
    def is_validator_emission_applied_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE)
    def is_validator_reward_applied_event_value(self) -> bool:
        return isinstance(self, TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE = type("TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE", (TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE = type("TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE", (TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE = type("TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE", (TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE = type("TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE", (TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE = type("TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE", (TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE = type("TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE", (TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE = type("TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE", (TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE = type("TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE", (TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore
TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE = type("TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE", (TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE, TypedValidatorBlueprintEvent,), {})  # type: ignore




class _UniffiConverterTypeTypedValidatorBlueprintEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypedValidatorBlueprintEvent.REGISTER_VALIDATOR_EVENT_VALUE(
                _UniffiConverterTypeRegisterValidatorEvent.read(buf),
            )
        if variant == 2:
            return TypedValidatorBlueprintEvent.UNREGISTER_VALIDATOR_EVENT_VALUE(
                _UniffiConverterTypeUnregisterValidatorEvent.read(buf),
            )
        if variant == 3:
            return TypedValidatorBlueprintEvent.STAKE_EVENT_VALUE(
                _UniffiConverterTypeStakeEvent.read(buf),
            )
        if variant == 4:
            return TypedValidatorBlueprintEvent.UNSTAKE_EVENT_VALUE(
                _UniffiConverterTypeUnstakeEvent.read(buf),
            )
        if variant == 5:
            return TypedValidatorBlueprintEvent.CLAIM_XRD_EVENT_VALUE(
                _UniffiConverterTypeClaimXrdEvent.read(buf),
            )
        if variant == 6:
            return TypedValidatorBlueprintEvent.UPDATE_ACCEPTING_STAKE_DELEGATION_STATE_EVENT_VALUE(
                _UniffiConverterTypeUpdateAcceptingStakeDelegationStateEvent.read(buf),
            )
        if variant == 7:
            return TypedValidatorBlueprintEvent.PROTOCOL_UPDATE_READINESS_SIGNAL_EVENT_VALUE(
                _UniffiConverterTypeProtocolUpdateReadinessSignalEvent.read(buf),
            )
        if variant == 8:
            return TypedValidatorBlueprintEvent.VALIDATOR_EMISSION_APPLIED_EVENT_VALUE(
                _UniffiConverterTypeValidatorEmissionAppliedEvent.read(buf),
            )
        if variant == 9:
            return TypedValidatorBlueprintEvent.VALIDATOR_REWARD_APPLIED_EVENT_VALUE(
                _UniffiConverterTypeValidatorRewardAppliedEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_register_validator_event_value():
            buf.write_i32(1)
            _UniffiConverterTypeRegisterValidatorEvent.write(value.value, buf)
        if value.is_unregister_validator_event_value():
            buf.write_i32(2)
            _UniffiConverterTypeUnregisterValidatorEvent.write(value.value, buf)
        if value.is_stake_event_value():
            buf.write_i32(3)
            _UniffiConverterTypeStakeEvent.write(value.value, buf)
        if value.is_unstake_event_value():
            buf.write_i32(4)
            _UniffiConverterTypeUnstakeEvent.write(value.value, buf)
        if value.is_claim_xrd_event_value():
            buf.write_i32(5)
            _UniffiConverterTypeClaimXrdEvent.write(value.value, buf)
        if value.is_update_accepting_stake_delegation_state_event_value():
            buf.write_i32(6)
            _UniffiConverterTypeUpdateAcceptingStakeDelegationStateEvent.write(value.value, buf)
        if value.is_protocol_update_readiness_signal_event_value():
            buf.write_i32(7)
            _UniffiConverterTypeProtocolUpdateReadinessSignalEvent.write(value.value, buf)
        if value.is_validator_emission_applied_event_value():
            buf.write_i32(8)
            _UniffiConverterTypeValidatorEmissionAppliedEvent.write(value.value, buf)
        if value.is_validator_reward_applied_event_value():
            buf.write_i32(9)
            _UniffiConverterTypeValidatorRewardAppliedEvent.write(value.value, buf)






class WithdrawResourceEvent:
    def __init__(self):
        raise RuntimeError("WithdrawResourceEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class AMOUNT:
        value: "Decimal";

        @typing.no_type_check
        def __init__(self,value: "Decimal"):
            
            self.value = value
            

        def __str__(self):
            return "WithdrawResourceEvent.AMOUNT(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_amount():
                return False
            if self.value != other.value:
                return False
            return True
    class IDS:
        value: "typing.List[NonFungibleLocalId]";

        @typing.no_type_check
        def __init__(self,value: "typing.List[NonFungibleLocalId]"):
            
            self.value = value
            

        def __str__(self):
            return "WithdrawResourceEvent.IDS(value={})".format(self.value)

        def __eq__(self, other):
            if not other.is_ids():
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_amount(self) -> bool:
        return isinstance(self, WithdrawResourceEvent.AMOUNT)
    def is_ids(self) -> bool:
        return isinstance(self, WithdrawResourceEvent.IDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WithdrawResourceEvent.AMOUNT = type("WithdrawResourceEvent.AMOUNT", (WithdrawResourceEvent.AMOUNT, WithdrawResourceEvent,), {})  # type: ignore
WithdrawResourceEvent.IDS = type("WithdrawResourceEvent.IDS", (WithdrawResourceEvent.IDS, WithdrawResourceEvent,), {})  # type: ignore




class _UniffiConverterTypeWithdrawResourceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WithdrawResourceEvent.AMOUNT(
                _UniffiConverterTypeDecimal.read(buf),
            )
        if variant == 2:
            return WithdrawResourceEvent.IDS(
                _UniffiConverterSequenceTypeNonFungibleLocalId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_amount():
            buf.write_i32(1)
            _UniffiConverterTypeDecimal.write(value.value, buf)
        if value.is_ids():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeNonFungibleLocalId.write(value.value, buf)




import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Declaration and _UniffiConverters for Signer Callback Interface

class Signer:
    def sign(self, hash: "Hash"):
        raise NotImplementedError

    def sign_to_signature(self, hash: "Hash"):
        raise NotImplementedError

    def sign_to_signature_with_public_key(self, hash: "Hash"):
        raise NotImplementedError

    def public_key(self, ):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceSigner(handle, method, args_data, args_len, buf_ptr):
    
    def invoke_sign(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.sign(
                _UniffiConverterTypeHash.read(args_stream)
                )

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterSequenceUInt8.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    
    def invoke_sign_to_signature(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.sign_to_signature(
                _UniffiConverterTypeHash.read(args_stream)
                )

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeSignature.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    
    def invoke_sign_to_signature_with_public_key(python_callback, args_stream, buf_ptr):
        def makeCall():return python_callback.sign_to_signature_with_public_key(
                _UniffiConverterTypeHash.read(args_stream)
                )

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypeSignatureWithPublicKey.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    
    def invoke_public_key(python_callback, args_stream, buf_ptr):
        def makeCall():
            return python_callback.public_key()

        def makeCallAndHandleReturn():
            rval = makeCall()
            with _UniffiRustBuffer.alloc_with_builder() as builder:
                _UniffiConverterTypePublicKey.write(rval, builder)
                buf_ptr[0] = builder.finalize()
            return _UNIFFI_CALLBACK_SUCCESS
        return makeCallAndHandleReturn()

    

    cb = _UniffiConverterCallbackInterfaceSigner.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a uniffi bug")

    if method == IDX_CALLBACK_FREE:
        _UniffiConverterCallbackInterfaceSigner.drop(handle)
        # Successfull return
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return _UNIFFI_CALLBACK_SUCCESS

    if method == 1:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_sign(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 2:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_sign_to_signature(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 3:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_sign_to_signature_with_public_key(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    if method == 4:
        # Call the method and handle any errors
        # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs` for details
        try:
            return invoke_public_key(cb, _UniffiRustBufferStream(args_data, args_len), buf_ptr)
        except BaseException as e:
            # Catch unexpected errors
            try:
                # Try to serialize the exception into a String
                buf_ptr[0] = _UniffiConverterString.lower(repr(e))
            except:
                # If that fails, just give up
                pass
            return _UNIFFI_CALLBACK_UNEXPECTED_ERROR
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
    return _UNIFFI_CALLBACK_UNEXPECTED_ERROR

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceSigner = _UNIFFI_FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceSigner)
_rust_call(lambda err: _UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_init_callback_signer(foreignCallbackCallbackInterfaceSigner, err))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiConverterCallbackInterfaceSigner = _UniffiConverterCallbackInterface(foreignCallbackCallbackInterfaceSigner)



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAccessRule(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAccessRule.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAccessRule.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDecimal.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDecimal.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePreciseDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePreciseDecimal.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePreciseDecimal.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLockFeeModification(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLockFeeModification.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLockFeeModification.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeManifestBuilderAddressReservation(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeManifestBuilderAddressReservation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeManifestBuilderAddressReservation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeResourceManagerRole(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeResourceManagerRole.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeResourceManagerRole.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSchema(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSchema.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSchema.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMetadataValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMetadataValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMetadataValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeResourceOrNonFungible(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeResourceOrNonFungible.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeResourceOrNonFungible.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt32.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceInt32(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterInt32.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceInt64(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBool(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBool.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBool.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDecimal.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDecimal.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNonFungibleGlobalId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNonFungibleGlobalId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNonFungibleGlobalId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeIndexedAssertion(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIndexedAssertion.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeIndexedAssertion.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeManifestBuilderMapEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestBuilderMapEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeManifestBuilderMapEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMapEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMapEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMapEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEntityType(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEntityType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEntityType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeInstruction(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeInstruction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeInstruction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeManifestBuilderValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestBuilderValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeManifestBuilderValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeManifestValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeManifestValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeManifestValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNonFungibleLocalId(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNonFungibleLocalId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNonFungibleLocalId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKeyHash(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKeyHash.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKeyHash.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeReservedInstruction(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeReservedInstruction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeReservedInstruction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeResourceOrNonFungible(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeResourceOrNonFungible.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeResourceOrNonFungible.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeResourceTracker(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeResourceTracker.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeResourceTracker.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSignatureWithPublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSignatureWithPublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSignatureWithPublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTransactionType(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTransactionType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTransactionType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeDecimal(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeDecimal.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeDecimal.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeAuthorizedDepositorsChanges(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeAuthorizedDepositorsChanges.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeAuthorizedDepositorsChanges.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeMetadataInitEntry(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeMetadataInitEntry.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeMetadataInitEntry.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeValidatorInfo(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeValidatorInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeValidatorInfo.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeAccountDefaultDepositRule(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeAccountDefaultDepositRule.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeAccountDefaultDepositRule.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeResourcePreferenceAction(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeResourcePreferenceAction.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeResourcePreferenceAction.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringTypeResources(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeResources.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeResources.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringOptionalTypeAccessRule(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterOptionalTypeAccessRule.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterOptionalTypeAccessRule.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringOptionalTypeMetadataValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterOptionalTypeMetadataValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterOptionalTypeMetadataValue.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringSequenceTypeResourceTracker(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceTypeResourceTracker.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceTypeResourceTracker.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringMapStringTypeResourcePreferenceAction(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringTypeResourcePreferenceAction.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringTypeResourcePreferenceAction.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringMapStringTypeResources(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringTypeResources.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringTypeResources.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringMapStringOptionalTypeMetadataValue(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapStringOptionalTypeMetadataValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapStringOptionalTypeMetadataValue.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringMapTypeNonFungibleLocalIdSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterMapTypeNonFungibleLocalIdSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterMapTypeNonFungibleLocalIdSequenceUInt8.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeCurveTypeTypeDecryptorsByCurve(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeCurveType.write(key, buf)
            _UniffiConverterTypeDecryptorsByCurve.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeCurveType.read(buf)
            val = _UniffiConverterTypeDecryptorsByCurve.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeEntityTypeSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeEntityType.write(key, buf)
            _UniffiConverterSequenceTypeAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeEntityType.read(buf)
            val = _UniffiConverterSequenceTypeAddress.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeNonFungibleLocalIdSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeNonFungibleLocalId.write(key, buf)
            _UniffiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeNonFungibleLocalId.read(buf)
            val = _UniffiConverterSequenceUInt8.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapSequenceUInt8SequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterSequenceUInt8.write(key, buf)
            _UniffiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterSequenceUInt8.read(buf)
            val = _UniffiConverterSequenceUInt8.read(buf)
            d[key] = val
        return d

def build_information() -> "BuildInformation":
    return _UniffiConverterTypeBuildInformation.lift(_rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_build_information,))


def derive_olympia_account_address_from_public_key(public_key: "PublicKey",olympia_network: "OlympiaNetwork") -> "OlympiaAddress":
    
    
    return _UniffiConverterTypeOlympiaAddress.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_olympia_account_address_from_public_key,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterTypeOlympiaNetwork.lower(olympia_network)))


def derive_public_key_from_olympia_account_address(olympia_resource_address: "OlympiaAddress") -> "PublicKey":
    
    return _UniffiConverterTypePublicKey.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_public_key_from_olympia_account_address,
        _UniffiConverterTypeOlympiaAddress.lower(olympia_resource_address)))


def derive_resource_address_from_olympia_resource_address(olympia_resource_address: "OlympiaAddress",network_id: "int") -> "Address":
    
    
    return _UniffiConverterTypeAddress.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_resource_address_from_olympia_resource_address,
        _UniffiConverterTypeOlympiaAddress.lower(olympia_resource_address),
        _UniffiConverterUInt8.lower(network_id)))


def derive_virtual_account_address_from_olympia_account_address(olympia_account_address: "OlympiaAddress",network_id: "int") -> "Address":
    
    
    return _UniffiConverterTypeAddress.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_olympia_account_address,
        _UniffiConverterTypeOlympiaAddress.lower(olympia_account_address),
        _UniffiConverterUInt8.lower(network_id)))


def derive_virtual_account_address_from_public_key(public_key: "PublicKey",network_id: "int") -> "Address":
    
    
    return _UniffiConverterTypeAddress.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_account_address_from_public_key,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(network_id)))


def derive_virtual_identity_address_from_public_key(public_key: "PublicKey",network_id: "int") -> "Address":
    
    
    return _UniffiConverterTypeAddress.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_identity_address_from_public_key,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(network_id)))


def derive_virtual_signature_non_fungible_global_id_from_public_key(public_key: "PublicKey",network_id: "int") -> "NonFungibleGlobalId":
    
    
    return _UniffiConverterTypeNonFungibleGlobalId.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_derive_virtual_signature_non_fungible_global_id_from_public_key,
        _UniffiConverterTypePublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(network_id)))


def hash(data: "typing.List[int]") -> "Hash":
    
    return _UniffiConverterTypeHash.lift(_rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_hash,
        _UniffiConverterSequenceUInt8.lower(data)))


def known_addresses(network_id: "int") -> "KnownAddresses":
    
    return _UniffiConverterTypeKnownAddresses.lift(_rust_call(_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_known_addresses,
        _UniffiConverterUInt8.lower(network_id)))


def manifest_sbor_decode_to_string_representation(bytes: "typing.List[int]",representation: "ManifestSborStringRepresentation",network_id: "int",schema: "typing.Optional[Schema]") -> "str":
    
    
    
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_manifest_sbor_decode_to_string_representation,
        _UniffiConverterSequenceUInt8.lower(bytes),
        _UniffiConverterTypeManifestSborStringRepresentation.lower(representation),
        _UniffiConverterUInt8.lower(network_id),
        _UniffiConverterOptionalTypeSchema.lower(schema)))


def metadata_sbor_decode(bytes: "typing.List[int]",network_id: "int") -> "MetadataValue":
    
    
    return _UniffiConverterTypeMetadataValue.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_decode,
        _UniffiConverterSequenceUInt8.lower(bytes),
        _UniffiConverterUInt8.lower(network_id)))


def metadata_sbor_encode(value: "MetadataValue") -> "typing.List[int]":
    
    return _UniffiConverterSequenceUInt8.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_metadata_sbor_encode,
        _UniffiConverterTypeMetadataValue.lower(value)))


def non_fungible_local_id_as_str(value: "NonFungibleLocalId") -> "str":
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_as_str,
        _UniffiConverterTypeNonFungibleLocalId.lower(value)))


def non_fungible_local_id_from_str(string: "str") -> "NonFungibleLocalId":
    
    return _UniffiConverterTypeNonFungibleLocalId.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_from_str,
        _UniffiConverterString.lower(string)))


def non_fungible_local_id_sbor_decode(bytes: "typing.List[int]") -> "NonFungibleLocalId":
    
    return _UniffiConverterTypeNonFungibleLocalId.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_decode,
        _UniffiConverterSequenceUInt8.lower(bytes)))


def non_fungible_local_id_sbor_encode(value: "NonFungibleLocalId") -> "typing.List[int]":
    
    return _UniffiConverterSequenceUInt8.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_non_fungible_local_id_sbor_encode,
        _UniffiConverterTypeNonFungibleLocalId.lower(value)))


def sbor_decode_to_string_representation(bytes: "typing.List[int]",representation: "SerializationMode",network_id: "int",schema: "typing.Optional[Schema]") -> "str":
    
    
    
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_string_representation,
        _UniffiConverterSequenceUInt8.lower(bytes),
        _UniffiConverterTypeSerializationMode.lower(representation),
        _UniffiConverterUInt8.lower(network_id),
        _UniffiConverterOptionalTypeSchema.lower(schema)))


def sbor_decode_to_typed_native_event(event_type_identifier: "EventTypeIdentifier",event_data: "typing.List[int]",network_id: "int") -> "TypedNativeEvent":
    
    
    
    return _UniffiConverterTypeTypedNativeEvent.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_sbor_decode_to_typed_native_event,
        _UniffiConverterTypeEventTypeIdentifier.lower(event_type_identifier),
        _UniffiConverterSequenceUInt8.lower(event_data),
        _UniffiConverterUInt8.lower(network_id)))


def scrypto_sbor_decode_to_string_representation(bytes: "typing.List[int]",representation: "SerializationMode",network_id: "int",schema: "typing.Optional[Schema]") -> "str":
    
    
    
    
    return _UniffiConverterString.lift(_rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_scrypto_sbor_decode_to_string_representation,
        _UniffiConverterSequenceUInt8.lower(bytes),
        _UniffiConverterTypeSerializationMode.lower(representation),
        _UniffiConverterUInt8.lower(network_id),
        _UniffiConverterOptionalTypeSchema.lower(schema)))


def test_panic(message: "str"):
    
    _rust_call_with_error(_UniffiConverterTypeRadixEngineToolkitError,_UniffiLib.uniffi_radix_engine_toolkit_uniffi_fn_func_test_panic,
        _UniffiConverterString.lower(message))


__all__ = [
    "InternalError",
    "AccountDefaultDepositRule",
    "Assertion",
    "Curve",
    "CurveType",
    "DecimalSource",
    "DecryptorsByCurve",
    "DependencyInformation",
    "DepositResourceEvent",
    "Emitter",
    "EntityType",
    "Instruction",
    "LocalTypeIndex",
    "ManifestAddress",
    "ManifestBuilderAddress",
    "ManifestBuilderValue",
    "ManifestBuilderValueKind",
    "ManifestExpression",
    "ManifestSborStringRepresentation",
    "ManifestValue",
    "ManifestValueKind",
    "Message",
    "MessageContent",
    "MetadataValue",
    "NameRecordError",
    "NonFungibleLocalId",
    "NonFungibleLocalIdVecSource",
    "ObjectModuleId",
    "OlympiaNetwork",
    "OwnerRole",
    "Proposer",
    "PublicKey",
    "PublicKeyHash",
    "RadixEngineToolkitError",
    "RecallResourceEvent",
    "ReservedInstruction",
    "ResourceOrNonFungible",
    "ResourcePreference",
    "ResourcePreferenceAction",
    "ResourceSpecifier",
    "ResourceTracker",
    "Resources",
    "Role",
    "RoundingMode",
    "SerializationMode",
    "Signature",
    "SignatureWithPublicKey",
    "TransactionType",
    "TypedAccessControllerBlueprintEvent",
    "TypedAccessControllerPackageEvent",
    "TypedConsensusManagerBlueprintEvent",
    "TypedConsensusManagerPackageEvent",
    "TypedFungibleResourceManagerBlueprintEvent",
    "TypedFungibleVaultBlueprintEvent",
    "TypedMetadataBlueprintEvent",
    "TypedMetadataPackageEvent",
    "TypedMultiResourcePoolBlueprintEvent",
    "TypedNativeEvent",
    "TypedNonFungibleResourceManagerBlueprintEvent",
    "TypedNonFungibleVaultBlueprintEvent",
    "TypedOneResourcePoolBlueprintEvent",
    "TypedPoolPackageEvent",
    "TypedResourcePackageEvent",
    "TypedRoleAssignmentBlueprintEvent",
    "TypedRoleAssignmentPackageEvent",
    "TypedTwoResourcePoolBlueprintEvent",
    "TypedValidatorBlueprintEvent",
    "WithdrawResourceEvent",
    "AuthorizedDepositorsChanges",
    "BadgeWithdrawEvent",
    "BuildInformation",
    "BurnFungibleResourceEvent",
    "BurnNonFungibleResourceEvent",
    "CancelBadgeWithdrawAttemptEvent",
    "CancelRecoveryProposalEvent",
    "ClaimXrdEvent",
    "ComponentAddresses",
    "Ed25519PublicKey",
    "EncryptedMessage",
    "EpochChangeEvent",
    "EventTypeIdentifier",
    "ExecutionAnalysis",
    "FeeLocks",
    "FeeSummary",
    "FungibleResourceRoles",
    "IndexedAssertion",
    "InitiateBadgeWithdrawAttemptEvent",
    "InitiateRecoveryEvent",
    "KnownAddresses",
    "LockFeeEvent",
    "LockFeeModification",
    "LockOwnerRoleEvent",
    "LockPrimaryRoleEvent",
    "LockRoleEvent",
    "ManifestAddressReservation",
    "ManifestBlobRef",
    "ManifestBucket",
    "ManifestBuilderAddressReservation",
    "ManifestBuilderBucket",
    "ManifestBuilderMapEntry",
    "ManifestBuilderNamedAddress",
    "ManifestBuilderProof",
    "ManifestProof",
    "MapEntry",
    "MetadataInitEntry",
    "MetadataModuleConfig",
    "MintFungibleResourceEvent",
    "MintNonFungibleResourceEvent",
    "MultiResourcePoolContributionEvent",
    "MultiResourcePoolDepositEvent",
    "MultiResourcePoolRedemptionEvent",
    "MultiResourcePoolWithdrawEvent",
    "OneResourcePoolContributionEvent",
    "OneResourcePoolDepositEvent",
    "OneResourcePoolRedemptionEvent",
    "OneResourcePoolWithdrawEvent",
    "PackageAddresses",
    "PlainTextMessage",
    "ProtocolUpdateReadinessSignalEvent",
    "RecoveryProposal",
    "RegisterValidatorEvent",
    "RemoveMetadataEvent",
    "ResourceAddresses",
    "ResourceManagerRole",
    "RoundChangeEvent",
    "RuleSet",
    "RuleSetUpdateEvent",
    "Schema",
    "Secp256k1PublicKey",
    "SecurityStructureRole",
    "SetAndLockOwnerRoleEvent",
    "SetAndLockRoleEvent",
    "SetMetadataEvent",
    "SetOwnerRoleEvent",
    "SetRoleEvent",
    "StakeEvent",
    "StopTimedRecoveryEvent",
    "TransactionHeader",
    "TransactionManifestModifications",
    "TwoResourcePoolContributionEvent",
    "TwoResourcePoolDepositEvent",
    "TwoResourcePoolRedemptionEvent",
    "TwoResourcePoolWithdrawEvent",
    "UnlockPrimaryRoleEvent",
    "UnregisterValidatorEvent",
    "UnstakeEvent",
    "UpdateAcceptingStakeDelegationStateEvent",
    "ValidatorEmissionAppliedEvent",
    "ValidatorInfo",
    "ValidatorRewardAppliedEvent",
    "VaultCreationEvent",
    "build_information",
    "derive_olympia_account_address_from_public_key",
    "derive_public_key_from_olympia_account_address",
    "derive_resource_address_from_olympia_resource_address",
    "derive_virtual_account_address_from_olympia_account_address",
    "derive_virtual_account_address_from_public_key",
    "derive_virtual_identity_address_from_public_key",
    "derive_virtual_signature_non_fungible_global_id_from_public_key",
    "hash",
    "known_addresses",
    "manifest_sbor_decode_to_string_representation",
    "metadata_sbor_decode",
    "metadata_sbor_encode",
    "non_fungible_local_id_as_str",
    "non_fungible_local_id_from_str",
    "non_fungible_local_id_sbor_decode",
    "non_fungible_local_id_sbor_encode",
    "sbor_decode_to_string_representation",
    "sbor_decode_to_typed_native_event",
    "scrypto_sbor_decode_to_string_representation",
    "test_panic",
    "AccessRule",
    "Address",
    "Decimal",
    "Hash",
    "Instructions",
    "Intent",
    "ManifestBuilder",
    "MessageValidationConfig",
    "NonFungibleGlobalId",
    "NotarizedTransaction",
    "OlympiaAddress",
    "PreciseDecimal",
    "PrivateKey",
    "SignedIntent",
    "TransactionBuilder",
    "TransactionBuilderHeaderStep",
    "TransactionBuilderIntentSignaturesStep",
    "TransactionBuilderMessageStep",
    "TransactionHash",
    "TransactionManifest",
    "ValidationConfig",
    "Signer",
]

