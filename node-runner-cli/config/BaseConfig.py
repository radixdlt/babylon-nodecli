from __future__ import annotations

import yaml

from deepdiff import DeepDiff


class BaseConfig:
    def __iter__(self):
        class_variables = {
            key: value
            for key, value in self.__class__.__dict__.items()
            if not key.startswith("__") and not callable(value)
        }
        for attr, value in class_variables.items():
            if self.__getattribute__(attr):
                yield attr, self.__getattribute__(attr)

    def __init__(self, config_dict: dict):
        class_variables = {
            key: value
            for key, value in self.__class__.__dict__.items()
            if not key.startswith("__") and not callable(value)
        }
        if config_dict is not None:
            for key, value in config_dict.items():
                try:
                    getattr(self, key)
                    if type(self.__getattribute__(key)) in [int, str, bool]:
                        setattr(self, key, value)
                except AttributeError:
                    pass

    def __repr__(self):
        return repr(vars(self))

    def __iter__(self):
        class_variables = {
            key: value
            for key, value in self.__class__.__dict__.items()
            if not key.startswith("__") and not callable(value)
        }
        for attr, value in class_variables.items():
            if self.__getattribute__(attr):
                yield attr, self.__getattribute__(attr)

    def to_dict(self):
        class_variables = {
            key: value
            for key, value in vars(self).items()
            if not key.startswith("__") and not callable(value)
        }
        returning_dict = dict(self)
        for attr, value in class_variables.items():
            returning_dict[attr] = ""
            if (
                type(self.__getattribute__(attr)) not in (str, int, bool, dict)
                and self.__getattribute__(attr) is not None
            ):
                returning_dict[attr] = self.__getattribute__(attr).to_dict()
            else:
                returning_dict[attr] = value
        return returning_dict

    def to_yaml(self):
        config_to_dump = self.to_dict()
        return yaml.dump(
            config_to_dump,
            sort_keys=True,
            default_flow_style=False,
            explicit_start=True,
            allow_unicode=True,
        )

    def to_file(self, config_file):
        config_to_dump = self.to_dict()
        with open(config_file, "w") as f:
            f.write("# WARNING!! This file is automatically generated and it is\n")
            f.write("# overriden when on install/update commands.\n")
            f.write("# Please consider re-running config/install commands rather\n")
            f.write("# than manually edit this file\n")
            yaml.dump(config_to_dump, f, sort_keys=True, default_flow_style=False)

    def compare_to_dict(self, config_as_dict: dict) -> dict:
        return dict(DeepDiff(config_as_dict, self.to_dict()))

    def compare_to_object(self, config_object: BaseConfig) -> dict:
        return dict(DeepDiff(config_object.to_dict(), self.to_dict()))


class SetupMode:
    _instance = None
    mode = None

    def __init__(self):
        raise RuntimeError("Call instance() instead")

    @classmethod
    def instance(cls):
        if cls._instance is None:
            cls._instance = cls.__new__(cls)
        return cls._instance
